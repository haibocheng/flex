<?xml version="1.0"?>
<apiPackage id="flash.filters"><apiName>flash.filters</apiName><apiDetail/><apiClassifier id="flash.filters:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
使用 ColorMatrixFilter 类可以将 4 x 5 矩阵转换应用于输入图像上的每个像素的 RGBA 颜色和 Alpha 值，以生成具有一组新的 RGBA 颜色和 Alpha 值的结果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>将颜色矩阵转换应用于每个像素的颜色和 Alpha 透明度值。
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
使用 ColorMatrixFilter 类可以将 4 x 5 矩阵转换应用于输入图像上的每个像素的 RGBA 颜色和 Alpha 值，以生成具有一组新的 RGBA 颜色和 Alpha 值的结果。该类允许饱和度更改、色相旋转、亮度为 Alpha 以及各种其它效果。您可以将滤镜应用于任何显示对象（即，从 DisplayObject 类继承的对象），例如 MovieClip、SimpleButton、TextField 和 Video 对象，以及 BitmapData 对象。

<p><b>注意：</b>对于 RGBA 值，最高有效字节代表红色通道值，其后的有效字节分别代表绿色、蓝色和 Alpha 通道值。</p>

<p>要创建新的颜色矩阵滤镜，请使用 <codeph>new ColorMatrixFilter()</codeph> 语法。滤镜的具体使用取决于要应用滤镜的对象：</p>
<ul><li>要对影片剪辑、文本字段、按钮和视频应用滤镜，请使用 <codeph>filters</codeph> 属性（继承自 DisplayObject）。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。 </li>

<li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并最终生成一个过滤图像。</li>
</ul>

<p>如果对显示对象应用滤镜，显示对象的 <codeph>cacheAsBitmap</codeph> 属性将设置为 <codeph>true</codeph>。如果删除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p>

<p>如果所得图像超过最大尺寸，则不应用滤镜。在 AIR 1.5 和 Flash Player 10 中，最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。例如，如果在放大某大型影片剪辑时应用了滤镜，则所得图像达到最大尺寸时，将关闭该滤镜。</p>

</apiDesc><example conref="examples\ColorMatrixFilterExample.as"> 以下示例将不同的颜色矩阵滤镜应用于图像文件。滤镜构造函数调用 <codeph>buildChild()</codeph> 四次，以加载和显示图像的四个实例。对 <codeph>buildChild()</codeph> 的第一次调用将 <codeph>null</codeph> 作为参数，不将滤镜应用于第一个实例。对 <codeph>buildChild()</codeph> 的每次后续调用都将函数作为参数，该函数将不同的颜色矩阵滤镜应用于图像的每个后续实例。
 <p><codeph>buildChild()</codeph> 函数创建一个名为 <codeph>loader</codeph> 的新 Loader 对象。每次调用 <codeph>buildChild()</codeph> 时，将一个事件侦听器附加到 Loader 对象，以侦听 <codeph>complete</codeph> 事件，这些事件由传递给 <codeph>buildChild()</codeph> 的函数处理。</p>
 
 <p><codeph>applyRed()</codeph>、<codeph>applyGreen()</codeph> 和 <codeph>applyBlue()</codeph> 函数使用 <codeph>matrix</codeph> 数组的不同值来实现不同的效果。</p>
 <p><b>注意</b>：为获得最佳效果，请使用宽度约为 80 像素的图像。图像文件的名称和位置应与您传递给 <codeph>url</codeph> 属性的值相匹配。例如，此示例中传递给 <codeph>url</codeph> 的值指向名为“Image.jpg”的图像文件，该图像文件与 SWF 文件位于同一目录中。
 </p>
 <codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.filters.ColorMatrixFilter;
    import flash.net.URLRequest;

    public class ColorMatrixFilterExample extends Sprite {
        private var size:uint  = 140;
        private var url:String = "Image.jpg";

        public function ColorMatrixFilterExample() {
            buildChild(null);
            buildChild(applyRed);
            buildChild(applyGreen);
            buildChild(applyBlue);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if (loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyRed(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([1, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyGreen(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 1, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyBlue(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>flash.display.BitmapData.getPixel()</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:ColorMatrixFilter:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
	用指定参数初始化新的 ColorMatrixFilter 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>由 20 个项目（排列成 4 x 5 矩阵）组成的数组。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>初始化新 ColorMatrixFilter 实例。
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	用指定参数初始化新的 ColorMatrixFilter 实例。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ColorMatrixFilter:clone"><apiName>clone</apiName><shortdesc>
	返回此滤镜对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
 	clones it using the <code>clone</code> method. The <code>matrix</code> property cannot be changed directly (for example,
	<code>clonedFilter.matrix[2] = 1;</code>). Instead, you must get a reference
	to the array, make the change, and reset the value using
	<code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter:       " + filter.matrix);
	
	var clonedFilter:ColorMatrixFilter = filter.clone();
	matrix = clonedFilter.matrix;
	matrix[2] = 1;
	clonedFilter.matrix = matrix;
	trace("clonedFilter: " + clonedFilter.matrix);
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>与原始实例具有完全相同的属性的新 ColorMatrixFilter 实例。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回此滤镜对象的副本。
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ColorMatrixFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	由 20 个项目组成的数组，适用于 4 x 5 颜色转换。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
  	changes its <code>matrix</code> property. The <code>matrix</code> property cannot be changed by directly modifying
  	its value (for example, <code>clonedFilter.matrix[2] = 1;</code>). Instead, you must
  	get a reference to the array, make the change to the reference, and reset the
	value using <code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter: " + filter.matrix);
	var changedMatrix:Array = filter.matrix;
	changedMatrix[2] = 1;
	filter.matrix = changedMatrix;
	trace("filter: " + filter.matrix);
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>设置时 Array 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	由 20 个项目组成的数组，适用于 4 x 5 颜色转换。<codeph>matrix</codeph> 属性不能通过直接修改它的值来更改（例如 <codeph>myFilter.matrix[2] = 1;</codeph>）。相反，必须先获取对数组的引用，对引用进行更改，然后重置该值。
	
	<p>颜色矩阵滤镜将每个源像素分离成它的红色、绿色、蓝色和 Alpha 成分，分别以 srcR、srcG、srcB 和 srcA 表示。要计算四个通道中每个通道的结果，可将图像中每个像素的值乘以转换矩阵中的值。（可选）可以将偏移量（介于 -255 至 255 之间）添加到每个结果（矩阵的每行中的第五项）中。滤镜将各颜色成分重新组合为单一像素，并写出结果。在下列公式中，a[0] 到 a[19] 对应于由 20 个项目组成的数组中的条目 0 至 19，该数组已传递到 <codeph>matrix</codeph> 属性：</p>
	<pre>
	redResult   = (a[0]  ~~ srcR) + (a[1]  ~~ srcG) + (a[2]  ~~ srcB) + (a[3]  ~~ srcA) + a[4]
	greenResult = (a[5]  ~~ srcR) + (a[6]  ~~ srcG) + (a[7]  ~~ srcB) + (a[8]  ~~ srcA) + a[9]
	blueResult  = (a[10] ~~ srcR) + (a[11] ~~ srcG) + (a[12] ~~ srcB) + (a[13] ~~ srcA) + a[14]
	alphaResult = (a[15] ~~ srcR) + (a[16] ~~ srcG) + (a[17] ~~ srcB) + (a[18] ~~ srcA) + a[19]
	</pre>
	
	<p>对于数组中的每个颜色值，值 1 等于正发送到输出的通道的 100%，同时保留颜色通道的值。</p>
	
	<p>计算是对非相乘的颜色值执行的。如果输入图形由预先相乘的颜色值组成，这些值会自动转换为非相乘的颜色值以执行此操作。</p>
	
	<p>可使用两种经过优化的模式：</p>
	
	<p><b>仅 Alpha。</b>当向滤镜传递仅调整 Alpha 成分的矩阵时，滤镜将优化其性能，如下所示：</p>
	<pre>
	    1 0 0 0 0
	    0 1 0 0 0
	    0 0 1 0 0
	    0 0 0 N 0  (where N is between 0.0 and 1.0)
	</pre>
	
	<p><b>更快的版本</b>。仅可用于启用 SSE/AltiVec 加速器的处理器，如 Intel<sup>®</sup> Pentium<sup>®</sup> 3 及更高版本、Apple<sup>®</sup> G4 及更高版本。当乘数项在 -15.99 到 15.99 之间，并且加数项 a[4]、a[9]、a[14] 和 a[19] 在 -8000 到 8000 之间时，将使用加速器。</p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
 可使用 GradientGlowFilter 类对显示对象应用渐变发光效果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>允许创建渐变发光效果。
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 可使用 GradientGlowFilter 类对显示对象应用渐变发光效果。渐变发光是一种非常逼真的发光效果，您可以控制颜色渐变。可以在对象的内缘或外缘的周围或者对象的顶部应用渐变发光。您可以将滤镜应用于任何显示对象（即，从 DisplayObject 类继承的对象），例如 MovieClip、SimpleButton、TextField 和 Video 对象，以及 BitmapData 对象。
 
 <p>滤镜的具体使用取决于要应用滤镜的对象：</p>
 <ul><li>要对显示对象应用滤镜，请使用 <codeph>filters</codeph> 属性。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。 </li>
 
 <li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并最终生成一个过滤图像。</li>
 </ul>
 
 <p>如果对显示对象应用滤镜，显示对象的 <codeph>cacheAsBitmap</codeph> 属性将设置为 <codeph>true</codeph>。如果清除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p> 
 
 <p>此滤镜支持舞台缩放。但是，它不支持常规缩放、旋转和倾斜；如果对象本身进行了缩放（如果将 <codeph>scaleX</codeph> 和 <codeph>scaleY</codeph> 设置为除 1.0 以外的其它值），滤镜效果将不进行缩放。只有用户在舞台上进行放大时它才会缩放。</p>
 
 <p>如果所得图像超过最大尺寸，则不应用滤镜。在 AIR 1.5 和 Flash Player 10 中，最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。例如，如果在放大某大型影片剪辑时应用了滤镜，则所得图像超过最大尺寸时，将关闭该滤镜。</p>
 
 </apiDesc><example conref="examples\GradientGlowFilterExample.as"> 以下示例将绘制一个正方形，并对它应用渐变发光滤镜。该示例的一般工作流程如下：
 <ol>
  <li>导入所需的类。</li>
  <li>声明用于定义正方形和滤镜的全局变量。</li>
  <li>创建构造函数，该函数执行以下操作：
      <ul>
          <li>调用 <codeph>draw()</codeph> 方法，该方法使用 Graphics 类的方法（通过 Sprite 的 <codeph>graphics</codeph> 属性访问）绘制一个正方形。</li>
          <li>创建名为 <codeph>filter</codeph> 的 BitmapFilter 对象，并将对 <codeph>getBitmapFilter()</codeph>（用于创建滤镜）的调用的返回值赋予它。</li>
          <li>创建一个名为 <codeph>myFilters</codeph> 的新数组，并将 <codeph>filter</codeph> 添加到该数组。</li>
          <li>将 <codeph>myFilters</codeph> 分配给 GradientGlowFilterExample 对象的 <codeph>filters</codeph> 属性。这将应用 <codeph>myFilters</codeph> 中包含的所有滤镜，在本例中仅为 <codeph>filter</codeph>。</li>
      </ul>
  </li>
 </ol>
<codeblock>
package {
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientGlowFilter;
    import flash.display.Sprite;

    public class GradientGlowFilterExample extends Sprite {
        private var bgColor:uint = 0xCCCCCC;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        private var distance:Number  = 0;
        private var angleInDegrees:Number = 45;
        private var colors:Array     = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
        private var alphas:Array     = [0, 1, 1, 1];
        private var ratios:Array     = [0, 63, 126, 255];
        private var blurX:Number     = 50;
        private var blurY:Number     = 50;
        private var strength:Number  = 2.5;
        private var quality:Number   = BitmapFilterQuality.HIGH;
        private var type:String      = BitmapFilterType.OUTER;
        private var knockout:Boolean = false;

        public function GradientGlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientGlowFilter(distance,
                                          angleInDegrees,
                                          colors,
                                          alphas,
                                          ratios,
                                          blurX,
                                          blurY,
                                          strength,
                                          quality,
                                          type,
                                          knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>GlowFilter 类</linktext></link></related-links><apiConstructor id="flash.filters:GradientGlowFilter:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
	用指定参数初始化滤镜。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a gradient glow filter, assigns 
	its values, and applies it to a flat rectangle image.
	
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var art:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	var distance:Number = 0;
	var angleInDegrees:Number = 45;
 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
 	var alphas:Array = [0, 1, 1, 1];
 	var ratios:Array = [0, 63, 126, 255];
	var blurX:Number = 50;
	var blurY:Number = 50;
	var strength:Number = 2.5;
	var quality:Number = 3;
	var type:String = "outer";
	var knockout:Boolean = false;
	
	var filter:GradientGlowFilter = new GradientGlowFilter(distance, 
														 angleInDegrees, 
														 colors, 
														 alphas, 
														 ratios, 
														 blurX, 
														 blurY, 
														 strength, 
														 quality, 
														 type, 
														 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	art.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
	mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>光晕的偏移距离。 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>角度，以度为单位。有效值为 0 到 360。 
	
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>定义渐变的颜色数组。例如，红色为 0xFF0000，蓝色为 0x0000FF 等等。
	
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc><codeph>colors</codeph> 数组中对应颜色的 Alpha 透明度值的数组。数组中每个元素的有效值为 0 到 1。例如，值 0.25 将 Alpha 透明度值设置为 25%。
	
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>颜色分布比例的数组。有效值为 0 到 255。该值定义颜色采样率为 100% 之处的宽度百分比。
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平模糊量。有效值为 0 到 255。如果模糊量小于或等于 1，则表明原始图像是按原样复制的。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直模糊量。有效值为 0 到 255。如果模糊量小于或等于 1，则表明原始图像是按原样复制的。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>印记或跨页的强度。该值越高，压印的颜色越深，而且发光与背景之间的对比度也越强。 有效值为 0 到 255。值越大，压印越强。值为 0 意味着未应用滤镜。
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>应用滤镜的次数。使用 BitmapFilterQuality 常量：
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>有关详细信息，请参阅 <codeph>quality</codeph> 属性的说明。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>滤镜效果的放置。可能的值是 flash.filters.BitmapFilterType 常量：
	<ul>
	<li><codeph>BitmapFilterType.OUTER</codeph> -- 对象外缘上的发光</li>
	<li><codeph>BitmapFilterType.INNER</codeph> -- 对象内缘上的发光；默认值。</li>
	<li><codeph>BitmapFilterType.FULL</codeph> -- 对象顶部的发光</li>
	</ul>
	
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指定对象是否具有挖空效果。应用挖空效果将使对象的填充变为透明，并显示文档的背景颜色。值为 <codeph>true</codeph> 将指定应用挖空效果；默认值为 <codeph>false</codeph>，即不应用挖空效果。
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	用指定参数初始化滤镜。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:GradientGlowFilter:clone"><apiName>clone</apiName><shortdesc>
	返回此滤镜对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GradientGlowFilter objects and compares them; <code>filter_1</code>
	is created by using the GradientGlowFilter construtor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example below modifies the <code>knockout</code> property of <code>filter_1</code>. Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>与原始 GradientGlowFilter 实例具有完全相同的属性的新 GradientGlowFilter 实例。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回此滤镜对象的副本。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientGlowFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	colors 数组中对应颜色的 Alpha 透明度值的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alphas</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAlphas");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var alphas:Array = filter.alphas;
		alphas.pop();
		alphas.pop();
		alphas.push(.3);
		alphas.push(1);
		filter.alphas = alphas;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>设置时 Array 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Alpha 透明度值的数组。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	<codeph>colors</codeph> 数组中对应颜色的 Alpha 透明度值的数组。数组中每个元素的有效值为 0 到 1。例如，0.25 将 Alpha 透明度值设置为 25%。
	
	<p><codeph>alphas</codeph> 属性不能通过直接修改它的值来进行更改。相反，必须获得对 <codeph>alphas</codeph> 的引用，对该引用进行更改，然后将 <codeph>alphas</codeph> 设置为该引用。</p>
	
	<p><codeph>colors</codeph>、<codeph>alphas</codeph> 和 <codeph>ratios</codeph> 属性是相关的。<codeph>colors</codeph> 数组中的第一个元素对应于 <codeph>alphas</codeph> 数组中的第一个元素以及 <codeph>ratios</codeph> 数组中的第一个元素，依此类推。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	角度，以度为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAngle");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 50;
		filter.angle = 90;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	角度，以度为单位。有效值为 0 到 360。默认值为 45。 
	
	<p>角度值表示理论上的光源落在对象上的角度，它决定了效果相对于该对象的位置。如果 <codeph>distance</codeph> 设置为 0，则效果相对于对象没有偏移，因此 <codeph>angle</codeph> 属性不起作用。</p>
        
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	 水平模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 水平模糊量。有效值为 0 到 255。如果模糊量小于或等于 1，则表明原始图像是按原样复制的。默认值为 4。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	 垂直模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 垂直模糊量。有效值为 0 到 255。如果模糊量小于或等于 1，则表明原始图像是按原样复制的。默认值为 4。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:colors:get"><apiName>colors</apiName><shortdesc>
	 定义渐变的颜色数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>colors</code> property on an existing movie clip 
	 when a user clicks it.
	 <listing version="2.0">
	 import flash.filters.GradientGlowFilter;
	 var mc:MovieClip = createGradientGlowRectangle("GlowColors");
	 mc.onRelease = function() {
	 	var filter:GradientGlowFilter = this.filters[0];
	 	var colors:Array = filter.colors;
	 	colors.pop();
	 	colors.push(0xFF00FF);
	 	filter.colors = colors;
	 	this.filters = new Array(filter);
	 }
	 
	 function createGradientGlowRectangle(name:String):MovieClip {
	 	var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
	 	var w:Number = 100;
	 	var h:Number = 100;
	 	art.beginFill(0x003366);
	 	art.lineTo(w, 0);
	 	art.lineTo(w, h);
	 	art.lineTo(0, h);
	 	art.lineTo(0, 0);
	 	art._x = 20;
	 	art._y = 20;
	 
	 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	 	var alphas:Array = [0, 1, 1, 1];
	 	var ratios:Array = [0, 63, 126, 255];
	 	var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	 	var filterArray:Array = new Array();
	 	filterArray.push(filter);
	 	art.filters = filterArray;
	 	return art;
	 }
	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>设置时 Array 为 null
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 定义渐变的颜色数组。例如，红色为 0xFF0000，蓝色为 0x0000FF 等等。
	 
	 <p><codeph>colors</codeph> 属性不能通过直接修改它的值来进行更改。相反，必须获得对 <codeph>colors</codeph> 的引用，对该引用进行更改，然后将 <codeph>colors</codeph> 设置为该引用。</p>
	 
	 <p><codeph>colors</codeph>、<codeph>alphas</codeph> 和 <codeph>ratios</codeph> 属性是相关的。<codeph>colors</codeph> 数组中的第一个元素对应于 <codeph>alphas</codeph> 数组中的第一个元素以及 <codeph>ratios</codeph> 数组中的第一个元素，依此类推。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	光晕的偏移距离。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowDistance");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 20;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	光晕的偏移距离。默认值为 4。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	指定对象是否具有挖空效果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowKnockout");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}

	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	指定对象是否具有挖空效果。 应用挖空效果将使对象的填充变为透明，并显示文档的背景颜色。值为 <codeph>true</codeph> 将指定应用挖空效果；默认值为 <codeph>false</codeph>，即不应用挖空效果。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	应用滤镜的次数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowQuality");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.quality = 3;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	应用滤镜的次数。默认值为 <codeph>BitmapFilterQuality.LOW</codeph>，与应用一次滤镜等效。值 <codeph>BitmapFilterQuality.MEDIUM</codeph> 两次应用滤镜；值 <codeph>BitmapFilterQuality.HIGH</codeph> 三次应用滤镜。滤镜的值越小，呈现速度越快。
	
	<p>对于大多数应用，<codeph>quality</codeph> 的值为低、中或高就足够了。您可以使用其他数值（最高为 15）来达到不同的效果，但是值越高，呈现速度越慢。除了增加 <codeph>quality</codeph> 的值，仅增加 <codeph>blurX</codeph> 和 <codeph>blurY</codeph> 属性的值通常也可以获得类似的效果，而且呈现速度更快。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	对应于 colors 数组中颜色的一组颜色分布比率。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>ratios</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowRatios");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var ratios:Array = filter.ratios;
		ratios.shift();
		ratios.unshift(40);
		filter.ratios = ratios;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>设置时 Array 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	对应于 <codeph>colors</codeph> 数组中颜色的一组颜色分布比率。有效值为 0 到 255。 
	
	<p><codeph>ratios</codeph> 属性不能通过直接修改它的值来进行更改。相反，必须获得对 <codeph>ratios</codeph> 的引用，对该引用进行更改，然后将 <codeph>ratios</codeph> 设置为该引用。</p>
	
	<p><codeph>colors</codeph>、<codeph>alphas</codeph> 和 <codeph>ratios</codeph> 属性是相关的。<codeph>colors</codeph> 数组中的第一个元素对应于 <codeph>alphas</codeph> 数组中的第一个元素以及 <codeph>ratios</codeph> 数组中的第一个元素，依此类推。</p>
	
	<p>如果 <codeph>distance</codeph> 值设置为 0，则将渐变发光滤镜看作从对象中心发出的具有渐变（即相互混合的颜色条纹）的发光。<codeph>colors</codeph> 数组中的第一种颜色是光晕最外面的颜色。最后一种颜色是光晕最里面的颜色。</p> 
	
	<p><codeph>ratios</codeph> 数组中的每个值设置颜色在渐变的半径上的位置，其中 0 表示渐变最外面的点，255 表示渐变最里面的点。比例值范围是从 0 到 255 像素，它们的值依次增加；例如 [0, 64, 128, 200, 255]。从 0 到 128 的值出现在光晕的外缘上。从 129 到 255 的值出现在光晕的内侧区域中。根据颜色的比例值和滤镜的 <codeph>type</codeph> 值，滤镜颜色可能会被应用滤镜的对象遮住。</p>
	
	<p>在下面的代码和图像中，将滤镜应用于黑色的圆影片剪辑，并将类型设置为 <codeph>"full"</codeph>。基于教学目的，<codeph>colors</codeph> 数组中的第一种颜色（粉色）的 <codeph>alpha</codeph> 值为 1，以便与白色文档背景形成鲜明对比。（实际上，您可能不希望这样显示第一种颜色。） 数组中的最后一种颜色（黄色）遮住了应用滤镜的黑色圆盘：</p>
	
	<p><pre>
	var colors:Array = [0xFFCCFF, 0x0000FF, 0x9900FF, 0xFF0000, 0xFFFF00];
	var alphas:Array = [1, 1, 1, 1, 1];
	var ratios:Array = [0, 32, 64, 128, 225];
	var myGGF:GradientGlowFilter = new GradientGlowFilter(0, 0, colors, alphas, ratios, 50, 50, 1, 2, "full", false);
	</pre></p>
    <p><adobeimage alt="ratios 数组为 0, 32, 64, 128, 225 的渐变发光滤镜。" href="../../images/gradientGlowDiagram.jpg"/></p>
	
	<p>要在将 <codeph>type</codeph> 值设置为 <codeph>"outer"</codeph> 或 <codeph>"full"</codeph> 时实现与文档背景的无缝效果，请将数组中的第一种颜色设置为与文档背景相同的颜色，或将第一种颜色的 Alpha 值设置为 0；或者使用技巧将滤镜与背景混合在一起。</p>
	
	<p>如果在代码中进行两处小的更改，发光效果可能会大不相同，即使采用相同的 <codeph>ratios</codeph> 和 <codeph>colors</codeph> 数组。将数组中第一种颜色的 Alpha 值设置为 0，以便滤镜和文档的白色背景混合在一起；并将 <codeph>type</codeph> 属性设置为 <codeph>"outer"</codeph> 或 <codeph>"inner"</codeph>。观察结果，如下面的图像所示。</p>
        <p><adobeimage alt="外发光" href="../../images/gradientGlowOuter.jpg"/><adobeimage alt="内发光" href="../../images/gradientGlowInner.jpg"/></p>
	<p>请记住，颜色在渐变中的散布基于 <codeph>blurX</codeph>、<codeph>blurY</codeph>、<codeph>strength</codeph> 和 <codeph>quality</codeph> 属性的值以及 <codeph>ratios</codeph> 值。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	印记或跨页的强度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowStrength");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	印记或跨页的强度。 该值越高，压印的颜色越深，而且发光与背景之间的对比度也越强。 有效值为 0 到 255。  值为 0 表示未应用滤镜。 默认值为 1。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:type:get"><apiName>type</apiName><shortdesc>
	滤镜效果的放置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowType");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.type = "inner";
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>设置时 String 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	滤镜效果的放置。可能的值是 flash.filters.BitmapFilterType 常量：
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> -- 对象外缘上的发光</li>
	<li><codeph>BitmapFilterType.INNER</codeph> -- 对象内缘上的发光；默认值。</li>
	<li><codeph>BitmapFilterType.FULL</codeph> -- 对象顶部的发光</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
DisplacementMapFilter 类使用指定的 BitmapData 对象（称为置换图图像）的像素值执行对象置换。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>置换滤镜应用于的原始对象。
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
DisplacementMapFilter 类使用指定的 BitmapData 对象（称为<i>置换图图像</i>）的像素值执行对象置换。您可以使用此滤镜将扭曲或斑点效果应用于从 DisplayObject 类中继承的任何对象，例如 MovieClip、SimpleButton、TextField 和 Video 对象，以及 BitmapData 对象。

<p>滤镜的具体使用取决于要应用滤镜的对象：</p>
<ul><li>要将滤镜应用于显示对象，请使用显示对象的 <codeph>filters</codeph> 属性。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。 </li>

<li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并生成一个过滤后的图像。</li>
</ul>

<p>如果对显示对象应用滤镜，则该显示对象的 <codeph>cacheAsBitmap</codeph> 属性值将设置为 <codeph>true</codeph>。如果清除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p>

<p>此滤镜使用以下公式：</p>

<codeblock>
dstPixel[x, y] = srcPixel[x + ((componentX(x, y) - 128) ~~ scaleX) / 256, y + ((componentY(x, y) - 128) ~~scaleY) / 256)
</codeblock>

<p>其中，<codeph>componentX(x, y)</codeph> 从 <codeph>mapBitmap</codeph> 属性获得 <codeph>(x - mapPoint.x ,y - mapPoint.y)</codeph> 处的 <codeph>componentX</codeph> 属性颜色值。</p>

<p>滤镜使用的映射图像会进行缩放，以匹配舞台缩放比例。当对象自身呈一定的比例时，它不会进行缩放。</p>

<p>此滤镜支持舞台缩放。但不支持常规缩放、旋转和倾斜。如果对象本身进行了缩放（如果将 <codeph>scaleX</codeph> 和 <codeph>scaleY</codeph> 属性设置为除 1.0 以外的其它值），滤镜效果将不进行缩放。只有用户在舞台上进行放大时它才会缩放。</p>

 </apiDesc><example conref="examples\DisplacementMapFilterExample.as"> 以下示例通过放射状渐变填充绘制一个正方形，创建一个文本字段和一个 BitmapData 对象，并将置换图滤镜应用于 DisplacementMapFilterExample 对象。该示例的一般工作流程如下：
 <ol>
  <li>该类为背景颜色、文本字段标签以及将用于各种函数的大小和偏移定义变量。</li>
  <li>构造函数调用 <codeph>draw()</codeph> 方法，该方法使用 Graphics 类的方法通过放射状渐变填充绘制一个正方形。请注意，<codeph>graphics</codeph> 是扩展 Sprite 的 DisplacementMapFilterExample 对象的属性。</li>
  <li>构造函数调用 <codeph>createLabel()</codeph> 方法，该方法创建显示 <codeph>labelText</codeph> 值的文本字段，并将其添加到显示列表。</li>
  <li>构造函数调用 <codeph>createFilter()</codeph> 方法，该方法执行以下操作：
      <ul>
          <li>为滤镜对象创建名为 <codeph>filter</codeph> 的变量。</li>
          <li>调用 <codeph>getDisplacementMapFilter()</codeph> 方法并将其返回值赋予 <codeph>filter</codeph> 变量。</li>
          <li>将 <codeph>filter</codeph> 传递给 DisplacementFilterExample 对象（主类）的 <codeph>filters</codeph> 属性。</li>
      </ul>
   </li> 
  <li><codeph>getBitmapFilter()</codeph> 方法创建一个名为 <codeph>mapBitmap</codeph> 的 BitmapData 对象，并将 <codeph>createBitmapData()</codeph> 方法的结果赋予它。<codeph>mapBitmap</codeph> 对象以及其它变量定义了新的置换图滤镜。</li>
  <li><codeph>createBitmapData()</codeph> 方法创建新的 BitmapData 对象，该对象基于 DisplacementMapFilterExample 对象的当前内容。它基于 <codeph>bitmapData</codeph> 创建新位图，并将该位图添加到舞台。</li>
 </ol>
<codeblock>
package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.BitmapDataChannel;
    import flash.display.GradientType;
    import flash.display.SpreadMethod;
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.DisplacementMapFilter;
    import flash.filters.DisplacementMapFilterMode;
    import flash.geom.Matrix;
    import flash.geom.Point;
    import flash.text.TextField;
    
    public class DisplacementMapFilterExample extends Sprite {
        private var bgColor:uint     = 0xFFCC00;
        private var size:uint        = 200;
        private var offset:uint      = 90;
        private var labelText:String = "Watch the text bend with the displacement map";

        public function DisplacementMapFilterExample() {
            draw();
            createLabel();
            createFilter();
        }

        private function createFilter():void {
            var filter:BitmapFilter = getBitmapFilter();
            filters = new Array(filter);
        }

        private function getBitmapFilter():BitmapFilter {
            var mapBitmap:BitmapData = createBitmapData();
            var mapPoint:Point       = new Point(0, 0);
            var channels:uint        = BitmapDataChannel.RED;
            var componentX:uint      = channels;
            var componentY:uint      = channels;
            var scaleX:Number        = 0.5;
            var scaleY:Number        = -30;
            var mode:String          = DisplacementMapFilterMode.CLAMP;
            var color:uint           = 0;
            var alpha:Number         = 0;
            return new DisplacementMapFilter(mapBitmap,
                                             mapPoint,
                                             componentX,
                                             componentY,
                                             scaleX,
                                             scaleY,
                                             mode,
                                             color,
                                             alpha);
        }

        private function draw():void {
            var matrix:Matrix = new Matrix();
            matrix.createGradientBox(size, size);
            graphics.beginGradientFill(GradientType.RADIAL,
                                       [0xFF0000, 0x0000FF],
                                       [100, 100],
                                       [55, 200],
                                       matrix,
                                       SpreadMethod.PAD);
            graphics.drawRect(0, 0, size, size);
        }

        private function createBitmapData():BitmapData {
            var bitmapData:BitmapData = new BitmapData(size, size, true, bgColor);
            bitmapData.draw(this, new Matrix());
            var bitmap:Bitmap = new Bitmap(bitmapData);
            bitmap.x = size;
            addChild(bitmap);
            return bitmapData;
        }

        private function createLabel():void {
            var tf:TextField = new TextField();
            tf.text = labelText;
            tf.y = offset;
            tf.width = size;
            addChild(tf);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DisplacementMapFilter:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
	用指定参数初始化 DisplacementMapFilter 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><category>Constructor
	 
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>mapBitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>包含置换映射数据的 BitmapData 对象。
	</apiDesc></apiParam><apiParam><apiItemName>mapPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>一个值，它包含目标显示对象的左上角相对于映射图像左上角的偏移量。
	</apiDesc></apiParam><apiParam><apiItemName>componentX</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>说明在映射图像中使用哪个颜色通道来置换 <i>x</i> 结果。可能的值为 BitmapDataChannel 常量。 
	</apiDesc></apiParam><apiParam><apiItemName>componentY</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>说明在映射图像中使用哪个颜色通道来置换 <i>y</i> 结果。可能的值为 BitmapDataChannel 常量。 
	</apiDesc></apiParam><apiParam><apiItemName>scaleX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>用于缩放映射计算的 <i>x</i> 置换结果的乘数。
	</apiDesc></apiParam><apiParam><apiItemName>scaleY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>用于缩放映射计算的 <i>y</i> 置换结果的乘数。
	</apiDesc></apiParam><apiParam><apiItemName>mode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>wrap</apiData><apiDesc>滤镜模式。可能的值为 DisplacementMapFilterMode 常量。
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>指定对于超出范围的替换应用什么颜色。置换的有效范围是 0.0 到 1.0。如果 <codeph>mode</codeph> 设置为 <codeph>DisplacementMapFilterMode.COLOR</codeph>，则使用此参数。
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>指定对于超出范围的替换应用什么 Alpha 值。它被指定为 0.0 到 1.0 之间的标准值。例如，.25 设置透明度值为 25%。如果 <codeph>mode</codeph> 设置为 <codeph>DisplacementMapFilterMode.COLOR</codeph>，则使用此参数。
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>初始化 DisplacementMapFilter 实例。
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	用指定参数初始化 DisplacementMapFilter 实例。
	
   	</apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DisplacementMapFilter:clone"><apiName>clone</apiName><shortdesc>
	返回此滤镜对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>DisplacementMapFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>DisplacementMapFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}		
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>mode</code> property of <code>filter_1</code>.  Modifying <code>mode</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1.mode);			// wrap
	trace(filter_2.mode);			// wrap
	trace(clonedFilter.mode);		// wrap
		
	filter_1.mode = "ignore";
	
	trace(filter_1.mode);			// ignore
	trace(filter_2.mode);			// ignore
	trace(clonedFilter.mode);		// wrap
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>具有与原始实例相同的所有属性的新 DisplacementMapFilter 实例。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回此滤镜对象的副本。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DisplacementMapFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	指定对于超出范围的替换应用的 Alpha 透明度值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>alpha</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	指定对于超出范围的替换应用的 Alpha 透明度值。它被指定为 0.0 到 1.0 之间的标准值。例如，.25 设置透明度值为 25%。默认值为 0。如果 <codeph>mode</codeph> 属性设置为 <codeph>DisplacementMapFilterMode.COLOR</codeph>，则使用此属性。  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:color:get"><apiName>color</apiName><shortdesc>
	指定对于超出范围的替换应用什么颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>color</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		filter.color = 0x00FF00;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	指定对于超出范围的替换应用什么颜色。置换的有效范围是 0.0 到 1.0。值采用十六进制格式。<codeph>color</codeph> 的默认值为 0。如果 <codeph>mode</codeph> 属性设置为 <codeph>DisplacementMapFilterMode.COLOR</codeph>，则使用此属性。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentX:get"><apiName>componentX</apiName><shortdesc>
	说明在映射图像中使用哪个颜色通道来置换 x 结果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.  It changes the value from 1 to 4 which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentX = 4;
		this.filters = new Array(filter);
	}
	
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiTipTexts><apiTipText>用于置换 x 结果的颜色通道。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	说明在映射图像中使用哪个颜色通道来置换 <i>x</i> 结果。可能的值为 BitmapDataChannel 常量：
	<ul>
		<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	<li><codeph>BitmapDataChannel.BLUE</codeph></li>
	<li><codeph>BitmapDataChannel.GREEN</codeph></li>
	<li><codeph>BitmapDataChannel.RED</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentY:get"><apiName>componentY</apiName><shortdesc>
	 说明在映射图像中使用哪个颜色通道来置换 y 结果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks it.  The value changes from 1 to 4, which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentY = 4;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 说明在映射图像中使用哪个颜色通道来置换 <i>y</i> 结果。可能的值为 BitmapDataChannel 常量：
	 <ul>
	 	<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
         </ul>
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapBitmap:get"><apiName>mapBitmap</apiName><shortdesc>
	包含置换映射数据的 BitmapData 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapBitmap</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	var scope:Object = this;
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapBitmap = scope.createGradientBitmap(300, 80, 0xFF000000, "linear");
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	
	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier><apiException><apiDesc>设置时 BitmapData 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	包含置换映射数据的 BitmapData 对象。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapPoint:get"><apiName>mapPoint</apiName><shortdesc>
	一个值，它包含目标显示对象的左上角相对于映射图像左上角的偏移量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapPoint</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapPoint = new Point(-30, -40);
		this.filters = new Array(filter);
		this._x = 30;
		this._y = 40;
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>设置时 Point 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	一个值，它包含目标显示对象的左上角相对于映射图像左上角的偏移量。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mode:get"><apiName>mode</apiName><shortdesc>
	滤镜模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example modifies <code>scaleY</code> inorder to create a displacement
	value that is out of range and then changes the <code>mode</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>ignore</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "ignore";
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	</oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>设置时 String 为 null
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>模式字符串不是有效类型之一
	
	</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	滤镜模式。可能的值为 DisplacementMapFilterMode 常量：
	<ul>
	<li><codeph>DisplacementMapFilterMode.WRAP</codeph> -- 将置换值折返到源图像的另一侧。</li>
	<li><codeph>DisplacementMapFilterMode.CLAMP</codeph> -- 将置换值锁定在源图像的边缘。</li>
	<li><codeph>DisplacementMapFilterMode.IGNORE</codeph> -- 如果置换值超出了范围，则忽略置换并使用源像素。</li>
	<li><codeph>DisplacementMapFilterMode.COLOR</codeph> -- 如果置换值在图像之外，则替换 <codeph>color</codeph> 和 <codeph>alpha</codeph> 属性中的值。</li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleX:get"><apiName>scaleX</apiName><shortdesc>
	用于缩放映射计算的 x 置换结果的乘数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleX = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	用于缩放映射计算的 <i>x</i> 置换结果的乘数。
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleY:get"><apiName>scaleY</apiName><shortdesc>
	用于缩放映射计算的 y 置换结果的乘数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	用于缩放映射计算的 <i>y</i> 置换结果的乘数。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterType"><apiName>BitmapFilterType</apiName><shortdesc>
BitmapFilterType 类中包含的值可用于设置 BitmapFilter 的类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
BitmapFilterType 类中包含的值可用于设置 BitmapFilter 的类型。

</apiDesc><example conref="examples\BitmapFilterTypeExample.as"> 以下示例将绘制一个灰色正方形，并对它应用 BevelFilter 对象。该示例使用常量 <codeph>BitmapFilterType.HIGH</codeph> 设置 <codeph>type</codeph> 属性。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterTypeExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterTypeExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterType:FULL"><apiName>FULL</apiName><shortdesc>
	定义对对象的整个区域应用滤镜的设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	定义对对象的整个区域应用滤镜的设置。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:INNER"><apiName>INNER</apiName><shortdesc>
	定义对对象的内侧区域应用滤镜的设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>inner</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	定义对对象的内侧区域应用滤镜的设置。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:OUTER"><apiName>OUTER</apiName><shortdesc>
	定义对对象的外侧区域应用滤镜的设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>outer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	定义对对象的外侧区域应用滤镜的设置。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
可使用 DropShadowFilter 类向显示对象添加投影。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
可使用 DropShadowFilter 类向显示对象添加投影。阴影算法基于模糊滤镜使用的同一个框型滤镜。投影样式有多个选项，包括内侧或外侧阴影和挖空模式。您可以将滤镜应用于任何显示对象（即，从 DisplayObject 类继承的对象），例如 MovieClip、SimpleButton、TextField 和 Video 对象，以及 BitmapData 对象。

<p>滤镜的具体使用取决于要应用滤镜的对象：</p>
 <ul><li>要对显示对象应用滤镜，请使用 <codeph>filters</codeph> 属性（继承自 DisplayObject）。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。 </li>
 
 <li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并最终生成一个过滤图像。</li>
 </ul>

<p>如果对显示对象应用滤镜，则该显示对象的 <codeph>cacheAsBitmap</codeph> 属性值将设置为 <codeph>true</codeph>。如果清除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p>
 <p>此滤镜支持舞台缩放。但是，它不支持常规缩放、旋转和倾斜。如果对象本身进行了缩放（如果将 <codeph>scaleX</codeph> 和 <codeph>scaleY</codeph> 设置为除 1.0 以外的其它值），滤镜将不进行缩放。只有用户在舞台上进行放大时它才会缩放。</p>
 
 <p>如果所得图像超过最大尺寸，则不应用滤镜。在 AIR 1.5 和 Flash Player 10 中，最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。例如，如果在放大某大型影片剪辑时应用了滤镜，则所得图像超过最大尺寸时，将关闭该滤镜。</p>

</apiDesc><example conref="examples\DropShadowFilterExample.as"> 以下示例将创建一个黄色正方形，并对它应用投影。该示例的一般工作流程如下：
 <ol>
  <li>声明用于绘制正方形的三个属性，将对该正方形应用滤镜。</li>
  <li>创建构造函数。构造函数调用 <codeph>draw()</codeph> 方法，该方法使用 Graphics 类的方法（通过 Sprite 的 <codeph>graphics</codeph> 属性访问）绘制一个橙色正方形。</li>
  <li>在构造函数中，将变量 <codeph>filter</codeph> 声明为 BitmapFilter 对象，并将它分配给对 <codeph>getBitmapFilter()</codeph> 的调用的返回值。<codeph>getBitmapFilter()</codeph> 方法定义已使用的投影滤镜。</li>
  <li>创建一个新的 Array 对象 <codeph>myFilters</codeph> 并将 <codeph>filter</codeph> 添加到数组。将 <codeph>myFilters</codeph> 数组分配给 DropShadowFilterExample 对象的 <codeph>filters</codeph> 属性。这将应用 <codeph>myFilters</codeph> 中包含的所有滤镜，在本例中仅为 <codeph>filter</codeph>。</li>
  </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.DropShadowFilter;

    public class DropShadowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function DropShadowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x000000;
            var angle:Number = 45;
            var alpha:Number = 0.8;
            var blurX:Number = 8;
            var blurY:Number = 8;
            var distance:Number = 15;
            var strength:Number = 0.65;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;
            return new DropShadowFilter(distance,
                                        angle,
                                        color,
                                        alpha,
                                        blurX,
                                        blurY,
                                        strength,
                                        quality,
                                        inner,
                                        knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DropShadowFilter:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
	用指定参数创建新的 DropShadowFilter 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example creates a new DropShadowFilter object
	with the default values:
	<pre>
	myFilter = new flash.filters.DropShadowFilter()
	</pre>
	 
	 </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>阴影的偏移距离，以像素为单位。 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>阴影的角度，0 到 360 度（浮点）。 
	
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>阴影颜色，采用十六进制格式 <i>0xRRGGBB</i>。默认值为 0x000000。
	
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>阴影颜色的 Alpha 透明度值。有效值为 0.0 到 1.0。例如，.25 设置透明度值为 25%。 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平模糊量。有效值为 0 到 255.0（浮点）。 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直模糊量。有效值为 0 到 255.0（浮点）。 
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>印记或跨页的强度。该值越高，压印的颜色越深，而且阴影与背景之间的对比度也越强。有效值为 0 到 255.0。 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>应用滤镜的次数。使用 BitmapFilterQuality 常量：
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>有关这些值的详细信息，请参阅 <codeph>quality</codeph> 属性说明。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>表示阴影是否为内侧阴影。值 <codeph>true</codeph> 指定内侧阴影。值 <codeph>false</codeph> 指定外侧阴影（对象外缘周围的阴影）。
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>应用挖空效果 (<codeph>true</codeph>)，这将有效地使对象的填色变为透明，并显示文档的背景颜色。 
	
	</apiDesc></apiParam><apiParam><apiItemName>hideObject</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>表示是否隐藏对象。如果值为 <codeph>true</codeph>，则表示没有绘制对象本身，只有阴影是可见的。 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	用指定参数创建新的 DropShadowFilter 实例。
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DropShadowFilter:clone"><apiName>clone</apiName><shortdesc>
	返回此滤镜对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three DropShadowFilter objects and compares them.  <code>filter_1</code>
	is created using the DropShadowFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>具有原始 DropShadowFilter 实例的所有属性的新 DropShadowFilter 实例。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回此滤镜对象的副本。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DropShadowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	阴影颜色的 Alpha 透明度值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAlpha");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	阴影颜色的 Alpha 透明度值。有效值为 0.0 到 1.0。例如，.25 设置透明度值为 25%。默认值为 1.0。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	阴影的角度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAngle");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.angle = 135;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	阴影的角度。有效值为 0 到 360 度（浮点）。默认值为 45。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurX");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurX = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平模糊量。有效值为 0 到 255.0（浮点）。默认值为 4.0。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurY");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurY = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直模糊量。有效值为 0 到 255.0（浮点）。默认值为 4.0。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:color:get"><apiName>color</apiName><shortdesc>
	阴影的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowColor");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.color = 0xFF0000;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	阴影的颜色。有效值采用十六进制格式 <i>0xRRGGBB</i>。默认值为 0x000000。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	阴影的偏移距离，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowDistance");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.distance = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	阴影的偏移距离，以像素为单位。默认值为 4.0（浮点）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:hideObject:get"><apiName>hideObject</apiName><shortdesc>
	表示是否隐藏对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>hideObject</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowHideObject");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.hideObject = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	表示是否隐藏对象。如果值为 <codeph>true</codeph>，则表示没有绘制对象本身，只有阴影是可见的。默认值为 <codeph>false</codeph>（显示对象）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	表示阴影是否为内侧阴影。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowInner");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	表示阴影是否为内侧阴影。值为 <codeph>true</codeph> 表明是内侧阴影。默认为 <codeph>false</codeph>，即外侧阴影（对象外缘周围的阴影）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	应用挖空效果 (true)，这将有效地使对象的填色变为透明，并显示文档的背景颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowKnockout");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	应用挖空效果 (<codeph>true</codeph>)，这将有效地使对象的填色变为透明，并显示文档的背景颜色。默认值为 <codeph>false</codeph>（不应用挖空效果）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	 应用滤镜的次数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowQuality");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.quality = 0;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 应用滤镜的次数。默认值为 <codeph>BitmapFilterQuality.LOW</codeph>，与应用一次滤镜等效。值 <codeph>BitmapFilterQuality.MEDIUM</codeph> 两次应用滤镜；值 <codeph>BitmapFilterQuality.HIGH</codeph> 三次应用滤镜。滤镜的值越小，呈现速度越快。
	 
	 <p>对于大多数应用，quality 的值为低、中或高就足够了。您可以使用其他数值（最高为 15）来达到不同的效果，但是值越高，呈现速度越慢。除了增加 <codeph>quality</codeph> 的值，仅增加 <codeph>blurX</codeph> 和 <codeph>blurY</codeph> 属性的值通常也可以获得类似的效果，而且呈现速度更快。</p>
         </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:DropShadowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	印记或跨页的强度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowStrength");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.strength = .6;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	印记或跨页的强度。该值越高，压印的颜色越深，而且阴影与背景之间的对比度也越强。有效值为 0 到 255.0。默认值为 1.0。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterQuality"><apiName>BitmapFilterQuality</apiName><shortdesc>
BitmapFilterQuality 类中包含的值用于设置 BitmapFilter 对象的呈现品质。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
BitmapFilterQuality 类中包含的值用于设置 BitmapFilter 对象的呈现品质。

</apiDesc><example conref="examples\BitmapFilterQualityExample.as"> 以下示例将绘制一个灰色正方形，并对它应用 BevelFilter 对象。该示例使用常量 <codeph>BitmapFilterQuality.HIGH</codeph> 设置 <codeph>quality</codeph> 属性。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterQualityExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterQualityExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>BlurFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>GlowFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>DropShadowFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
	定义高品质滤镜设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	定义高品质滤镜设置。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:LOW"><apiName>LOW</apiName><shortdesc>
	定义低品质滤镜设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	定义低品质滤镜设置。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
	定义中等品质滤镜设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	定义中等品质滤镜设置。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilterMode"><apiName>DisplacementMapFilterMode</apiName><shortdesc>
DisplacementMapFilterMode 类为 DisplacementMapFilter 类的 mode 属性提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
DisplacementMapFilterMode 类为 DisplacementMapFilter 类的 <codeph>mode</codeph> 属性提供值。

</apiDesc></apiClassifierDetail><apiValue id="flash.filters:DisplacementMapFilterMode:CLAMP"><apiName>CLAMP</apiName><shortdesc>
	将置换值锁定在源图像的边缘。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>clamp</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	将置换值锁定在源图像的边缘。用于 <codeph>DisplacementMapFilter.mode</codeph> 属性。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:COLOR"><apiName>COLOR</apiName><shortdesc>
	如果置换值在图像之外，则替换 color 和 alpha 属性中的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>color</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	如果置换值在图像之外，则替换 <codeph>color</codeph> 和 <codeph>alpha</codeph> 属性中的值。用于 <codeph>DisplacementMapFilter.mode</codeph> 属性。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:IGNORE"><apiName>IGNORE</apiName><shortdesc>
	如果置换值超出了范围，则忽略置换并使用源像素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>ignore</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	如果置换值超出了范围，则忽略置换并使用源像素。用于 <codeph>DisplacementMapFilter.mode</codeph> 属性。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:WRAP"><apiName>WRAP</apiName><shortdesc>
	将置换值折返到源图像的另一侧。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>wrap</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	将置换值折返到源图像的另一侧。用于 <codeph>DisplacementMapFilter.mode</codeph> 属性。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.filters:BevelFilter"><apiName>BevelFilter</apiName><shortdesc> 
 可使用 BevelFilter 类对显示对象添加斜角效果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>添加斜角效果。 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc> 
 可使用 BevelFilter 类对显示对象添加斜角效果。斜角效果使对象（如按钮）具有三维外观。您可以利用不同的加亮颜色和阴影颜色、斜角上的模糊量、斜角的角度、斜角的位置和挖空效果来自定义斜角的外观。您可以将滤镜应用于任何显示对象（即，从 DisplayObject 类继承的对象），例如 MovieClip、SimpleButton、TextField 和 Video 对象，以及 BitmapData 对象。
 
 <p>要创建新滤镜，请使用构造函数 <codeph>new BevelFilter()</codeph>。滤镜的具体使用取决于要应用滤镜的对象：</p>
 <ul><li>要对影片剪辑、文本字段、按钮和视频应用滤镜，请使用 <codeph>filters</codeph> 属性（继承自 DisplayObject）。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。 </li>
 
 <li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并最终生成一个过滤图像。</li>
 </ul>
 
 <p>如果对显示对象应用滤镜，则该对象的 <codeph>cacheAsBitmap</codeph> 属性值将设置为 <codeph>true</codeph>。如果删除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p>
 
 <p>此滤镜支持舞台缩放。但是，它不支持常规缩放、旋转和倾斜。如果对象本身进行了缩放（如果 <codeph>scaleX</codeph> 和 <codeph>scaleY</codeph> 属性未被设置为 100%），则滤镜不进行缩放。只有用户在舞台上进行放大时它才会缩放。</p>
 
 <p>如果所得图像超过最大尺寸，则不应用滤镜。在 AIR 1.5 和 Flash Player 10 中，最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。例如，如果在放大某大型影片剪辑时应用了滤镜，则所得图像超过最大尺寸时，将关闭该滤镜。</p>
 
 </apiDesc><example conref="examples\BevelFilterExample.as"> 以下示例创建一个深黄色正方形，并用浅黄色 (0xFFFF00) 加亮和蓝色 (0x0000FF) 阴影应用斜角。该示例的一般工作流程如下：
 <ol>
  <li>导入所需的类。</li>   
  <li>声明 <codeph>draw()</codeph> 函数所用的三个属性，该函数绘制应用了斜角滤镜的对象。</li>
  <li>创建 <codeph>BevelFilterExample()</codeph> 构造函数，该函数执行以下操作：
      <ul>
          <li>调用稍后将声明的 <codeph>draw()</codeph> 函数。</li>
          <li>将变量 <codeph>filter</codeph> 声明为 BitmapFilter 对象，并将它分配给对 <codeph>getBitmapFilter()</codeph> 的调用的返回值。</li>
          <li>创建一个新的 Array 对象 <codeph>myFilters</codeph> 并将 <codeph>filter</codeph> 添加到该数组，将 <codeph>myFilters</codeph> 分配给 BevelFilterExample 对象的 <codeph>filters</codeph> 属性。这将应用 <codeph>myFilters</codeph> 中包含的所有滤镜，在本例中仅为 <codeph>filter</codeph>。</li>      
      </ul>
 </li>
  <li>创建 <codeph>getBitmapFilter</codeph> 函数，以创建和设置滤镜的属性。</li>
  <li>创建 <codeph>draw()</codeph> 函数。该函数使用 Graphics 类的方法（通过 Sprite 类的 <codeph>graphics</codeph> 属性访问）绘制正方形。</li>
  
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BevelFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xFFFF00;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x0000FF;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BevelFilter:BevelFilter"><apiName>BevelFilter</apiName><shortdesc>
	用指定参数初始化新的 BevelFilter 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following code creates a new BevelFilter instance. The values given 
	are the default values; you could call the constructor without any values and get the same result.
	<listing> filter = new flash.filters.BevelFilter (4, 45, 0xFFFFFF, 1, 0x000000, 1, 4, 4, 1, 
	1, "inner", false) 
	</listing>
	The next example instantiates a new BevelFilter and applies it to the MovieClip <code>rect</code>.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var distance:Number = 5;
	var angleInDegrees:Number = 45;
	var highlightColor:uint = 0xFFFF00;
	var highlightAlpha:Number = .8;
	var shadowColor:uint = 0x0000FF;
	var shadowAlpha:Number = .8;
	var blurX:Number = 20;
	var blurY:Number = 20;
	var strength:Number = 1;
	var quality:int = 3;
	var type:String = "inner";
	var knockout:Boolean = false;
	
	var filter:BevelFilter = new BevelFilter(distance, angleInDegrees, highlightColor, highlightAlpha, shadowColor, shadowAlpha, blurX, blurY, strength, quality, type, knockout);
	
	var rect:MovieClip = createRectangle(100, 100, 0x00CC00, "bevelFilterExample");
	rect.filters = new Array(filter);
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>斜角的偏移距离，以像素为单位（浮点）。 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>斜角的角度，0 至 360 度。 
	</apiDesc></apiParam><apiParam><apiItemName>highlightColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFF</apiData><apiDesc>斜角的加亮颜色，<i>0xRRGGBB</i>。 
	</apiDesc></apiParam><apiParam><apiItemName>highlightAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>加亮颜色的 Alpha 透明度值。有效值为 0.0 到 1.0。例如，.25 设置透明度值为 25%。 
	</apiDesc></apiParam><apiParam><apiItemName>shadowColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0x000000</apiData><apiDesc>斜角的阴影颜色，<i>0xRRGGBB</i>。 
	</apiDesc></apiParam><apiParam><apiItemName>shadowAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>阴影颜色的 Alpha 透明度值。有效值为 0.0 到 1.0。例如，.25 设置透明度值为 25%。 
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平模糊量，以像素为单位。有效值为 0 到 255.0（浮点）。 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直模糊量，以像素为单位。有效值为 0 到 255.0（浮点）。
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>印记或跨页的强度。该值越高，压印的颜色越深，而且斜角与背景之间的对比度也越强。有效值为 0 到 255.0。 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>斜角的品质。有效值为 0 至 15，但是对于大多数应用，可以使用 <codeph>BitmapFilterQuality</codeph> 常量：
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>这些值越低，滤镜的呈现速度就越快。可以使用其它可用的数值来实现不同的效果。</p>

	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>斜角类型。有效值为 <codeph>BitmapFilterType</codeph> 常数：<codeph>BitmapFilterType.INNER</codeph>、<codeph>BitmapFilterType.OUTER</codeph> 或 <codeph>BitmapFilterType.FULL</codeph>。 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>应用挖空效果 (<codeph>true</codeph>)，这将有效地使对象的填色变为透明，并显示文档的背景颜色。
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	用指定参数初始化新的 BevelFilter 实例。
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#BitmapFilterType"><linktext>BitmapFilterType</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:BevelFilter:clone"><apiName>clone</apiName><shortdesc>
	返回此滤镜对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BevelFilter objects and compares them.  <code>filter_1</code>
	is created using the BevelFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
	 	// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
		// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>具有与原始 BevelFilter 实例相同的所有属性的新 BevelFilter 实例。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回此滤镜对象的副本。
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	斜角的角度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.angle = 225;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	斜角的角度。有效值为 0 到 360 度。默认值为 45 度。
	
	<p>角度值表示理论上的光源落在对象上的角度，它决定了效果相对于该对象的位置。如果 <codeph>distance</codeph> 属性设置为 0，则效果相对于对象没有偏移，因此 <codeph>angle</codeph> 属性不起作用。</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平模糊量，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurX");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurX = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平模糊量，以像素为单位。有效值为从 0 到 255（浮点）。默认值为 4。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直模糊量，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurY");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurY = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直模糊量，以像素为单位。有效值为从 0 到 255（浮点）。默认值为 4。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	斜角的偏移距离。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.distance = 3;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	斜角的偏移距离。有效值以像素为单位（浮点）。默认值为 4。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightAlpha:get"><apiName>highlightAlpha</apiName><shortdesc>
	加亮颜色的 Alpha 透明度值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	加亮颜色的 Alpha 透明度值。该值被指定为 0 到 1 之间的标准值。例如，.25 设置透明度值为 25%。默认值为 1。
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightColor:get"><apiName>highlightColor</apiName><shortdesc>
	斜角的加亮颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightColor = 0x0000FF;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	斜角的加亮颜色。有效值采用十六进制格式，<i>0xRRGGBB</i>。默认值为 0xFFFFFF。
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
    应用挖空效果 (true)，这将有效地使对象的填色变为透明，并显示文档的背景颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelKnockout");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    应用挖空效果 (<codeph>true</codeph>)，这将有效地使对象的填色变为透明，并显示文档的背景颜色。默认值为 <codeph>false</codeph>（不应用挖空效果）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	应用滤镜的次数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelQuality");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	应用滤镜的次数。默认值为 <codeph>BitmapFilterQuality.LOW</codeph>，与应用一次滤镜等效。值 <codeph>BitmapFilterQuality.MEDIUM</codeph> 两次应用滤镜；值 <codeph>BitmapFilterQuality.HIGH</codeph> 三次应用滤镜。滤镜的值越小，呈现速度越快。
	
	<p>对于大多数应用，<codeph>quality</codeph> 的值为低、中或高就足够了。您可以使用其他数值（最高为 15）来达到不同的效果，但是值越高，呈现速度越慢。除了增加 <codeph>quality</codeph> 的值，仅增加 <codeph>blurX</codeph> 和 <codeph>blurY</codeph> 属性的值通常也可以获得类似的效果，而且呈现速度更快。</p>
	
	<p>您可以使用以下 <codeph>BitmapFilterQuality</codeph> 常数指定 <codeph>quality</codeph> 属性的值：
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowAlpha:get"><apiName>shadowAlpha</apiName><shortdesc>
	阴影颜色的 Alpha 透明度值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	阴影颜色的 Alpha 透明度值。该值被指定为 0 到 1 之间的标准值。例如，.25 设置透明度值为 25%。默认值为 1。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowColor:get"><apiName>shadowColor</apiName><shortdesc>
	斜角的阴影颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowColor = 0xFFFF00;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	斜角的阴影颜色。有效值采用十六进制格式，<i>0xRRGGBB</i>。默认值为 0x000000。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	印记或跨页的强度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelStrength");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.strength = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	印记或跨页的强度。有效值为 0 到 255。该值越大，印记的颜色越深，而且斜角与背景之间的对比度也越强。默认值为 1。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:type:get"><apiName>type</apiName><shortdesc>
	斜角在对象上的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelType");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.type = "outer";
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>设置时 String 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	斜角在对象上的位置。内斜角和外斜角被放置在内缘或外缘上；完全斜角被放置在整个对象上。有效值为 <codeph>BitmapFilterType</codeph> 常量：
	
	<ul>
	<li><codeph>BitmapFilterType.INNER</codeph></li>
	<li><codeph>BitmapFilterType.OUTER</codeph></li>
	<li><codeph>BitmapFilterType.FULL</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilter"><apiName>BitmapFilter</apiName><shortdesc>
 BitmapFilter 类是所有图像滤镜效果的基类。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>所有图像滤镜效果的基类。
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 BitmapFilter 类是所有图像滤镜效果的基类。 
 
 <p>BevelFilter、BlurFilter、ColorMatrixFilter、ConvolutionFilter、DisplacementMapFilter、DropShadowFilter、GlowFilter、GradientBevelFilter 和 GradientGlowFilter 类都扩展了 BitmapFilter 类。您可以将这些滤镜效果应用于任何显示对象。</p>
 
 <p>不可以直接实例化或扩展 BitmapFilter。</p>
 
 </apiDesc><example conref="examples\BitmapFilterExample.as"> 以下示例说明如何将若干滤镜应用于给定的 DisplayObject 对象，并使用 <codeph>filters</codeph> 属性进行跟踪。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.*;

    public class BitmapFilterExample extends Sprite {
        public function BitmapFilterExample() {
            trace(this.filters.length);             // 0

            var tmpFilters:Array = this.filters;
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.BEVEL_FILTER));
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.GLOW_FILTER));
            this.filters = tmpFilters;

            trace(this.filters.length);             // 2
            trace(this.filters[0] is BitmapFilter); // true
            trace(this.filters[0] is BevelFilter);  // true
            trace(this.filters[1] is BitmapFilter); // true
            trace(this.filters[1] is GlowFilter);   // true
        }
    }
}

import flash.filters.*;
class FilterFactory {
    public static var BEVEL_FILTER:String = "BevelFilter";
    public static var BevelFilterConstructor:Class = BevelFilter;

    public static var BLUR_FILTER:String = "BlurFilter";
    public static var BlurFilterConstructor:Class = BlurFilter;

    public static var COLOR_MATRIX_FILTER:String = "ColorMatrixFilter";
    public static var ColorMatrixFilterConstructor:Class = ColorMatrixFilter;

    public static var CONVOLUTION_FILTER:String = "ConvolutionFilter";
    public static var ConvolutionFilterConstructor:Class = ConvolutionFilter;

    public static var DISPLACEMENT_MAP_FILTER:String = "DisplacementMapFilter";
    public static var DisplacementMapFilterConstructor:Class = DisplacementMapFilter;

    public static var DROP_SHADOW_FILTER:String = "DropShadowFilter";
    public static var DropShadowFilterConstructor:Class = DropShadowFilter;

    public static var GLOW_FILTER:String = "GlowFilter";
    public static var GlowFilterConstructor:Class = GlowFilter;

    public static var GRADIENT_BEVEL_FILTER:String = "GradientBevelFilter";
    public static var GradientBevelFilterConstructor:Class = GradientBevelFilter;

    public static var GRADIENT_GLOW_FILTER:String = "GradientGlowFilter";
    public static var GradientGlowFilterConstructor:Class = GradientGlowFilter;

    public static function createFilter(type:String):BitmapFilter {
        return new FilterFactory[type + "Constructor"]();   
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.filters:BitmapFilter:clone"><apiName>clone</apiName><shortdesc>
	 返回 BitmapFilter 对象，它是与原始 BitmapFilter 对象完全相同的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 BitmapFilter 对象。
	 
	 </apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>BitmapFilter 对象的副本。
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回 BitmapFilter 对象，它是与原始 BitmapFilter 对象完全相同的副本。
	 
	 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.filters:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
 可使用 BlurFilter 类将模糊视觉效果应用于显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>模糊效果。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 可使用 BlurFilter 类将模糊视觉效果应用于显示对象。模糊效果可以柔化图像的细节。您可以生成一些模糊效果，范围从创建一个柔化的、未聚焦的外观到高斯模糊（就像通过半透明玻璃查看图像一样的朦胧的外观）。当此滤镜的 <codeph>quality</codeph> 属性设置为低时，结果为柔化的、未聚焦的外观。当 <codeph>quality</codeph> 属性设置为高时，该属性接近高斯模糊滤镜。您可以将滤镜应用于任何显示对象（即，从 DisplayObject 类继承的对象），例如 MovieClip、SimpleButton、TextField 和 Video 对象，以及 BitmapData 对象。
 
 <p>要创建新的滤镜，请使用构造函数 <codeph>new BlurFilter()</codeph>。滤镜的具体使用取决于要应用滤镜的对象：</p>
 <ul><li>要对影片剪辑、文本字段、按钮和视频应用滤镜，请使用 <codeph>filters</codeph> 属性（继承自 DisplayObject）。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。 </li>
 
 <li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并最终生成一个过滤图像。</li>
 </ul>
 
 <p>如果对显示对象应用滤镜，显示对象的 <codeph>cacheAsBitmap</codeph> 属性将设置为 <codeph>true</codeph>。如果删除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p>
 
 <p>此滤镜支持舞台缩放。但是，它不支持常规缩放、旋转和倾斜。如果对象本身进行了缩放（<codeph>scaleX</codeph> 和 <codeph>scaleY</codeph> 未设置为 100%），滤镜效果将不进行缩放。只有用户在舞台上进行放大时它才会缩放。</p>
 
 <p>如果所得图像超过最大尺寸，则不应用滤镜。在 AIR 1.5 和 Flash Player 10 中，最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。例如，如果在放大某大型影片剪辑时应用了滤镜，则所得图像超过最大尺寸时，将关闭该滤镜。</p>
 
 </apiDesc><example conref="examples\BlurFilterExample.as"> 以下示例创建了一个深黄色正方形并对其应用高斯样式模糊滤镜。该示例的一般工作流程如下：
 <ol>
  <li>导入所需的类。</li>   
  <li>声明 <codeph>draw()</codeph> 函数所用的三个属性，该函数绘制应用了模糊滤镜的对象。 </li>
  <li>创建 <codeph>BlurFilterExample()</codeph> 构造函数，该函数执行以下操作：
      <ul>
          <li>调用稍后将声明的 <codeph>draw()</codeph> 函数。</li>
          <li>将 <codeph>filter</codeph> 变量声明为 BitmapFilter 对象，并将它分配给对 <codeph>getBitmapFilter()</codeph> 的调用的返回值。</li>
          <li>创建一个新的 Array 对象 <codeph>myFilters</codeph> 并将 <codeph>filter</codeph> 添加到该数组，将 <codeph>myFilters</codeph> 分配给 BlurFilterExample 对象的 <codeph>filters</codeph> 属性。这将应用 <codeph>myFilters</codeph> 中包含的所有滤镜，在本例中仅为 <codeph>filter</codeph>。</li>
      </ul>
  </li>
  <li>创建 <codeph>getBitmapFilter()</codeph> 函数，以创建和设置滤镜的属性。</li>
  <li>创建 <codeph>draw()</codeph> 函数。该函数使用 Graphics 类的方法（通过 Sprite 类的 <codeph>graphics</codeph> 属性访问）绘制正方形。</li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BlurFilter;

    public class BlurFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BlurFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var blurX:Number = 30;
            var blurY:Number = 30;
            return new BlurFilter(blurX, blurY, BitmapFilterQuality.HIGH);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BlurFilter:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
	用指定参数初始化滤镜。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Instantiate a new <code>BlurFilter</code> and apply it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "BlurFilterExample");
	
	var blurX:Number = 30;
	var blurY:Number = 30;
	var quality:Number = 3;
	
	var filter:BlurFilter = new BlurFilter(blurX, blurY, quality);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平模糊量。有效值为 0 到 255.0（浮点值）。 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直模糊量。有效值为 0 到 255.0（浮点值）。 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>应用滤镜的次数。您可以使用 BitmapFilterQuality 常量来指定品质：
	<ul>
	<li><codeph>flash.filters.BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>高品质接近高斯模糊。对于大多数应用，这三个值已足够了。虽然您可以使用不超过 15 的其它数值来达到不同的效果，但是请注意，值越高，呈现速度越慢。</p>
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>初始化滤镜。
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	用指定参数初始化滤镜。默认值会创建一个柔化的、未聚焦的图像。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:BlurFilter:clone"><apiName>clone</apiName><shortdesc>
	返回此滤镜对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BlurFilter objects and compares them.  <code>filter_1</code>
	is created using the BlurFilter constructor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>quality</code> property of <code>filter_1</code>.  Modifying <code>quality</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1.quality);			// 2
	trace(filter_2.quality);			// 2
	trace(clonedFilter.quality);		// 2
	
	filter_1.quality = 1;
	
	trace(filter_1.quality);			// 1
	trace(filter_2.quality);			// 1
	trace(clonedFilter.quality);		// 2
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>具有与原始 BlurFilter 实例相同的所有属性的新 BlurFilter 实例。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回此滤镜对象的副本。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BlurFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurX");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurX = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平模糊量。有效值为从 0 到 255（浮点）。默认值为 4。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurY");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurY = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直模糊量。有效值为从 0 到 255（浮点）。默认值为 4。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:quality:get"><apiName>quality</apiName><shortdesc>
	执行模糊的次数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterQuality");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	执行模糊的次数。默认值为 <codeph>BitmapFilterQuality.LOW</codeph>，与应用一次滤镜等效。值 <codeph>BitmapFilterQuality.MEDIUM</codeph> 两次应用滤镜；值 <codeph>BitmapFilterQuality.HIGH</codeph> 三次应用滤镜并接近高斯模糊。滤镜的值越小，呈现速度越快。
	
	<p>对于大多数应用，<codeph>quality</codeph> 的值为低、中或高就足够了。虽然您可以使用不超过 15 的其它数值来增加应用模糊的次数，但该数值越高，呈现速度就越慢。除了增加 <codeph>quality</codeph> 的值，仅增加 <codeph>blurX</codeph> 和 <codeph>blurY</codeph> 属性的值通常也可以获得类似的效果，而且呈现速度更快。</p>
	
	<p>您可以使用以下 BitmapFilterQuality 常数指定 <codeph>quality</codeph> 属性的值：</p>
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
ConvolutionFilter 类应用矩阵盘绕滤镜效果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Do we allow anything other than 3x3 matrix convolution? Are default x y values correct?

</internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>应用矩阵卷积滤镜。

</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
ConvolutionFilter 类应用矩阵盘绕滤镜效果。卷积将输入图像的像素与相邻的像素合并以生成图像。通过卷积，可以实现大量的图像效果，包括模糊、边缘检测、锐化、浮雕和斜角。您可以将滤镜应用于任何显示对象（即，从 DisplayObject 类继承的对象），例如 MovieClip、SimpleButton、TextField 和 Video 对象，以及 BitmapData 对象。

<p>要创建卷积滤镜，请使用语法 <codeph>new ConvolutionFilter()</codeph>。滤镜的具体使用取决于要应用滤镜的对象：</p>
<ul><li>要对影片剪辑、文本字段、按钮和视频应用滤镜，请使用 <codeph>filters</codeph> 属性（继承自 DisplayObject）。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。 </li>

<li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并最终生成一个过滤图像。</li>
</ul>

<p>如果对显示对象应用滤镜，则该对象的 <codeph>cacheAsBitmap</codeph> 属性值将设置为 <codeph>true</codeph>。如果清除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p>

<p>如果所得图像超过最大尺寸，则不应用滤镜。在 AIR 1.5 和 Flash Player 10 中，最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。例如，如果在放大某大型影片剪辑时应用了滤镜，则所得图像超过最大尺寸时，将关闭该滤镜。</p>

</apiDesc><example conref="examples\ConvolutionFilterExample.as"> 以下示例将不同的卷积滤镜应用于图像文件。滤镜构造函数调用 <codeph>buildChild()</codeph> 四次，以加载和显示图像的四个实例。对 <codeph>buildChild()</codeph> 的每次调用都将函数作为参数，该函数不对第一个实例应用任何滤镜，而对后续的每个实例应用不同的卷积滤镜。
 <p><codeph>buildChild()</codeph> 函数创建一个名为 <codeph>loader</codeph> 的新 Loader 对象。每次调用 <codeph>buildChild()</codeph> 时，将一个事件侦听器附加到 Loader 对象，以侦听 <codeph>complete</codeph> 事件，这些事件由传递给 <codeph>buildChild()</codeph> 的函数处理。</p>
 
 <p><codeph>applyBrightness()</codeph>、<codeph>applySharpness()</codeph> 和 <codeph>applyOutline()</codeph> 函数使用 <codeph>matrix</codeph> 数组的不同值来实现不同的 ConvolutionFilter 效果。</p>
 <p><b>注意</b>：为获得最佳效果，请使用宽度约为 80 像素的图像。图像文件的名称和位置应与您传递给 <codeph>url</codeph> 属性的值相匹配。例如，此示例中传递给 <codeph>url</codeph> 的值指向名为“Image.jpg”的图像文件，该图像文件与 SWF 文件位于同一目录中。
 </p>
 
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.filters.BitmapFilter;
    import flash.filters.ConvolutionFilter;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class ConvolutionFilterExample extends Sprite {
        private var size:uint = 140;
        private var url:String = "Image.jpg";

        public function ConvolutionFilterExample() {
            buildChild(applyNothing);
            buildChild(applyBrightness);
            buildChild(applySharpness);
            buildChild(applyOutline);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if(loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyNothing(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            applyLabel(child, "no filter");
        }

        private function applyBrightness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [5, 5, 5,
                                5, 0, 5,
                                5, 5, 5];
            applyFilter(child, matrix);
            applyLabel(child, "brightness");
        }

        private function applySharpness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [0, -1, 0,
                               -1, 20, -1,
                                0, -1, 0];
            applyFilter(child, matrix);
            applyLabel(child, "sharpness");
        }

        private function applyOutline(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [-30, 30, 0,
                                -30, 30, 0,
                                -30, 30, 0];
            applyFilter(child, matrix);
            applyLabel(child, "outline");
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var matrixX:Number = 3;
            var matrixY:Number = 3;
            var divisor:Number = 9;
            var filter:BitmapFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }

        private function applyLabel(child:DisplayObject, label:String):void {
            var tf:TextField = new TextField();
            tf.x = child.x;
            tf.y = child.height;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.text = label;
            addChild(tf);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.filters.xml#ConvolutionFilter/matrix"><linktext>matrix</linktext></link></related-links><apiConstructor id="flash.filters:ConvolutionFilter:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
	用指定参数初始化 ConvolutionFilter 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a ConvolutionFilter
	object with the four required parameters <code>matrixX</code>, <code>matrixY</code>, 
	<code>matrix</code>, and <code>divisor</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var matrixX:Number = 3;
	var matrixY:Number = 3;
	var matrix:Array = [1, 1, 1, 1, 1, 1, 1, 1, 1];
	var divisor:Number = 9;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
	
   	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
   	
  	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
  	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
   	myBitmapData.noise(128);
   		
   	mc.onPress = function() {
   		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
   	}
	</listing>
	
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrixX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>矩阵的 <i>x</i> 维度（矩阵中列的数目）。默认值为 0。
	</apiDesc></apiParam><apiParam><apiItemName>matrixY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>矩阵的 <i>y</i> 维度（矩阵中行的数目）。默认值为 0。
	</apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>用于矩阵转换的值的数组。数组中的项数必须等于 <codeph>matrixX ~~ matrixY</codeph>。
	</apiDesc></apiParam><apiParam><apiItemName>divisor</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>矩阵转换中使用的除数。默认值为 1。如果除数是所有矩阵值的总和，则可调平结果的总体色彩强度。忽略 0 值，此时使用默认值。 
	</apiDesc></apiParam><apiParam><apiItemName>bias</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>要添加到矩阵转换结果的偏差。默认值为 0。
	</apiDesc></apiParam><apiParam><apiItemName>preserveAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc><codeph>false</codeph> 值表示未保留 Alpha 值，并且卷积适用于所有通道（包括 Alpha 通道）。值为 <codeph>true</codeph> 表示只对颜色通道应用卷积。默认值为 <codeph>true</codeph>。
	</apiDesc></apiParam><apiParam><apiItemName>clamp</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>对于源图像之外的像素，如果值为 <codeph>true</codeph>，则表明通过复制输入图像给定边缘处的颜色值，沿着输入图像的每个边框按需要扩展输入图像。如果值为 <codeph>false</codeph>，则表明应按照 <codeph>color</codeph> 和 <codeph>alpha</codeph> 属性中的指定使用其它颜色。默认值为 <codeph>true</codeph>。 
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>要替换源图像之外的像素的十六进制颜色。
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>替换颜色的 Alpha。
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	用指定参数初始化 ConvolutionFilter 实例。
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ConvolutionFilter:clone"><apiName>clone</apiName><shortdesc>
	返回此滤镜对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>ConvolutionFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>ConvolutionFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}		
	</listing>
	
	<p>To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>bias</code> property of <code>filter_1</code>.  Modifying <code>bias</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.</p>
	
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	trace(filter_1.bias);			// 0
	trace(filter_2.bias);			// 0
	trace(clonedFilter.bias);		// 0
	
	filter_1.bias = 20;
	
	trace(filter_1.bias);			// 20
	trace(filter_2.bias);			// 20
	trace(clonedFilter.bias);		// 0
	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>BitmapFilter，与原始 ConvolutionMatrixFilter 实例具有完全相同的属性的新 ConvolutionFilter 实例。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回此滤镜对象的副本。
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ConvolutionFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	替换颜色的 Alpha 透明度值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property of <code>filter</code>
	from its default value of <code>1</code> to <code>.35</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var alpha:Number = .35;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, 0x0000FF, alpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	 
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, 98, 78), new Point(2, 2), filter);
  	}
	</listing>	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	替换颜色的 Alpha 透明度值。有效值为 0 到 1.0。默认值为 0。例如，.25 设置透明度值为 25%。	  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:bias:get"><apiName>bias</apiName><shortdesc>
	要添加到矩阵转换结果中的偏差量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>bias</code> property of <code>filter</code>
	from its default value of 0 to 50.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var bias:Number = 50;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, bias);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
 	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	要添加到矩阵转换结果中的偏差量。偏差可增加每个通道的颜色值，以便暗色变得较明亮。默认值为 0。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:clamp:get"><apiName>clamp</apiName><shortdesc>
	指示是否应锁定图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	指示是否应锁定图像。对于源图像之外的像素，如果值为 <codeph>true</codeph>，则表明通过复制输入图像每个相应的边缘处的颜色值，沿着输入图像的每个边框按需要扩展输入图像。如果值为 <codeph>false</codeph>，则表明应按照 <codeph>color</codeph> 和 <codeph>alpha</codeph> 属性中的指定使用其它颜色。默认值为 <codeph>true</codeph>。
	
	</apiDesc><example conref="ConvolutionClampExample.as"> 以下示例使用 <codeph>BitmapData</codeph> 类创建两个框，其中一个框的大小是另一个框的一半。在首次加载该示例时，将使用 <codeph>attachBitmap()</codeph> 在 <codeph>mc</codeph> 内绘制较大的框。在单击 <codeph>mc</codeph> 并调用 <codeph>applyFilter()</codeph> 方法时，将会在 <codeph>smallBox</codeph> 作为源位图的基础上重绘 <codeph>BitmapData</codeph> 的 <codeph>largeBox</codeph> 实例。由于 <codeph>applyFilter()</codeph> 会将 <codeph>smallBox</codeph> 绘制在 <codeph>Rectangle</codeph> 上，而后者的宽度和高度被指定为 <codeph>largeBox</codeph> 的宽度和高度，因此源位图要比绘制区域更小。在本例中，<codeph>ConvolutionFilter</codeph> 的 <codeph>clamp</codeph> 属性被设置为 <codeph>false</codeph>，未被源位图 <codeph>smallBox</codeph> 覆盖的区域是由 <codeph>clampColor</codeph> 和 <codeph>clampAlpha</codeph> 变量确定的纯红色。
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.filters.ConvolutionFilter;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.geom.Point;

    public class ConvolutionClampExample extends Sprite {
        // Variables that affect clamping:
        var clamp:Boolean = false;
        var clampColor:Number = 0xFF0000;
        var clampAlpha:Number = 1;
        
        // For illustration, keep other ConvolutionFilter variables neutral:
        var bias:Number = 0;
        var preserveAlpha:Boolean = false;
        // Also, construct a neutral matrix
        var matrixCols:Number = 3;
        var matrixRows:Number = 3;
        var matrix:Array = [ 1,1,1,
                             1,1,1,
                             1,1,1 ];
        
        var filter:ConvolutionFilter = new ConvolutionFilter(matrixCols, matrixRows, matrix, matrix.length, bias, preserveAlpha, clamp, clampColor, clampAlpha);
        
        var largeBoxWidth:Number = 100;
        var largeBoxHeight:Number = 100;
        var largeBox:BitmapData = new BitmapData(largeBoxWidth, largeBoxWidth, true, 0xCC00FF00);
        var smallBoxWidth:Number = largeBoxWidth / 2;
        var smallBoxHeight:Number = largeBoxHeight / 2;
        var smallBox:BitmapData = new BitmapData(smallBoxWidth, smallBoxWidth, true, 0xCC0000FF);
            
        var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
        mc.attachBitmap(largeBox, this.getNextHighestDepth());
        
        mc.onPress = function() {
            largeBox.applyFilter(smallBox,
                                 new Rectangle(0,0, largeBoxWidth, largeBoxHeight),
                                 new Point(0,0),
                                 filter);
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:color:get"><apiName>color</apiName><shortdesc>
	要替换源图像之外的像素的十六进制颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property of <code>filter</code>
	from its default value of <code>0</code> to <code>0xFF0000</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var color:Number = 0x0000FF;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, color, 1);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	  	
  	var height:Number = 100;
  	var width:Number = 80;
  	mc.onPress = function() {
  		height -= 2;
  		width -= 2;
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, height, width), new Point(2, 2), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	要替换源图像之外的像素的十六进制颜色。它是一个没有 Alpha 成分的 RGB 值。默认值为 0。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:divisor:get"><apiName>divisor</apiName><shortdesc>
	矩阵转换中使用的除数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>divisor</code> property of <code>filter</code>
	to 6.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  	
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	 	
  	mc.onPress = function() {
  		var newDivisor:Number = 6;
  		filter.divisor = newDivisor;
  	 	myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	矩阵转换中使用的除数。默认值为 1。如果除数是所有矩阵值的总和，则可调平结果的总体色彩强度。忽略 0 值，此时使用默认值。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	用于矩阵转换的值的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>matrix</code> property of <code>filter</code>
	from one that blurs a bitmap to one that sharpens it.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  		
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	  	
  	mc.onPress = function() {
  		var newMatrix:Array = [0, -1, 0, -1, 8, -1, 0, -1, 0];
  		filter.matrix = newMatrix;
  		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>设置时 Array 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	用于矩阵转换的值的数组。数组中的项数必须等于 <codeph>matrixX ~~ matrixY</codeph>。
	<p> 矩阵盘绕基于一个 <i>n</i> x <i>m</i> 矩阵，该矩阵说明输入图像中的给定像素值如何与其相邻的像素值合并以生成最终的像素值。每个结果像素通过将矩阵应用到相应的源像素及其相邻像素来确定。</p>
	
	<p> 对于 3 x 3 矩阵卷积，将以下公式用于每个独立的颜色通道：
	<pre><codeph>
	dst (x, y) = ((src (x-1, y-1) ~~ a0 + src(x, y-1) ~~ a1....
	                  src(x, y+1) ~~ a7 + src (x+1,y+1) ~~ a8) / divisor) + bias
	</codeph></pre>
	</p>
	
	<p>某些规格的滤镜在由提供 SSE（SIMD 流扩展）的处理器运行时执行速度更快。以下是更快的卷积操作的条件：</p>
	<ul>
	<li>滤镜必须是 3x3 滤镜。</li>
	<li>所有滤镜项必须是介于 -127 和 +127 之间的整数。</li>
	<li>所有滤镜项的总和不能包含大于 127 的绝对值。</li> 
	<li>如果任何滤镜项为负，则除数必须介于 2.00001 和 256 之间。</li>
	<li>如果所有滤镜项都为正，则除数必须介于 1.1 和 256 之间。</li>
	<li>偏差必须是整数。</li>
	</ul>
    <p><b>注意：</b>如果使用不带参数的构造函数创建了 ConvolutionFilter 实例，则为矩阵属性赋值的顺序将影响滤镜的行为。在以下情况中，矩阵数组已指定，而 <codeph>matrixX</codeph> 和 <codeph>matrixY</codeph> 属性仍设置为 <codeph>0</codeph>（默认值）：</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    </codeblock>
    <p>在以下情况中，矩阵数组已指定，而 <codeph>matrixX</codeph> 和 <codeph>matrixY</codeph> 属性设置为 <codeph>3</codeph>：</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    </codeblock>
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixX:get"><apiName>matrixX</apiName><shortdesc>
	矩阵的 x 维度（矩阵中列的数目）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixX</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
 	
 	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixX);	// 2
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	矩阵的 <i>x</i> 维度（矩阵中列的数目）。默认值为 0。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixY:get"><apiName>matrixY</apiName><shortdesc>
	矩阵的 y 维度（矩阵中行的数目）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixY</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixY);	// 3
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	矩阵的 <i>y</i> 维度（矩阵中行的数目）。默认值为 0。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:preserveAlpha:get"><apiName>preserveAlpha</apiName><shortdesc>
	指示是否已保留 Alpha 通道并且不使用滤镜效果，或是否对 Alpha 通道以及颜色通道应用卷积滤镜。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>preserveAlpha</code> property of <code>filter</code>
	from its default value of <code>true</code> to <code>false</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var preserveAlpha:Boolean = false;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, preserveAlpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
	
	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	指示是否已保留 Alpha 通道并且不使用滤镜效果，或是否对 Alpha 通道以及颜色通道应用卷积滤镜。值为 <codeph>false</codeph> 表示卷积应用于所有通道，包括 Alpha 通道。值为 <codeph>true</codeph> 表示只对颜色通道应用卷积。默认值为 <codeph>true</codeph>。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
使用 GradientBevelFilter 类可以对显示对象应用渐变斜角效果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>允许应用渐变斜角效果。
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
使用 GradientBevelFilter 类可以对显示对象应用渐变斜角效果。渐变斜角是位于对象外部、内部或顶部的使用渐变色增强的有斜面的边缘。有斜面的边缘使对象具有三维外观。您可以将滤镜应用于任何显示对象（即，从 DisplayObject 类继承的对象），例如 MovieClip、SimpleButton、TextField 和 Video 对象，以及 BitmapData 对象。

 <p>滤镜的具体使用取决于要应用滤镜的对象：</p>
 <ul><li>要对显示对象应用滤镜，请使用 <codeph>filters</codeph> 属性。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。 </li>
 
 <li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并最终生成一个过滤图像。</li>
 </ul>

<p>如果对显示对象应用滤镜，显示对象的 <codeph>cacheAsBitmap</codeph> 属性将设置为 <codeph>true</codeph>。如果清除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p> 

<p>此滤镜支持舞台缩放。但是，它不支持常规缩放、旋转和倾斜；如果对象本身进行了缩放（如果将 <codeph>scaleX</codeph> 和 <codeph>scaleY</codeph> 设置为除 1.0 以外的其它值），滤镜效果将不进行缩放。只有用户在舞台上进行放大时它才会缩放。</p>

<p>如果所得图像超过最大尺寸，则不应用滤镜。在 AIR 1.5 和 Flash Player 10 中，最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。例如，如果在放大某大型影片剪辑时应用了滤镜，则所得图像超过最大尺寸时，将关闭该滤镜。</p>

 </apiDesc><example conref="examples\GradientBevelFilterExample.as"> 以下示例将绘制一个正方形，并对它应用渐变斜角滤镜。该示例的一般工作流程如下：
 <ol>
  <li>导入所需的类。</li>
  <li>声明用于定义正方形和滤镜的全局变量。</li>
  <li>创建构造函数，该函数执行以下操作：
      <ul>
          <li>调用 <codeph>draw()</codeph> 方法，该方法使用 Graphics 类的方法（通过 Sprite 的 <codeph>graphics</codeph> 属性访问）绘制一个灰色正方形。</li>
          <li>创建名为 <codeph>filter</codeph> 的 BitmapFilter 对象，并将对 <codeph>getBitmapFilter()</codeph>（用于创建滤镜）的调用的返回值赋予它。</li>
          <li>创建一个名为 <codeph>myFilters</codeph> 的新数组，并将 <codeph>filter</codeph> 添加到该数组。</li>
          <li>将 <codeph>myFilters</codeph> 分配给 GradientBevelFilterExample 对象的 <codeph>filters</codeph> 属性。这将应用 <codeph>myFilters</codeph> 中包含的所有滤镜，在本例中仅为 <codeph>filter</codeph>。</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientBevelFilter;

    public class GradientBevelFilterExample extends Sprite {
        private var bgColor:uint     = 0xCCCCCC;
        private var size:uint        = 80;
        private var offset:uint      = 50;
        private var distance:Number  = 5;
        private var angleInDegrees:Number = 225; // opposite 45 degrees
        private var colors:Array     = [0xFFFFFF, 0xCCCCCC, 0x000000];
        private var alphas:Array     = [1, 0, 1];
        private var ratios:Array     = [0, 128, 255];
        private var blurX:Number     = 8;
        private var blurY:Number     = 8;
        private var strength:Number  = 2;
        private var quality:Number   = BitmapFilterQuality.HIGH
        private var type:String      = BitmapFilterType.INNER;
        private var knockout:Boolean = true;

        public function GradientBevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientBevelFilter(distance,
                                           angleInDegrees,
                                           colors,
                                           alphas,
                                           ratios,
                                           blurX,
                                           blurY,
                                           strength,
                                           quality,
                                           type,
                                           knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:GradientBevelFilter:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
	用指定参数初始化滤镜。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Constructor
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>偏移距离。有效值为 0 到 8。 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>角度，以度为单位。有效值为 0 到 360。 
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>渐变中使用的 RGB 十六进制颜色值数组。例如，红色为 0xFF0000，蓝色为 0x0000FF 等等。
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc><codeph>colors</codeph> 数组中对应颜色的 Alpha 透明度值的数组。数组中每个元素的有效值为 0 到 1。例如，.25 设置透明度值为 25%。
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>颜色分布比例的数组；有效值为 0 到 255。
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平模糊量。有效值为 0 到 255。如果模糊量小于或等于 1，则表明原始图像是按原样复制的。默认值为 4。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直模糊量。有效值为 0 到 255。如果模糊量小于或等于 1，则表明原始图像是按原样复制的。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>印记或跨页的强度。该值越高，压印的颜色越深，而且斜角与背景之间的对比度也越强。有效值为 0 到 255。值为 0 表示未应用滤镜。 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>滤镜的品质。使用 BitmapFilterQuality 常量：
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>有关详细信息，请参阅 <codeph>quality</codeph> 属性的说明。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>斜角效果的放置。可能的值为 BitmapFilterType 常量：
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> -- 对象外缘上的斜角</li>
	<li><codeph>BitmapFilterType.INNER</codeph> -- 对象内缘上的斜角</li>
	<li><codeph>BitmapFilterType.FULL</codeph> -- 对象顶部的斜角</li>
	</ul>
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指定是否应用挖空效果。值为 <codeph>true</codeph> 将使对象的填充变为透明，并显示文档的背景颜色。 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	用指定参数初始化滤镜。
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/quality"><linktext>GradientBevelFilter.quality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GradientBevelFilter:clone"><apiName>clone</apiName><shortdesc>
	返回此滤镜对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates two rectangle shapes. The first, 
	<code>sourceClip</code> has a bevel effect. The second, 
	<code>resultClip</code> has no effect until it is clicked.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var sourceClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneSourceClip");
	var resultClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneResultClip");
	
	resultClip.source = sourceClip;
	
	var sourceFilter:GradientBevelFilter = getNewFilter();
	sourceClip.filters = new Array(sourceFilter);
	
	resultClip._x = 180;
	resultClip.onRelease = function() {
		this.filters = new Array(this.source.filters[0].clone());
	}
	
	function setUpFlatRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		return mc;
	}
	
	function getNewFilter():GradientBevelFilter {
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		return new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	}
	
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>与原始 GradientBevelFilter 实例具有完全相同的属性的新 GradientBevelFilter 实例。
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回此滤镜对象的副本。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientBevelFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	colors 数组中对应颜色的 Alpha 透明度值的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>alphas</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("alphasExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [.2, 0, .2];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [1, 0, 1];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>设置时 Array 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Alpha 值的数组。
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	<codeph>colors</codeph> 数组中对应颜色的 Alpha 透明度值的数组。数组中每个元素的有效值为 0 到 1。例如，.25 设置透明度值为 25%。
	
	<p><codeph>alphas</codeph> 属性不能通过直接修改它的值来进行更改。相反，必须获得对 <codeph>alphas</codeph> 的引用，对该引用进行更改，然后将 <codeph>alphas</codeph> 设置为该引用。</p>
	
	<p><codeph>colors</codeph>、<codeph>alphas</codeph> 和 <codeph>ratios</codeph> 属性是相关的。<codeph>colors</codeph> 数组中的第一个元素对应于 <codeph>alphas</codeph> 数组中的第一个元素以及 <codeph>ratios</codeph> 数组中的第一个元素，依此类推。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	角度，以度为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>angle</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("angleExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].angle = 45;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	角度，以度为单位。有效值为 0 到 360。默认值为 45。
	
	<p>角度值表示理论上的光源落在对象上的角度。该值确定将渐变颜色应用到对象上的角度：加亮和阴影出现的位置，或数组中第一种颜色出现的位置。然后，按这些颜色在数组中出现的顺序应用颜色。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurX</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurXExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurX = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平模糊量。有效值为 0 到 255。如果模糊量小于或等于 1，则表明原始图像是按原样复制的。默认值为 4。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurY</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurYExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurY = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直模糊量。有效值为 0 到 255。如果模糊量小于或等于 1，则表明原始图像是按原样复制的。默认值为 4。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:colors:get"><apiName>colors</apiName><shortdesc>
	渐变中使用的 RGB 十六进制颜色值数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>colors</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("colorsExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0x000000, 0xCCCCCC, 0xFFFFFF];
		arr[0].colors = colors;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		arr[0].colors = colors;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>设置时 Array 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>RGB 十六进制颜色值的数组。
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	渐变中使用的 RGB 十六进制颜色值数组。例如，红色为 0xFF0000，蓝色为 0x0000FF 等等。
	
	<p><codeph>colors</codeph> 属性不能通过直接修改它的值来进行更改。相反，必须获得对 <codeph>colors</codeph> 的引用，对该引用进行更改，然后将 <codeph>colors</codeph> 设置为该引用。</p>
	
	<p><codeph>colors</codeph>、<codeph>alphas</codeph> 和 <codeph>ratios</codeph> 属性是相关的。<codeph>colors</codeph> 数组中的第一个元素对应于 <codeph>alphas</codeph> 数组中的第一个元素以及 <codeph>ratios</codeph> 数组中的第一个元素，依此类推。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	偏移距离。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>distance</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("distanceExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].distance = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	偏移距离。有效值为 0 到 8。默认值为 4.0。
	
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	指定对象是否具有挖空效果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>knockout</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("knockoutExample");
	mc.onRelease = function() {
	var arr:Array = this.filters;
		arr[0].knockout = true;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	指定对象是否具有挖空效果。 应用挖空效果将使对象的填充变为透明，并显示文档的背景颜色。值为 <codeph>true</codeph> 将指定应用挖空效果；默认值为 <codeph>false</codeph>，即不应用挖空效果。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	应用滤镜的次数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>quality</code> property on an existing
	object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("qualityExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].quality = 1; // low quality
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	应用滤镜的次数。默认值为 <codeph>BitmapFilterQuality.LOW</codeph>，与应用一次滤镜等效。值 <codeph>BitmapFilterQuality.MEDIUM</codeph> 两次应用滤镜；值 <codeph>BitmapFilterQuality.HIGH</codeph> 三次应用滤镜。滤镜的值越小，呈现速度越快。
	
	<p>对于大多数应用，<codeph>quality</codeph> 的值为低、中或高就足够了。您可以使用其他数值（最高为 15）来达到不同的效果，但是值越高，呈现速度越慢。除了增加 <codeph>quality</codeph> 的值，仅增加 <codeph>blurX</codeph> 和 <codeph>blurY</codeph> 属性的值通常也可以获得类似的效果，而且呈现速度更快。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	对应于 colors 数组中颜色的一组颜色分布比率。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>ratios</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("ratiosExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [127, 128, 129];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [0, 128, 255];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>设置时 Array 为 null
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	对应于 <codeph>colors</codeph> 数组中颜色的一组颜色分布比率。数组中每个元素的有效值为 0 到 255。
	
	<p><codeph>ratios</codeph> 属性不能通过直接修改它的值来进行更改。相反，必须获得对 <codeph>ratios</codeph> 的引用，对该引用进行更改，然后将 <codeph>ratios</codeph> 设置为该引用。</p>
	
	<p> <codeph>colors</codeph>、<codeph>alphas</codeph> 和 <codeph>ratios</codeph> 属性是相关的。<codeph>colors</codeph> 数组中的第一个元素对应于 <codeph>alphas</codeph> 数组中的第一个元素以及 <codeph>ratios</codeph> 数组中的第一个元素，依此类推。</p>
	
	<p> 要了解渐变斜角中的颜色是如何分布的，请先考虑您希望在渐变斜角中使用的颜色。考虑到简单斜角具有加亮颜色和阴影颜色；渐变斜角具有加亮渐变和阴影渐变。假定加亮出现在左上角，阴影出现在右下角。假定滤镜的一种可能用法：滤镜在加亮中使用四种颜色，在阴影中也使用四种颜色。除了加亮和阴影，滤镜还使用一种基本的填充颜色，这种颜色出现在加亮和阴影接合的边缘。因此所使用的颜色总数是九，比例数组中相应的元素数目也是九。</p>
	
	<p> 如果您将渐变看作由互相混合的各种颜色的条纹组成，则每一个比例值设置颜色在渐变半径上的位置，其中 0 表示渐变最外面的点，255 表示渐变最里面的点。对于一种典型用法，中间值为 128，这是基本的填充值。要获得下面图像中显示的斜角效果，请使用这九种颜色的示例分配比例值，如下所示：</p>
	
	<ul> 
	<li> 前四种颜色的范围是从 0 到 127，它们的值依次增加，以便每个值都大于等于前一个值。这就形成了加亮斜角边缘。</li>
	<li> 第五种颜色（中间颜色）是基本填充，设置为 128。像素值为 128 将设置基本填充，如果类型设置为 outer，基本填充将出现在形状外侧（以及斜角边缘周围）；或者，如果类型设置为 inner，基本填充将出现在形状内侧，将有效地覆盖对象自己的填充。</li>
	<li> 后四种颜色范围是从 129 到 255，它们的值依次增加，以便每个值都大于等于前一个值。这就形成了阴影斜角边缘。</li>
	</ul>
	
	<p> 如果希望平均分布每个边缘的颜色，则使用奇数种颜色，其中中间的颜色为基本填充。平均分布颜色中 0 到 127 以及 129 到 255 之间的值，然后调整值以更改渐变中颜色的每个条纹的宽度。对于具有九种颜色的渐变斜角，可能的数组为 [16, 32, 64, 96, 128, 160, 192, 224, 235]。下面的图像对渐变斜角进行了描绘，如下所示：</p>
	
	<p><adobeimage alt="具有九种颜色的渐变斜角。" href="../../images/gradientBevelRainbow.jpg"/></p>
	
	<p>请记住，颜色在渐变中的散布基于 <codeph>blurX</codeph>、<codeph>blurY</codeph>、<codeph>strength</codeph> 和 <codeph>quality</codeph> 属性的值以及 <codeph>ratios</codeph> 值。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	印记或跨页的强度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>strength</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("strengthExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].strength = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	印记或跨页的强度。该值越高，压印的颜色越深，而且斜角与背景之间的对比度也越强。有效值为 0 到 255。值为 0 表示未应用滤镜。 默认值为 1。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:type:get"><apiName>type</apiName><shortdesc>
	斜角效果的放置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>type</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("typeExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].type = "outer";
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	斜角效果的放置。可能的值为 BitmapFilterType 常量：
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> -- 对象外缘上的斜角</li>
	<li><codeph>BitmapFilterType.INNER</codeph> -- 对象内缘上的斜角</li>
	<li><codeph>BitmapFilterType.FULL</codeph> -- 对象顶部的斜角</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
 使用 GlowFilter 类可以对显示对象应用发光效果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>允许添加发光效果。
 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 GlowFilter 类可以对显示对象应用发光效果。有多个用于发光样式的选项，包括内侧发光或外侧发光以及挖空模式。在投影滤镜的 <codeph>distance</codeph> 和 <codeph>angle</codeph> 属性设置为 0 时，发光滤镜与投影滤镜极为相似。您可以将滤镜应用于任何显示对象（即，从 DisplayObject 类继承的对象），例如 MovieClip、SimpleButton、TextField 和 Video 对象，以及 BitmapData 对象。
 
 <p>滤镜的具体使用取决于要应用滤镜的对象：</p>
 <ul><li>要对显示对象应用滤镜，请使用 <codeph>filters</codeph> 属性（继承自 DisplayObject）。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。 </li>
 
 <li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并最终生成一个过滤图像。</li>
 </ul>
 
 
 <p>如果对显示对象应用滤镜，显示对象的 <codeph>cacheAsBitmap</codeph> 属性将设置为 <codeph>true</codeph>。如果清除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p>

 <p>此滤镜支持舞台缩放。但是，它不支持常规缩放、旋转和倾斜。如果对象本身进行了缩放（如果将 <codeph>scaleX</codeph> 和 <codeph>scaleY</codeph> 设置为除 1.0 以外的其它值），滤镜将不进行缩放。只有用户在舞台上进行放大时它才会缩放。</p>
 
 <p>如果所得图像超过最大尺寸，则不应用滤镜。在 AIR 1.5 和 Flash Player 10 中，最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。例如，如果在放大某大型影片剪辑时应用了滤镜，则所得图像超过最大尺寸时，将关闭该滤镜。</p>
 
 </apiDesc><example conref="examples\GlowFilterExample.as"> 以下示例将绘制一个正方形，并对它应用模糊滤镜。该示例的一般工作流程如下：
 <ol>
  <li>导入所需的类。</li>
  <li>声明 <codeph>draw</codeph> 方法中所用的三个属性，该方法使用 Graphics 类的方法（通过 Sprite 的 <codeph>graphics</codeph> 属性访问）绘制一个橙色正方形。</li>
  <li>创建构造函数，该函数执行以下操作：
      <ul>
          <li>调用 <codeph>draw</codeph> 方法。</li> 
          <li>创建名为 <codeph>filter</codeph> 的新 BitmapFilter 对象，并将对 <codeph>getBitmapFilter()</codeph>（用于定义滤镜）的调用的返回值赋予它。</li>
          <li>创建一个名为 <codeph>myFilters</codeph> 的新数组，并将 <codeph>filter</codeph> 添加到该数组。 </li>
          <li>将 <codeph>myFilters</codeph> 分配给 BevelFilterExample 对象的 <codeph>filters</codeph> 属性。这将应用 <codeph>myFilters</codeph> 中包含的所有滤镜，在本例中仅为 <codeph>filter</codeph>。</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.GlowFilter;

    public class GlowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function GlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x33CCFF;
            var alpha:Number = 0.8;
            var blurX:Number = 35;
            var blurY:Number = 35;
            var strength:Number = 2;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;

            return new GlowFilter(color,
                                  alpha,
                                  blurX,
                                  blurY,
                                  strength,
                                  quality,
                                  inner,
                                  knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/scaleX"><linktext>flash.display.DisplayObject.scaleX</linktext></link><link href="flash.display.xml#DisplayObject/scaleY"><linktext>flash.display.DisplayObject.scaleY</linktext></link><link href="flash.filters.xml#DropShadowFilter/distance"><linktext>flash.filters.DropShadowFilter.distance</linktext></link><link href="flash.filters.xml#DropShadowFilter/angle"><linktext>flash.filters.DropShadowFilter.angle</linktext></link></related-links><apiConstructor id="flash.filters:GlowFilter:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
	用指定参数初始化新的 GlowFilter 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example instantiates a new GlowFilter instance and applies
	it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	
	var color:Number = 0x33CCFF;
	var alpha:Number = .8;
	var blurX:Number = 35;
	var blurY:Number = 35;
	var strength:Number = 2;
	var quality:Number = 3;
	var inner:Boolean = false;
	var knockout:Boolean = false;
	
	var filter:GlowFilter = new GlowFilter(color, 
										 alpha, 
										 blurX, 
										 blurY, 
										 strength, 
										 quality, 
										 inner, 
										 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFF0000</apiData><apiDesc>光晕颜色，采用十六进制格式 0x<i>RRGGBB</i>。默认值为 0xFF0000。
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>颜色的 Alpha 透明度值。有效值为 0 到 1。例如，.25 设置透明度值为 25%。
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>水平模糊量。有效值为 0 到 255（浮点）。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>垂直模糊量。有效值为 0 到 255（浮点）。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>2</apiData><apiDesc>印记或跨页的强度。该值越高，压印的颜色越深，而且发光与背景之间的对比度也越强。有效值为 0 到 255。 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>应用滤镜的次数。使用 BitmapFilterQuality 常量：
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>有关详细信息，请参阅 <codeph>quality</codeph> 属性的说明。</p>
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指定发光是否为内侧发光。值 <codeph> true</codeph> 指定发光是内侧发光。值 <codeph>false</codeph> 指定发光是外侧发光（对象外缘周围的发光）。 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指定对象是否具有挖空效果。值为 <codeph>true</codeph> 将使对象的填充变为透明，并显示文档的背景颜色。 
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	用指定参数初始化新的 GlowFilter 实例。
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GlowFilter/quality"><linktext>GlowFilter.quality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GlowFilter:clone"><apiName>clone</apiName><shortdesc>
	返回此滤镜对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GlowFilter objects and compares them: <code>filter_1</code>
	is created by using the GlowFilter constructor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> strength: 2
		// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> strength: 2
	// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>具有原始 GlowFilter 实例的所有属性的新 GlowFilter 实例。
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回此滤镜对象的副本。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GlowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	颜色的 Alpha 透明度值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterAlpha");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	颜色的 Alpha 透明度值。有效值为 0 到 1。例如，.25 设置透明度值为 25%。默认值为 1。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurX");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurX = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平模糊量。有效值为 0 到 255（浮点）。默认值为 6。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直模糊量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurY");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurY = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直模糊量。有效值为 0 到 255（浮点）。默认值为 6。2 的乘方值（如 2、4、8、16 和 32）经过优化，呈现速度比其它值更快。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:color:get"><apiName>color</apiName><shortdesc>
	光晕颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterColor");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.color = 0x00FF33;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	光晕颜色。有效值采用十六进制格式 0x<i>RRGGBB</i>。默认值为 0xFF0000。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	指定发光是否为内侧发光。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterInner");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	指定发光是否为内侧发光。值 <codeph>true</codeph> 表示内侧发光。默认值为 <codeph>false</codeph>，即外侧发光（对象外缘周围的发光）。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	指定对象是否具有挖空效果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterKnockout");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	指定对象是否具有挖空效果。值为 <codeph>true</codeph> 将使对象的填充变为透明，并显示文档的背景颜色。默认值为 <codeph>false</codeph>（不应用挖空效果）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	应用滤镜的次数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterQuality");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	应用滤镜的次数。默认值为 <codeph>BitmapFilterQuality.LOW</codeph>，与应用一次滤镜等效。值 <codeph>BitmapFilterQuality.MEDIUM</codeph> 两次应用滤镜；值 <codeph>BitmapFilterQuality.HIGH</codeph> 三次应用滤镜。滤镜的值越小，呈现速度越快。
	
	<p>对于大多数应用，<codeph>quality</codeph> 的值为低、中或高就足够了。您可以使用其他数值（最高为 15）来达到不同的效果，但是值越高，呈现速度越慢。除了增加 <codeph>quality</codeph> 的值，仅增加 <codeph>blurX</codeph> 和 <codeph>blurY</codeph> 属性的值通常也可以获得类似的效果，而且呈现速度更快。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	印记或跨页的强度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterStrength");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.strength = .8;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	印记或跨页的强度。 该值越高，压印的颜色越深，而且发光与背景之间的对比度也越强。 有效值为 0 到 255。默认值为 2。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
	 ShaderFilter 类通过对应用了滤镜的对象执行着色器来应用滤镜。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ShaderFilter 类通过对应用了滤镜的对象执行着色器来应用滤镜。应用了滤镜的对象将用作着色器输入，而着色器输出将用作滤镜效果。
	 
	 <p>要创建新的滤镜，请使用构造函数 <codeph>new ShaderFilter()</codeph>。滤镜的具体使用取决于要应用滤镜的对象：</p>
	 
	 <ul>
	   <li>要对影片剪辑、文本字段、按钮和视频应用滤镜，请使用 <codeph>filters</codeph> 属性（继承自 DisplayObject）。设置对象的 <codeph>filters</codeph> 属性不会修改相应的对象，而清除 <codeph>filters</codeph> 属性可以删除相应的滤镜。</li>
	   <li>要对 BitmapData 对象应用滤镜，请使用 <codeph>BitmapData.applyFilter()</codeph> 方法。对 BitmapData 对象调用 <codeph>applyFilter()</codeph> 会取得源 BitmapData 对象和滤镜对象，并最终生成一个过滤图像。</li>
	 </ul>
	 
	 <p>如果对显示对象应用滤镜，则该对象的 <codeph>cacheAsBitmap</codeph> 属性值将设置为 true。如果删除所有滤镜，将恢复 <codeph>cacheAsBitmap</codeph> 的原始值。</p>
	 
	 <p>此滤镜支持舞台缩放。但是，它不支持常规缩放、旋转和倾斜。如果对象本身进行了缩放（如果 <codeph>scaleX</codeph> 和 <codeph>scaleY</codeph> 属性未被设置为 100%），则滤镜不进行缩放。只有用户在舞台上进行放大时它才会缩放。</p>
	 
	 <p>如果所得图像超过最大尺寸，则不应用滤镜。在 AIR 1.5 和 Flash Player 10 中，最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。例如，如果在放大某大型影片剪辑时应用了滤镜，则所得图像超过最大尺寸时，将关闭该滤镜。</p>
	 
	 <p>要指定将 Shader 实例用于滤镜，请将 Shader 实例作为参数传递到 <codeph>ShaderFilter()</codeph> 构造函数，或将其设置为 <codeph>shader</codeph> 属性的值。</p>
	 
	 <p>要允许着色器输出超出已过滤对象的范围，请使用 <codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph> 和 <codeph>bottomExtension</codeph> 属性。</p>
	 
	 </apiDesc><example conref="examples\ShaderFilterExample.1.as"> 下面的示例中加载了一个着色器，并将其用作 ShaderFilter 的 <codeph>shader</codeph> 属性。代码在 Sprite 实例中绘制一个圆并将其添加到舞台。加载着色器时，会对该 Sprite 应用着色器滤镜。
 
 <p>请注意，此示例假定在与应用程序的输出目录相同的目录中存在一个名为“gradient.pbj”的着色器字节码文件。</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel RedGradientFilter
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "Applies a gradient across the red channel of the input image.";
>
{
    input image4 src;
    output pixel4 dst;
    
    parameter float width
    &lt;
        description: "The width of the image to which the shader is applied.";
        minValue: 0.0;
    >;

    void evaluatePixel()
    {
        pixel4 temp = sampleNearest(src, outCoord());
        temp.r = 1.0 - (outCoord().x * (1.0 / width));
        dst = temp;
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.filters.ShaderFilter;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderFilterExample extends Sprite {
        
        private var loader:URLLoader;
        private var s:Sprite;
        
        public function ShaderFilterExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("gradient.pbj"));
            
            s = new Sprite();
            s.graphics.beginFill(0x009900);
            s.graphics.drawCircle(100, 100, 100);
            addChild(s);
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader(loader.data);
            shader.data.width.value = [s.width];
            
            var gradientFilter:ShaderFilter = new ShaderFilter(shader);
            s.filters = [gradientFilter];
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links><apiConstructor id="flash.filters:ShaderFilter:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
		 创建新的着色器滤镜。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>要为此滤镜使用的着色器。有关详细信息以及着色器必须符合的限制，请参阅 <codeph>shader</codeph> 属性的说明。
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 创建新的着色器滤镜。
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#ShaderFilter/shader"><linktext>shader</linktext></link></related-links></apiConstructor><apiValue id="flash.filters:ShaderFilter:bottomExtension:get"><apiName>bottomExtension</apiName><shortdesc>
		 目标对象底部的增大量（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 目标对象底部的增大量（以像素为单位）。
		 
		 <p>该增大量是指超出目标对象范围并在执行着色器期间传递到该着色器的范围。在执行着色器时，Flash Player 或 AIR 将计算影片剪辑的正常范围，然后基于 <codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph> 和 <codeph>bottomExtension</codeph> 值扩展该范围。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:leftExtension:get"><apiName>leftExtension</apiName><shortdesc>
		 目标对象左侧的增大量（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 目标对象左侧的增大量（以像素为单位）。
		 
		 <p>该增大量是指超出目标对象范围并在执行着色器期间传递到该着色器的范围。在执行着色器时，Flash Player 或 AIR 将计算影片剪辑的正常范围，然后基于 <codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph> 和 <codeph>bottomExtension</codeph> 值扩展该范围。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:rightExtension:get"><apiName>rightExtension</apiName><shortdesc>
		 目标对象右侧的增大量（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 目标对象右侧的增大量（以像素为单位）。
		 
		 <p>该增大量是指超出目标对象范围并在执行着色器期间传递到该着色器的范围。在执行着色器时，Flash Player 或 AIR 将计算影片剪辑的正常范围，然后基于 <codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph> 和 <codeph>bottomExtension</codeph> 值扩展该范围。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:shader:get"><apiName>shader</apiName><shortdesc>
		 要为此滤镜使用的着色器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 要为此滤镜使用的着色器。
		 
		 <p>分配给 <codeph>shader</codeph> 属性的着色器必须指定至少一个 <codeph>image4</codeph> 输入。<b>不</b>需要使用关联 ShaderInput 对象的 <codeph>input</codeph> 属性在代码中指定输入。而将应用了滤镜的对象自动用作第一个输入（<codeph>index</codeph> 为 0 的输入）。用作滤镜的着色器可以指定多个输入，而在这种情况下，如果要指定任何其它输入，则必须设置其 ShaderInput 实例的 <codeph>input</codeph> 属性。</p>
		 
		 <p>如果为此属性分配一个 Shader 实例，则会在内部复制着色器，过滤操作将使用该内部副本，而不会引用原始着色器。对着色器所做的任何更改（例如更改参数值、输入或字节代码）不会应用到用于滤镜的着色器副本。要使对着色器所做的更改能够影响滤镜输出，则必须将 Shader 实例重新分配给 <codeph>shader</codeph> 属性。对于所有滤镜，还必须将 ShaderFilter 实例重新分配给显示对象的 <codeph>filters</codeph> 属性才能应用滤镜更改。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:topExtension:get"><apiName>topExtension</apiName><shortdesc>
		 目标对象顶部的增大量（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 目标对象顶部的增大量（以像素为单位）。
		 
		 <p>该增大量是指超出目标对象范围并在执行着色器期间传递到该着色器的范围。在执行着色器时，Flash Player 或 AIR 将计算影片剪辑的正常范围，然后基于 <codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph> 和 <codeph>bottomExtension</codeph> 值扩展该范围。</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>