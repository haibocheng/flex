<?xml version="1.0"?>
<apiPackage id="flash.geom"><apiName>flash.geom</apiName><apiDetail/><apiClassifier id="flash.geom:Utils3D"><apiName>Utils3D</apiName><shortdesc> 
 Utils3D 类包含一些静态方法，可用于简化某些三维矩阵操作的实现过程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>一个实用程序类，其中包含可用于简化某些三维操作的实现过程的静态方法。 
 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Utils3D 类包含一些静态方法，可用于简化某些三维矩阵操作的实现过程。
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Vector3D"><linktext>flash.geom.Vector3D</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links><apiOperation id="flash.geom:Utils3D:pointTowards"><apiName>pointTowards</apiName><shortdesc>
    朝着某个位置插补对象的方向。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>第二个参数中指定的 Matrix3D 对象的修改后版本。要使用 <codeph>pointTowards()</codeph> 方法转换显示对象，请将显示对象的 Matrix3D 属性设置为返回的 Matrix3D 对象。
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个介于 0 和 1 之间的数字，它使对象逐步朝着目标转变。
    
    </apiDesc></apiParam><apiParam><apiItemName>mat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>转换的对象的 Matrix3D 属性。 
    
    </apiDesc></apiParam><apiParam><apiItemName>pos</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>目标对象的相对于现实世界的位置。相对于现实世界定义了相对于所有对象所在的现实世界空间和坐标的对象转换。  
    
    </apiDesc></apiParam><apiParam><apiItemName>at</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>用于定义显示对象所指向的位置的相对于对象的矢量。相对于对象定义了相对于对象空间（即对象自己的参照帧和坐标系统）的对象转换。默认值为 (0,0,-1)。
    
    </apiDesc></apiParam><apiParam><apiItemName>up</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>用于为显示对象定义“向上”方向的相对于对象的矢量。如果从上至下绘制对象，则 <i>+z</i> 轴为该对象的“up”矢量。相对于对象定义了相对于对象空间（即对象自己的参照帧和坐标系统）的对象转换。默认值为 (0,-1,0)。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    朝着某个位置插补对象的方向。<codeph>pointTowards()</codeph> 方法结合了 <codeph>Matrix3D.pointAt()</codeph> 和 <codeph>Matrix3D.interpolateTo()</codeph> 方法的功能。  
    
    <p><codeph>pointTowards()</codeph> 方法允许对方向进行就地修改。此方法将对显示对象的 Matrix3D 进行分解，并将旋转元素替换为可使对象朝着目标位置进行不同的百分比转变的元素。此对象可以在仍按自己的方向移动的同时，逐步向目标转变。对 <codeph>pointTowards()</codeph> 的连续调用（后跟一个转换方法）可生成对象追逐或紧随移动的目标运动的动画。首先将对象指向一个朝向目标的百分比点，然后沿某个轴逐步移动对象。</p> 
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/pointAt()"><linktext>flash.geom.Matrix3D.pointAt()</linktext></link><link href="flash.geom.xml#Matrix3D/interpolateTo()"><linktext>flash.geom.Matrix3D.interpolateTo()</linktext></link><link href="flash.geom.xml#Matrix3D/interpolate()"><linktext>flash.geom.Matrix3D.interpolate()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Utils3D:projectVector"><apiName>projectVector</apiName><shortdesc>
    利用投影 Matrix3D 对象，将 Vector3D 对象从一个空间坐标投影到另一个空间坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>一个具有转换后的空间坐标的新 Vector3D。
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>一个用于实现投影转换的投影 Matrix3D 对象。如果某个显示对象中包含 PerspectiveProjection 对象，则可以使用 <codeph>perspectiveProjection.toMatrix()</codeph> 方法生成适用于该显示对象的子级的投影 Matrix3D 对象。对于更高级的投影，请使用 <codeph>matrix3D.rawData</codeph> 属性创建自定义投影矩阵。不存在用于创建投影 Matrix3D 对象的内置的 Matrix3D 方法。
    
    </apiDesc></apiParam><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>投影到新的空间坐标的 Vector3D 对象。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    利用投影 Matrix3D 对象，将 Vector3D 对象从一个空间坐标投影到另一个空间坐标。<codeph>projectVector()</codeph> 方法与 <codeph>Matrix3D.transformVector()</codeph> 方法类似，只不过 <codeph>projectVector()</codeph> 方法将按照投影深度值来划分原始 Vector3D 对象的 <i>x</i>、<i>y</i> 和 <i>z</i> 元素。深度值是指视图或视角空间中从视点到 Vector3D 对象的距离。此距离的默认值为 <i>z</i> 元素的值。
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>flash.geom.Matrix3D.transformVector()</linktext></link><link href="flash.geom.xml#Utils3D/projectVectors()"><linktext>projectVectors()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Utils3D:projectVectors"><apiName>projectVectors</apiName><shortdesc>
    利用投影 Matrix3D 对象，将一个三维空间坐标矢量 (verts) 投影到一个二维空间坐标矢量 (projectedVerts)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>一个用于实现投影转换的投影 Matrix3D 对象。可以使用 <codeph>Matrix3D.rawData</codeph> 属性生成投影 Matrix3D 对象。
    </apiDesc></apiParam><apiParam><apiItemName>verts</apiItemName><apiType value="Vector$Number"/><apiDesc>一个由数字构成的矢量，其中的每三个数字表示一个三维空间的 <i>x</i>、<i>y</i> 和 <i>z</i> 坐标，如 <codeph>Vector3D(x,y,z)</codeph>。 
    
    </apiDesc></apiParam><apiParam><apiItemName>projectedVerts</apiItemName><apiType value="Vector$Number"/><apiDesc>一个由数字构成的矢量，其中的每两个数字表示一个投影的二维坐标，如 <codeph>Point(x,y)</codeph>。应预先分配相应的矢量。<codeph>projectVectors()</codeph> 方法将为每个投影的点填充值。
    
    </apiDesc></apiParam><apiParam><apiItemName>uvts</apiItemName><apiType value="Vector$Number"/><apiDesc>一个由数字构成的矢量，其中的每三个数字表示 <codeph>uvt</codeph> 数据的 <i>u</i>、<i>v</i> 和 <i>t</i> 元素。<i>u</i> 和 <i>v</i> 是每个投影的点的纹理坐标。<i>t</i> 值为投影深度值，即视图或视角空间中从视点到 Vector3D 对象的距离。应预先分配相应的矢量并指定 <i>u</i> 和 <i>v</i> 值。<codeph>projectVectors</codeph> 方法将为每个投影的点填充 <i>t</i> 值。
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>将一个三维空间坐标矢量投影到一个二维空间坐标矢量。
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    利用投影 Matrix3D 对象，将一个三维空间坐标矢量 (<i>verts</i>) 投影到一个二维空间坐标矢量 (<codeph>projectedVerts</codeph>)。在将投影的 Vector 对象用作参数之前，应预先分配该对象。 
    
    <p><codeph>projectVectors()</codeph> 方法还会设置 <i>uvt</i> 数据的 <i>t</i> 值。应预先分配一个矢量，并且该矢量应可以容纳每个投影的坐标集矢量的 <i>uvts</i> 数据。还应指定 <i>uvt</i> 数据的 <i>u</i> 和 <i>v</i> 值。<i>uvt</i> 数据是一个用于纹理映射的标准化坐标矢量。对于 UV 坐标，(0,0) 是位图的左上角，(1,1) 是位图的右下角。</p>
    
    <p>可将此方法与 <codeph>Graphics.drawTriangles()</codeph> 方法和 <codeph>GraphicsTrianglePath</codeph> 类配合使用。</p>  
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D/projectVector()"><linktext>projectVector()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.geom:Vector3D"><apiName>Vector3D</apiName><shortdesc> 
 Vector3D 类使用笛卡尔坐标 x、y 和 z 表示三维空间中的点或位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Vector3D 类使用笛卡尔坐标 x、y 和 z 表示三维空间中的点或位置。与在二维空间中一样，<codeph>x</codeph> 属性表示水平轴，<codeph>y</codeph> 属性表示垂直轴。在三维空间中，<codeph>z</codeph> 属性表示深度。当对象向右移动时，<codeph>x</codeph> 属性的值会增大。当对象向下移动时，<codeph>y</codeph> 属性的值会增大。当对象远离视点时，<codeph>z</codeph> 属性的值会增大。若使用透视投影和缩放，则对象在靠近屏幕时会显得大一些，而在远离屏幕时会显得小一些。正如右手三维坐标系中一样，正向 z 轴指向远离查看者的方向，并且当对象远离查看者的视线时，<codeph>z</codeph> 属性的值增大。全局空间的原点 (0,0,0) 位于舞台的左上角。 
   
 <p><adobeimage alt="X、Y、Z 轴" href="../../images/xyzAxes.jpg"/></p>
 
 <p>Vector3D 类还可以表示方向，即一个从坐标原点（例如 (0,0,0)）指向一个端点的箭头；或表示 RGB（红、绿、蓝）颜色模型的一个浮点组件。</p> 
 
 <p>四元数表示法引入了第四个元素（<codeph>w</codeph> 属性），该元素提供额外的方向信息。例如，<codeph>w</codeph> 属性可以定义 Vector3D 对象的旋转角度。旋转角度和坐标 x、y 和 z 的组合可确定显示对象的方向。以下是 Vector3D 元素在矩阵表示法中的表示形式：</p>
 
 <p><adobeimage alt="Vector3D 元素" href="../../images/Vector3Delements.jpg"/></p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links><apiConstructor id="flash.geom:Vector3D:Vector3D"><apiName>Vector3D</apiName><shortdesc>
     创建 Vector3D 对象的实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>第一个元素，例如 x 坐标。 
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>第二个元素，例如 y 坐标。 
     </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>第三个元素，例如 z 坐标。 
     </apiDesc></apiParam><apiParam><apiItemName>w</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.</apiData><apiDesc>表示额外数据的可选元素，例如旋转角度。 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建 Vector3D 对象的实例。如果未指定构造函数的参数，则将使用元素 (0,0,0,0) 创建 Vector3D 对象。
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Vector3D:add"><apiName>add</apiName><shortdesc>
    将当前 Vector3D 对象的 x、y 和 z 元素的值与另一个 Vector3D 对象的 x、y 和 z 元素的值相加。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 Vector3D 对象，它是将当前 Vector3D 对象与另一个 Vector3D 对象相加所产生的结果。
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>要与当前 Vector3D 对象相加的 Vector3D 对象。
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>将当前 Vector3D 对象与另一个同类对象相加以创建新的 Vector3D 对象。 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    将当前 Vector3D 对象的 x、y 和 z 元素的值与另一个 Vector3D 对象的 x、y 和 z 元素的值相加。<codeph>add()</codeph> 方法不更改当前的 Vector3D 对象。相反，此方法将返回具有新值的新 Vector3D 对象。
    
    <p>将两个矢量相加即可获得一个合成矢量。一种用于可视化结果的方法是，从第一个矢量的原点或尾部到第二个矢量的结束点或开头绘制一个矢量。合成矢量是第一个矢量的原点与第二个矢量的结束点之间的距离。</p>   
    
    <p><adobeimage alt="合成 Vector3D" href="../../images/resultantVector3D.jpg"/></p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/incrementBy()"><linktext>incrementBy()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:angleBetween"><apiName>angleBetween</apiName><shortdesc>
    返回两个矢量之间的弧度的角度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>两个 Vector3D 对象之间的角度。
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>第一个 Vector3D 对象。
    </apiDesc></apiParam><apiParam><apiItemName>b</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>第二个 Vector3D 对象。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    返回两个矢量之间的弧度的角度。返回的角度是第一个 Vector3D 对象旋转到与第二个 Vector3D 对象对齐的位置时所形成的最小弧度。 
    
    <p><codeph>angleBetween()</codeph> 方法是静态方法。可以将此方法直接用作 Vector3D 类的方法。</p>
    
    <p>要将一个角度转换成弧度，可以使用以下公式：</p> 
    
    <p><codeph>radian = Math.PI/180 ~~ degree</codeph></p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:clone"><apiName>clone</apiName><shortdesc>
    返回一个新 Vector3D 对象，它是与当前 Vector3D 对象完全相同的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个新 Vector3D 对象，它是当前 Vector3D 对象的副本。
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    返回一个新 Vector3D 对象，它是与当前 Vector3D 对象完全相同的副本。
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:crossProduct"><apiName>crossProduct</apiName><shortdesc>
    返回一个新的 Vector3D 对象，它与当前 Vector3D 对象和另一个 Vector3D 对象垂直（成直角）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个新的 Vector3D 对象，它与当前 Vector3D 对象和作为参数指定的 Vector3D 对象垂直。
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>第二个 Vector3D 对象。 
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    返回一个新的 Vector3D 对象，它与当前 Vector3D 对象和另一个 Vector3D 对象垂直（成直角）。如果返回的 Vector3D 对象的坐标为 (0,0,0)，则表示两个 Vector3D 对象互相垂直。
    
    <p><adobeimage alt="叉积" href="../../images/crossproduct.jpg"/></p>
    
    <p>可以将多边形表面的两个顶点的标准化叉积与摄像头或眼睛视点的标准化矢量结合使用来获取点积。点积的值可以确定是否从视点中隐藏三维对象的某个表面。</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/dotProduct()"><linktext>dotProduct()</linktext></link><link href="flash.geom.xml#Vector3D/normalize()"><linktext>normalize()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:decrementBy"><apiName>decrementBy</apiName><shortdesc>
    按照指定的 Vector3D 对象的 x、y 和 z 元素的值递减当前 Vector3D 对象的 x、y 和 z 元素的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>包含要从当前 Vector3D 对象中减去的值的 Vector3D 对象。
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>按照另一个 Vector3D 对象递减当前的 Vector3D 对象。  
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    按照指定的 Vector3D 对象的 x、y 和 z 元素的值递减当前 Vector3D 对象的 x、y 和 z 元素的值。与 <codeph>Vector3D.subtract()</codeph> 方法不同，<codeph>decrementBy()</codeph> 方法会更改当前的 Vector3D 对象并且不返回新的 Vector3D 对象。
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/subtract()"><linktext>subtract()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:distance"><apiName>distance</apiName><shortdesc>
    返回两个 Vector3D 对象之间的距离。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>两个 Vector3D 对象之间的距离。
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>用作第一个三维点的 Vector3D 对象。 
    </apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>用作第二个三维点的 Vector3D 对象。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    返回两个 Vector3D 对象之间的距离。<codeph>distance()</codeph> 方法是静态方法。可以将此方法直接用作 Vector3D 类的方法，以获取两个三维点之间的欧几里德距离。
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:dotProduct"><apiName>dotProduct</apiName><shortdesc>
    如果当前 Vector3D 对象和作为参数指定的 Vector3D 对象均为单位顶点，此方法将返回这两个顶点之间所成角的余弦值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个标量，它是当前 Vector3D 对象与指定的 Vector3D 对象之间的点积。
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>第二个 Vector3D 对象。 
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>返回当前 Vector3D 对象与另一个 Vector3D 对象的点积。
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    如果当前 Vector3D 对象和作为参数指定的 Vector3D 对象均为单位顶点，此方法将返回这两个顶点之间所成角的余弦值。单位顶点是指向同一方向且长度为一的顶点。它们会在结果中将矢量长度作为一个因子删除。可以使用 <codeph>normalize()</codeph> 方法将一个矢量转换为单位矢量。 
    
    <p><codeph>dotProduct()</codeph> 方法会找出两个顶点之间所成的角。它还用于背面剔除或照明计算。背面剔除是一个用于确定从视点中隐藏哪些表面的过程。可以使用摄像头或眼睛视点的标准化顶点和多边形表面的顶点的叉积来获取点积。如果点积小于零，则表面将面向摄像头或查看者。如果两个单位顶点互相垂直，则二者正交且点积为零。如果两个单位顶点互相平行，则点积为一。</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/crossProduct()"><linktext>crossProduct()</linktext></link><link href="flash.geom.xml#Vector3D/normalize()"><linktext>normalize()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:equals"><apiName>equals</apiName><shortdesc>
    通过将当前 Vector3D 对象的 x、y 和 z 元素与指定的 Vector3D 对象的 x、y 和 z 元素进行比较，确定这两个对象是否相等。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果指定的 Vector3D 对象与当前 Vector3D 对象相等，则为 <codeph>true</codeph> 值；否则为 <codeph>false</codeph>。
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>要与当前 Vector3D 对象进行比较的 Vector3D 对象。
    </apiDesc></apiParam><apiParam><apiItemName>allFour</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>一个可选参数，它指定在比较时是否使用 Vector3D 对象的 <codeph>w</codeph> 属性。  
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    通过将当前 Vector3D 对象的 x、y 和 z 元素与指定的 Vector3D 对象的 x、y 和 z 元素进行比较，确定这两个对象是否相等。如果这些元素的值相同，则两个 Vector3D 对象相等。如果第二个可选参数设置为 <codeph>true</codeph>，则将对 Vector3D 对象的所有四个元素（包括 <codeph>w</codeph> 属性）进行比较。 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/nearEquals()"><linktext>nearEquals()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:incrementBy"><apiName>incrementBy</apiName><shortdesc>
    按照指定的 Vector3D 对象的 x、y 和 z 元素的值递增当前 Vector3D 对象的 x、y 和 z 元素的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>要与当前的 Vector3D 对象相加的 Vector3D 对象。
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>按照另一个 Vector3D 对象递增当前的 Vector3D 对象。 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    按照指定的 Vector3D 对象的 x、y 和 z 元素的值递增当前 Vector3D 对象的 x、y 和 z 元素的值。与 <codeph>Vector3D.add()</codeph> 方法不同，<codeph>incrementBy()</codeph> 方法会更改当前的 Vector3D 对象并且不返回新的 Vector3D 对象。
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/add()"><linktext>add()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:nearEquals"><apiName>nearEquals</apiName><shortdesc>
    将当前 Vector3D 对象的元素与指定的 Vector3D 对象的元素进行比较，以确定它们是否大致相同。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果指定的 Vector3D 对象与当前 Vector3D 对象相等，则为 <codeph>true</codeph> 值；否则为 <codeph>false</codeph>。
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>要与当前 Vector3D 对象进行比较的 Vector3D 对象。 
    </apiDesc></apiParam><apiParam><apiItemName>tolerance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个用于确定容差因子的数字。如果 <codeph>toCompare</codeph> 参数中指定的 Vector3D 元素的值与当前 Vector3D 元素的值之差小于容差数，则将这两个值视为大致相等。  
    </apiDesc></apiParam><apiParam><apiItemName>allFour</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>一个可选参数，它指定在比较时是否使用 Vector3D 对象的 <codeph>w</codeph> 属性。  
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    将当前 Vector3D 对象的元素与指定的 Vector3D 对象的元素进行比较，以确定它们是否大致相同。如果两个顶点的所有元素的值都相等或比较的结果在容差范围内，则两个 Vector3D 对象大致相等。两个元素的值之差必须小于作为 <codeph>tolerance</codeph> 参数指定的数字。如果第三个可选参数设置为 <codeph>true</codeph>，则将对 Vector3D 对象的所有四个元素（包括 <codeph>w</codeph> 属性）进行比较。否则，比较中仅包含 x、y 和 z 元素。
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/equals()"><linktext>equals()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:negate"><apiName>negate</apiName><shortdesc>
    将当前 Vector3D 对象设置为其逆对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    将当前 Vector3D 对象设置为其逆对象。也可以将逆对象视为与原始对象相反的对象。当前 Vector3D 对象的 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>z</codeph> 属性的值将更改为 <codeph>-x</codeph>、<codeph>-y</codeph> 和 <codeph>-z</codeph>。 
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:normalize"><apiName>normalize</apiName><shortdesc>
    通过将最前面的三个元素（x、y、z）除以矢量的长度可将 Vector3D 对象转换为单位矢量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>当前 Vector3D 对象的长度。
    
    </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    通过将最前面的三个元素（x、y、z）除以矢量的长度可将 Vector3D 对象转换为单位矢量。单位顶点是具有同一方向且长度为一的顶点。它们通过将长度作为一个因子删除，从而简化了矢量计算。
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:project"><apiName>project</apiName><shortdesc>
     将当前 Vector3D 对象的 x、y 和 z 属性的值除以其 w 属性的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     将当前 Vector3D 对象的 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>z</codeph> 属性的值除以其 <codeph>w</codeph> 属性的值。 
     
     <p>如果当前 Vector3D 对象是将一个 Vector3D 对象与一个投影 Matrix3D 对象相乘后获得的结果，则 <codeph>w</codeph> 属性可以容纳转换值。然后，<codeph>project()</codeph> 方法可以通过将这些元素除以 <codeph>w</codeph> 属性来完成投影。使用 <codeph>Matrix3D.rawData</codeph> 属性可创建投影 Matrix3D 对象。</p>
     
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:scaleBy"><apiName>scaleBy</apiName><shortdesc>
    按标量（大小）缩放当前的 Vector3D 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>s</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个用于缩放 Vector3D 对象的乘数（标量）。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    按标量（大小）缩放当前的 Vector3D 对象。Vector3D 对象的 x、y 和 z 元素乘以参数中指定的标量数字。例如，如果将矢量放大 10 倍，则得到的矢量的长度比原来的矢量大 10 倍。标量还可以更改矢量的方向。若将矢量乘以一个负数，则将反转该矢量的方向。
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Vector3D:subtract"><apiName>subtract</apiName><shortdesc>
    从另一个 Vector3D 对象的 x、y 和 z 元素的值中减去当前 Vector3D 对象的 x、y 和 z 元素的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个新的 Vector3D 对象，它是当前 Vector3D 对象与指定的 Vector3D 对象之差。
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>要从当前 Vector3D 对象中减去的 Vector3D 对象。
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>从另一个 Vector3D 对象中减去当前 Vector3D 对象以创建新的 Vector3D 对象。 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    从另一个 Vector3D 对象的 x、y 和 z 元素的值中减去当前 Vector3D 对象的 x、y 和 z 元素的值。<codeph>subtract()</codeph> 方法不更改当前的 Vector3D 对象。相反，此方法将返回一个具有新值的新的 Vector3D 对象。
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Vector3D/decrementBy()"><linktext>decrementBy()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Vector3D:toString"><apiName>toString</apiName><shortdesc>
     返回当前 Vector3D 对象的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个字符串，它包含 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>z</codeph> 属性的值。
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     返回当前 Vector3D 对象的字符串表示形式。该字符串包含 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>z</codeph> 属性的值。
     
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Vector3D:X_AXIS"><apiName>X_AXIS</apiName><shortdesc>
    定义为 Vector3D 对象的 x 轴，坐标为 (1,0,0)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    定义为 Vector3D 对象的 x 轴，坐标为 (1,0,0)。
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:Y_AXIS"><apiName>Y_AXIS</apiName><shortdesc>
    定义为 Vector3D 对象的 y 轴，坐标为 (0,1,0)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    定义为 Vector3D 对象的 y 轴，坐标为 (0,1,0)。
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:Z_AXIS"><apiName>Z_AXIS</apiName><shortdesc>
    定义为 Vector3D 对象的 z 轴，坐标为 (0,0,1)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    定义为 Vector3D 对象的 z 轴，坐标为 (0,0,1)。
    
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:w"><apiName>w</apiName><shortdesc>
     Vector3D 对象的第四个元素（除了 x、y 和 z 属性之外）可以容纳数据，例如旋转角度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Vector3D 对象的第四个元素（除了 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>z</codeph> 属性之外）可以容纳数据，例如旋转角度。默认值为 0。
     
     <p>四元数表示法在三维旋转计算中，会将角度用作第四个元素。<codeph>w</codeph> 属性可用于定义有关 Vector3D 对象的旋转角度。旋转角度和坐标（x、y、z）的组合可确定显示对象的方向。 </p>
     <p>此外，可以将 <codeph>w</codeph> 属性用作投影的三维位置的透视变形因子，或用作表示投影到二维空间中的三维坐标的投影转换值。例如，可以使用 <codeph>Matrix3D.rawData</codeph> 属性创建一个投影矩阵，在将此矩阵应用于 Vector3D 对象时，该对象的第四个元素（<codeph>w</codeph> 属性）中会生成一个转换值。然后，将该 Vector3D 对象的其它元素除以此转换值可生成一个投影的 Vector3D 对象。可以使用 <codeph>Vector3D.project()</codeph> 方法将 Vector3D 对象的前三个元素除以它的第四个元素。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/project()"><linktext>project()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Vector3D:x"><apiName>x</apiName><shortdesc>
     Vector3D 对象中的第一个元素，例如，三维空间中某个点的 x 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Vector3D 对象中的第一个元素，例如，三维空间中某个点的 x 坐标。默认值为 0。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:y"><apiName>y</apiName><shortdesc>
     Vector3D 对象中的第二个元素，例如，三维空间中某个点的 y 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Vector3D 对象中的第二个元素，例如，三维空间中某个点的 y 坐标。默认值为 0。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:z"><apiName>z</apiName><shortdesc>
     Vector3D 对象中的第三个元素，例如，三维空间中某个点的 z 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Vector3D 对象中的第三个元素，例如，三维空间中某个点的 z 坐标。默认值为 0。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Vector3D:length:get"><apiName>length</apiName><shortdesc>
    当前 Vector3D 对象的长度（大小），即从原点 (0,0,0) 到该对象的 x、y 和 z 坐标的距离。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>当前 Vector3D 对象的长度。 
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    当前 Vector3D 对象的长度（大小），即从原点 (0,0,0) 到该对象的 x、y 和 z 坐标的距离。<codeph>w</codeph> 属性将被忽略。单位矢量具有的长度或大小为一。
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/lengthSquared"><linktext>lengthSquared</linktext></link></related-links></apiValue><apiValue id="flash.geom:Vector3D:lengthSquared:get"><apiName>lengthSquared</apiName><shortdesc>
    当前 Vector3D 对象长度的平方，它是使用 x、y 和 z 属性计算出来的。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>当前 Vector3D 对象长度的平方。 
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    当前 Vector3D 对象长度的平方，它是使用 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>z</codeph> 属性计算出来的。<codeph>w</codeph> 属性将被忽略。尽可能使用 <codeph>lengthSquared()</codeph> 方法，而不要使用 <codeph>Vector3D.length()</codeph> 方法的 <codeph>Math.sqrt()</codeph> 方法调用，后者速度较慢。
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Vector3D/length"><linktext>length</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:Matrix3D"><apiName>Matrix3D</apiName><shortdesc>
 Matrix3D 类表示一个转换矩阵，该矩阵确定三维 (3D) 显示对象的位置和方向。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><internal>Removed the following since it was very unclear. It could be used for a future example however:
 <p>To support a camera viewpoint and motion, create a camera class that keeps a Matrix3D object for 
 handling the movement of the display objects relative to the camera. In the camera space, the display objects 
 move in the opposite direction of the camera movement. For example, when the camera moves closer, the objects 
 become bigger. In other words, if the camera moves down the world z axis, the objects moves up 
 the z axis. One way to produce this effect is by setting the Matrix3D object of the camera class 
 to the inverse of the display objects' transformation. If the display objects are children of the <code>root</code> 
 display object, the Matrix3D object of the camera class can be set to the inverse of the <code>root</code> 
 display object. Another option is to have the display objects as children of a camera object.</p>
 
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Matrix3D 类表示一个转换矩阵，该矩阵确定三维 (3D) 显示对象的位置和方向。该矩阵可以执行转换功能，包括平移（沿 x、y 和 z 轴重新定位）、旋转和缩放（调整大小）。Matrix3D 类还可以执行透视投影，这会将 3D 坐标空间中的点映射到二维 (2D) 视图。 
 
 <p>单一矩阵可以将多个转换组合在一起，并一次性对 3D 显示对象应用这些转换。例如，可以将一个矩阵应用于 3D 坐标，以便依次执行旋转和平移。 </p> 
 
 <p>当显式设置一个显示对象的 <codeph>z</codeph> 属性或任何旋转或缩放属性时，将自动创建相应的 Matrix3D 对象。</p>
 
 <p>可以通过 <codeph>transform.matrix3d</codeph> 属性访问 3D 显示对象的 Matrix3D 对象。2D 对象不具有 Matrix3D 对象。 </p>
 
 <p>2D 对象的 <codeph>z</codeph> 属性的值为零，并且其 <codeph>matrix3D</codeph> 属性的值为 <codeph>null</codeph>。</p> 
 
 <p><b>注意：</b>如果将同一 Matrix3D 对象分配给两个不同的显示对象，则将引发运行时错误。</p>
 
 <p>Matrix3D 类使用一个 4x4 正方形矩阵，即一个由四行和四列数字构成的表，其中容纳了用于转换的数据。矩阵的前三行容纳每个 3D 轴 (x,y,z) 的数据。平移信息位于最后一列中。方向和缩放数据位于前三个列中。缩放因子是位于前三个列中的对角数字。以下是 Matrix3D 元素的表示形式：</p>  
 
 <p><adobeimage alt="Matrix3D 元素" href="../../images/Matrix3Delements.jpg"/></p>
 
 <p>无需了解矩阵数学，即可使用 Matrix3D 类。该类提供了一些用于简化转换和投影任务的特定方法，例如 <codeph>appendTranslation()</codeph>、<codeph>appendRotation()</codeph> 或 <codeph>interpolateTo()</codeph> 方法。还可以使用 <codeph>decompose()</codeph> 和 <codeph>recompose()</codeph> 方法或 <codeph>rawData</codeph> 属性来访问基础矩阵元素。</p>
 
 <p>显示对象会对其轴旋转属性进行缓存，以便使每个轴具有单独的旋转并管理不同的旋转组合。若调用 Matrix3D 对象的某一方法来转换显示对象，则该对象的旋转缓存无效。</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Vector3D"><linktext>flash.geom.Vector3D</linktext></link><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links><apiConstructor id="flash.geom:Matrix3D:Matrix3D"><apiName>Matrix3D</apiName><shortdesc>
    创建 Matrix3D 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>v</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>一个由 16 个数字组成的矢量，其中，每四个元素可以是 4x4 矩阵的一行或一列。
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    创建 Matrix3D 对象。可以使用一个由 16 个数字组成的矢量来初始化 Matrix3D 对象，其中，每四个元素可以是一行或一列。创建 Matrix3D 对象之后，可以使用 <codeph>rawData</codeph> 属性访问该对象的矩阵元素。 
    
    <p>如果未定义任何参数，则构造函数会生成一个恒等或单位 Matrix3D 对象。在矩阵表示法中，恒等矩阵中的主对角线位置上的所有元素的值均为一，而所有其它元素的值均为零。恒等矩阵的 <codeph>rawData</codeph> 属性的值为 <codeph>1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1</codeph>。恒等矩阵的位置或平移值为 <codeph>Vector3D(0,0,0)</codeph>，旋转设置为 <codeph>Vector3D(0,0,0)</codeph>，缩放值为 <codeph>Vector3D(1,1,1)</codeph>。</p> 
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix3D/identity()"><linktext>identity()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiConstructor><apiOperation id="flash.geom:Matrix3D:append"><apiName>append</apiName><shortdesc>
    通过将另一个 Matrix3D 对象与当前 Matrix3D 对象相乘来后置一个矩阵。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lhs</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>一个左侧矩阵，它与当前 Matrix3D 对象相乘。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    通过将另一个 Matrix3D 对象与当前 Matrix3D 对象相乘来后置一个矩阵。得到的结果将合并两个矩阵转换。可以将一个 Matrix3D 对象与多个矩阵相乘。最终的 Matrix3D 对象将包含所有转换的结果。
    
    <p>矩阵乘法运算与矩阵加法运算不同。矩阵乘法运算是不可交换的。换句话说，A 乘以 B 并不等于 B 乘以 A。在使用 <codeph>append()</codeph> 方法时，乘法运算将从左侧开始，这意味着 <codeph>lhs</codeph> Matrix3D 对象位于乘法运算符的左侧。</p>
    
    <codeph>thisMatrix = lhs ~~ thisMatrix;</codeph>
      
    <p>首次调用 <codeph>append()</codeph> 方法时，此方法会对父级空间进行相关修改。后续调用与后置的 Matrix3D 对象的参照帧相关。</p>
    
    <p><codeph>append()</codeph> 方法会将当前矩阵替换为后置的矩阵。如果要后置两个矩阵，而不更改当前矩阵，请使用 <codeph>clone()</codeph> 方法复制当前矩阵，然后对生成的副本应用 <codeph>append()</codeph> 方法。</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prepend()"><linktext>flash.geom.Matrix3D.prepend()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendRotation"><apiName>appendRotation</apiName><shortdesc>
    在 Matrix3D 对象上后置一个增量旋转。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>degrees</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>旋转的角度。
    </apiDesc></apiParam><apiParam><apiItemName>axis</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>旋转的轴或方向。常见的轴为 <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>)、<codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) 和 <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>)。 
    </apiDesc></apiParam><apiParam><apiItemName>pivotPoint</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>用于确定对象的旋转中心的点。对象的默认轴点为该对象的注册点。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    在 Matrix3D 对象上后置一个增量旋转。在将 Matrix3D 对象应用于显示对象时，矩阵会在 Matrix3D 对象中先执行其它转换，再执行旋转。 
    
    <p>显示对象的旋转由以下元素定义：一个轴、绕该轴旋转的增量角度和对象旋转中心的可选轴点。轴可以是任何常规方向。常见的轴为 <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>)、<codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) 和 <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>)。在航空术语中，有关 y 轴的旋转称为偏航。有关 x 轴的旋转称为俯仰。有关 z 轴的旋转称为翻滚。</p> 
    
    <p>转换的顺序很重要。先旋转再平移的转换所产生的效果与先平移再旋转的转换所产生的效果不同。</p>
    
    <p>旋转效果不是绝对效果。它与当前位置和方向相关。要确保对转换矩阵进行绝对更改，请使用 <codeph>recompose()</codeph> 方法。<codeph>appendRotation()</codeph> 方法也与显示对象的轴旋转属性（例如 <codeph>rotationX</codeph> 属性）不同。旋转属性始终先于任何平移执行，而 <codeph>appendRotation()</codeph> 方法相对于矩阵中已存在的内容执行。要确保获得与显示对象的轴旋转属性类似的效果，请使用 <codeph>prependRotation()</codeph> 方法，该方法会在矩阵中先执行旋转，然后再执行其它转换。</p>
    
    <p>在将 <codeph>appendRotation()</codeph> 方法的转换应用于显示对象的 Matrix3D 对象时，缓存的显示对象旋转属性值无效。</p> 
    
    <p>一种用于让一个显示对象绕相对于其位置的特定点旋转的方法是：将该对象平移设置为指定的点，使用 <codeph>appendRotation()</codeph> 方法旋转该对象，然后将该对象向后平移到原始位置。在下面的示例中，<codeph>myObject</codeph> 3D 显示对象将围绕坐标 (10,10,0) 进行 y 轴旋转。</p>
    
    <codeblock rev="3.0">
    
    myObject.z = 1; 
    myObject.transform.matrix3D.appendTranslation(10,10,0);
    myObject.transform.matrix3D.appendRotation(1, Vector3D.Y_AXIS);
    myObject.transform.matrix3D.appendTranslation(-10,-10,0);
     
    </codeblock>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependRotation()"><linktext>prependRotation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendScale"><apiName>appendScale</apiName><shortdesc>
    在 Matrix3D 对象上后置一个增量缩放，沿 x、y 和 z 轴改变位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>xScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>用于沿 x 轴缩放对象的乘数。
    </apiDesc></apiParam><apiParam><apiItemName>yScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>用于沿 y 轴缩放对象的乘数。
    </apiDesc></apiParam><apiParam><apiItemName>zScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>用于沿 z 轴缩放对象的乘数。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    在 Matrix3D 对象上后置一个增量缩放，沿 x、y 和 z 轴改变位置。在将 Matrix3D 对象应用于显示对象时，矩阵会在 Matrix3D 对象中先执行其它转换，然后再执行缩放更改。默认的缩放系数为 (1.0, 1.0, 1.0)。
    
    <p>缩放将作为沿三个轴（x、y、z）进行的三个增量更改集进行定义。可以将每个轴与不同的数字相乘。在将缩放更改应用于显示对象时，该对象的大小会增大或减小。例如，将 x、y 和 z 轴设置为 2 将使对象大小为原来的两倍，而将轴设置为 <codeph>0.5</codeph> 将使对象的大小为原来的一半。要确保缩放转换只影响特定的轴，请将其它参数设置为 1。参数为 1 表示不沿特定的轴进行任何缩放更改。</p>
    
    <p><codeph>appendScale()</codeph> 方法可用于调整大小和管理扭曲（例如显示对象的拉伸或收缩），或用于某个位置上的放大和缩小。在显示对象的旋转和平移过程中，将自动执行缩放转换。</p>
    
    <p>转换的顺序很重要。先调整大小再平移的转换所产生的效果与先平移再调整大小的转换所产生的效果不同。</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependScale()"><linktext>prependScale()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:appendTranslation"><apiName>appendTranslation</apiName><shortdesc>
    在 Matrix3D 对象上后置一个增量平移，沿 x、y 和 z 轴重新定位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>沿 x 轴的增量平移。
    </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>沿 y 轴的增量平移。
    </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>沿 z 轴的增量平移。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    在 Matrix3D 对象上后置一个增量平移，沿 x、y 和 z 轴重新定位。在将 Matrix3D 对象应用于显示对象时，矩阵会在 Matrix3D 对象中先执行其它转换，然后再执行平移更改。
    
    <p>平移将作为沿三个轴（x、y、z）进行的三个增量更改集进行定义。在对显示对象应用转换时，显示对象会从当前位置沿 x、y 和 z 轴按参数指定的增量移动。要确保平移只影响特定的轴，请将其它参数设置为零。参数为零表示不沿特定的轴进行任何更改。</p> 
    
    <p>平移更改不是绝对更改。它们与矩阵的当前位置和方向相关。要确保对转换矩阵进行绝对更改，请使用 <codeph>recompose()</codeph> 方法。转换的顺序也很重要。先平移再旋转的转换所产生的效果与先旋转再平移所产生的效果不同。</p>
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/prependTranslation()"><linktext>prependTranslation()</linktext></link><link href="flash.geom.xml#Matrix3D/position"><linktext>position</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:clone"><apiName>clone</apiName><shortdesc>
    返回一个新 Matrix3D 对象，它是与当前 Matrix3D 对象完全相同的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个新 Matrix3D 对象，它是与当前 Matrix3D 对象完全相同的副本。
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    返回一个新 Matrix3D 对象，它是与当前 Matrix3D 对象完全相同的副本。      
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix3D:decompose"><apiName>decompose</apiName><shortdesc>
    将转换矩阵的平移、旋转和缩放设置作为由三个 Vector3D 对象组成的矢量返回。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个由三个 Vector3D 对象组成的矢量，其中，每个对象分别容纳平移、旋转和缩放设置。 
    
    </apiDesc><apiType value="Vector$flash.geom:Vector3D"/></apiReturn><apiParam><apiItemName>orientationStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>eulerAngles</apiData><apiDesc>一个可选参数，它确定用于矩阵转换的方向样式。三种类型的方向样式分别为：<codeph>eulerAngles</codeph>（常量 <codeph>EULER_ANGLES</codeph>）、<codeph>axisAngle</codeph>（常量 <codeph>AXIS_ANGLE</codeph>）和 <codeph>quaternion</codeph>（常量 <codeph>QUATERNION</codeph>）。有关其它方向样式的附加信息，请参阅 <codeph>geom.Orientation3D</codeph> 类。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    将转换矩阵的平移、旋转和缩放设置作为由三个 Vector3D 对象组成的矢量返回。第一个 Vector3D 对象容纳平移元素。第二个 Vector3D 对象容纳旋转元素。第三个 Vector3D 对象容纳缩放元素。 
    
    <p>一些 Matrix3D 方法（例如 <codeph>interpolateTo()</codeph> 方法）会自动分解和重新组成矩阵以执行其转换。</p> 
       
    <p>要使用绝对父级参照帧来修改矩阵转换，请使用 <codeph>decompose()</codeph> 方法检索设置，然后做出适当的更改。然后，可以使用 <codeph>recompose()</codeph> 方法将 Matrix3D 对象设置为修改后的转换。</p>
    
    <p><codeph>decompose()</codeph> 方法的参数指定要用于转换的方向样式。默认方向为 <codeph>eulerAngles</codeph>，它通过三个不同的对应于每个轴的旋转角来定义方向。这些旋转是连续发生的，并且相互不更改轴。显示对象的轴旋转属性执行欧拉角方向样式转换。另外两个方向样式选项分别为 <codeph>axisAngle</codeph> 和 <codeph>quaternion</codeph>。轴角方向结合使用轴和角度来确定方向。对象绕其旋转的轴是一个单位矢量，它表示一个方向。角表示有关矢量的旋转幅度。方向还确定显示对象面对的方向，而角确定哪个方向是向上。<codeph>appendRotation()</codeph> 和 <codeph>prependRotation()</codeph> 方法使用轴角方向。四元数方向使用复数和矢量的第四个元素。方向由三个旋转轴（x、y、z）和一个旋转角 (w) 表示。<codeph>interpolate()</codeph> 方法使用四元数。</p> 
    
    </apiDesc><example conref="examples\Matrix3DdecomposeExample.as"> 在本示例中，通过使用 <codeph>decompose()</codeph> 和 <codeph>recompose()</codeph> 方法，在椭圆朝消失点移动时水平拉伸椭圆。<codeph>decompose()</codeph> 方法返回的第一个 Vector3D 对象容纳平移坐标。第三个 Vector3D 对象容纳缩放设置。Vector3D 对象的 <codeph>incrementBy()</codeph> 方法递增矩阵的绝对平移和缩放设置。
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.events.Event;
    
    public class Matrix3DdecomposeExample extends MovieClip {
        private var ellipse:Shape = new Shape();

        public function Matrix3DdecomposeExample():void {
            
            ellipse.x = (this.stage.stageWidth / 2);
            ellipse.y = (this.stage.stageHeight - 40);
            ellipse.z = 1;
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(0, 0, 50, 40);
            ellipse.graphics.endFill();
            addChild(ellipse);

            ellipse.addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }

        private function enterFrameHandler(e:Event):void {  

            var v3:Vector.&lt;Vector3D> = new Vector.&lt;Vector3D>(3);
            v3 = ellipse.transform.matrix3D.decompose();
            v3[0].incrementBy(new Vector3D(0,0,1));
            v3[2].incrementBy(new Vector3D(0.01,0,0));
            ellipse.transform.matrix3D.recompose(v3);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>recompose()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:deltaTransformVector"><apiName>deltaTransformVector</apiName><shortdesc>
    使用不含平移元素的转换矩阵将 Vector3D 对象从一个空间坐标转换到另一个空间坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个包含转换后的坐标的 Vector3D 对象。
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>一个容纳要转换的坐标的 Vector3D 对象。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    使用不含平移元素的转换矩阵将 Vector3D 对象从一个空间坐标转换到另一个空间坐标。返回的 Vector3D 对象将容纳应用旋转和缩放转换之后的新坐标。如果 <codeph>deltaTransformVector()</codeph> 方法应用的是仅包含平移转换的矩阵，则返回的 Vector3D 对象与原始 Vector3D 对象相同。
    
    <p>通过使用 <codeph>deltaTransformVector()</codeph> 方法，可以让一个坐标空间中的显示对象对第二个显示对象的旋转转换做出响应。该对象不复制旋转；它只是更改其位置以反映旋转中的更改。例如，为了使用 <codeph>display.Graphics</codeph> API 绘制一个旋转的 3D 显示对象，则必须将该对象的旋转坐标映射到一个 2D 点。首先，在每次旋转后使用 <codeph>deltaTransformVector()</codeph> 方法检索对象的 3D 坐标。然后，应用显示对象的 <codeph>local3DToGlobal()</codeph> 方法，以将 3D 坐标平移到 2D 点。然后，可以使用 2D 点来绘制旋转的 3D 对象。</p> 
    
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVectors()"><linktext>transformVectors()</linktext></link><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>transformVector()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:identity"><apiName>identity</apiName><shortdesc>
    将当前矩阵转换为恒等或单位矩阵。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    将当前矩阵转换为恒等或单位矩阵。恒等矩阵中的主对角线位置上的元素的值为一，而所有其它元素的值为零。生成的结果是一个矩阵，其中，<codeph>rawData</codeph> 值为 <codeph>1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1</codeph>，旋转设置为 <codeph>Vector3D(0,0,0)</codeph>，位置或平移设置为 <codeph>Vector3D(0,0,0)</codeph>，缩放设置为 <codeph>Vector3D(1,1,1)</codeph>。以下是恒等矩阵的表示形式。
    
    <p><adobeimage alt="恒等矩阵" href="../../images/identityMatrix.jpg"/></p>
    
    <p>通过应用恒等矩阵转换的对象不执行任何转换。换句话说，如果一个矩阵与一个恒等矩阵相乘，则会生成一个与原始矩阵相同（恒等）的矩阵。</p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix3D:interpolate"><apiName>interpolate</apiName><shortdesc>
    通过将一个显示对象插补到靠近目标显示对象的一个百分比位置，简化在两个参照帧之间插值的过程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>一个 Matrix3D 对象，其中包含用于放置原始矩阵和目标矩阵之间的矩阵值的元素。在将返回的矩阵应用于 <codeph>this</codeph> 显示对象时，该对象会朝着目标对象移动到指定的百分比位置。
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>thisMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>要插补的 Matrix3D 对象。
    </apiDesc></apiParam><apiParam><apiItemName>toMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>目标 Matrix3D 对象。
    </apiDesc></apiParam><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个介于 <codeph>0</codeph> 和 <codeph>1</codeph> 之间的值，它确定朝目标 Matrix3D 对象插补 <codeph>thisMat</codeph> Matrix3D 对象的位置百分比。
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>将显示对象插补到靠近目标显示对象的一个百分比位置。
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    通过将一个显示对象插补到靠近目标显示对象的一个百分比位置，简化在两个参照帧之间插值的过程。生成的结果是一个新 Matrix3D 对象，其中，用于平移、旋转和缩放的所有元素都插补到当前显示对象和目标显示对象之间的值。
    
    <p><codeph>interpolate()</codeph> 方法可避免在使用方法（例如显示对象的轴旋转属性）时出现一些不需要的结果。<codeph>interpolate()</codeph> 方法可使缓存的显示对象旋转属性值无效，并在插补前将显示对象矩阵的方向元素转换为四元数。此方法可以确保旋转的路径最短且最有效。它还生成平滑的、无万向节锁定的旋转。当使用欧拉角时（此时将单独处理每个轴）会出现万向节锁定。在绕两个或更多轴旋转的过程中，这些轴可能会对齐，从而导致意外结果。四元数旋转可避免万向节锁定。</p> 
    
    <p>对 <codeph>interpolate()</codeph> 方法的连续调用会产生这样的效果：显示对象迅速启动，然后缓慢接近另一个显示对象。例如，如果将 <codeph>thisMat</codeph> 参数设置为返回的 Matrix3D 对象，将 <codeph>toMat</codeph> 参数设置为目标显示对象关联的 Matrix3D 对象，并将 <codeph>percent</codeph> 参数设置为 <codeph>0.1</codeph>，则显示对象会朝目标对象移动百分之十。对于后续调用或在后续的帧中，对象会移动剩余的 90% 的百分之十，然后移动剩余的 80% 的百分之十，直到对象到达目标。</p>  
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/interpolateTo()"><linktext>interpolateTo()</linktext></link><link href="flash.geom.xml#Utils3D/pointTowards()"><linktext>flash.geom.Utils3D.pointTowards()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:interpolateTo"><apiName>interpolateTo</apiName><shortdesc>
    将显示对象的矩阵插补到靠近目标矩阵的一个百分比位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>toMat</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>目标 Matrix3D 对象。  
    </apiDesc></apiParam><apiParam><apiItemName>percent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个介于 <codeph>0</codeph> 和 <codeph>1</codeph> 之间的值，它确定显示对象相对于目标的位置。该值越接近于 <codeph>1.0</codeph>，显示对象就越靠近其当前位置。该值越接近于 <codeph>0</codeph>，显示对象就越靠近其目标。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    将显示对象的矩阵插补到靠近目标矩阵的一个百分比位置。用于显示对象的平移、旋转和缩放的所有元素都插补到当前显示对象矩阵和目标显示对象矩阵之间的值。 
    
    <p><codeph>interpolateTo()</codeph> 方法可避免在使用方法（例如显示对象的轴旋转属性）时出现不需要的结果。<codeph>interpolateTo()</codeph> 方法可使缓存的显示对象旋转属性值无效，并在插补前将显示对象矩阵的方向元素转换为四元数。此方法可以确保旋转的路径最短且最有效。它还生成平滑的、无万向节锁定的旋转。当使用欧拉角时（此时将单独处理每个轴）会出现万向节锁定。在绕两个或更多轴旋转的过程中，这些轴可能会对齐，从而导致意外结果。四元数旋转可避免万向节锁定。</p> 
    
    <p>对 <codeph>interpolateTo()</codeph> 方法的连续调用会产生这样的效果：显示对象迅速启动，然后缓慢接近另一个显示对象。例如，如果 percent 参数设置为 <codeph>0.1</codeph>，则显示对象会朝 <codeph>toMat</codeph> 参数指定的目标对象移动百分之十。对于后续调用或在后续的帧中，对象会移动剩余的 90% 的百分之十，然后移动剩余的 80% 的百分之十，直到对象到达目标。</p>  
    
    </apiDesc><example conref="examples\InterpolateToExample.as"> 在本示例中，一个三维显示对象 <codeph>ellipse2</codeph> 朝另一个三维显示对象 <codeph>ellipse1</codeph> 逼近。<codeph>ellipse2</codeph> 环绕在 <codeph>ellipse1</codeph> 的周围，试图接近它。如果 <codeph>ellipse1</codeph> 未绕其 y 轴旋转，则 <codeph>ellipse2</codeph> 将到达并落在 <codeph>ellipse1</codeph> 的上方。这两个椭圆的绘制方式相同，但放置在不同的三维现实世界空间位置。 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.geom.*;
    import flash.events.Event;

    public class InterpolateToExample extends MovieClip {
        private var ellipse1:Shape = new Shape();
        private var ellipse2:Shape = new Shape();

        public function InterpolateToExample():void {

            ellipse1 = myEllipses(250, 100, 500, 0xFF0000);
            addChild(ellipse1);
            
            ellipse2 = myEllipses(-30, 120, 1, 0x00FF00);
            addChild(ellipse2);

            addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }

        private function myEllipses(x:Number, y:Number, z:Number, c:Number):Shape {
            var s:Shape = new Shape();                            
            s.x = x;
            s.y = y;
            s.z = z;
            s.graphics.beginFill(c);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(100, 50, 100, 80);
            s.graphics.endFill();
            return s;
        }

        private function enterFrameHandler(e:Event) {
            ellipse1.rotationY += 1;

            ellipse2.transform.matrix3D.interpolateTo(ellipse1.transform.matrix3D, 0.1);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/interpolate()"><linktext>interpolate()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:invert"><apiName>invert</apiName><shortdesc>
    反转当前矩阵。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果成功反转矩阵，则返回 <codeph>true</codeph>。 
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    反转当前矩阵。逆矩阵具有与原始矩阵相同的大小，但它执行的转换与原始矩阵相反。例如，如果在原始矩阵中，一个对象按某个方向绕 x 轴旋转，那么在逆矩阵中，该对象将按此方向的反方向绕 x 轴旋转。对一个对象应用逆矩阵可撤消原始矩阵执行的转换。如果将一个矩阵与其逆矩阵相乘，则将产生一个恒等矩阵。 
    
    <p>利用矩阵的逆矩阵，可以将一个矩阵除以另一个矩阵。通过将矩阵 A 与矩阵 B 的逆矩阵相乘，可以将矩阵 A 除以矩阵 B。逆矩阵还可以用于摄像头空间。当摄像头在现实世界空间中移动时，现实世界中的对象需按与摄像头相反的方向移动，这样才能从现实世界视点转换到摄像头或视点空间。例如，如果摄像头移动得越近，则对象变得越大。换句话说，如果摄像头沿现实世界的 z 轴下移，则对象会沿此 z 轴上移。</p> 
    
    <p><codeph>invert()</codeph> 方法会将当前矩阵替换为逆矩阵。如果要反转矩阵，而不更改当前矩阵，请先使用 <codeph>clone()</codeph> 方法复制当前矩阵，然后对生成的副本应用 <codeph>invert()</codeph> 方法。</p>
    
    <p>Matrix3D 对象必须是可逆的。</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/determinant"><linktext>determinant</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:pointAt"><apiName>pointAt</apiName><shortdesc>
    旋转显示对象以使其朝向指定的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>pos</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>目标对象的相对于现实世界的位置。相对于现实世界定义了相对于所有对象所在的现实世界空间和坐标的对象转换。
    
    </apiDesc></apiParam><apiParam><apiItemName>at</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>用于定义显示对象所指向的位置的相对于对象的矢量。相对于对象定义了相对于对象空间（即对象自己的参照帧和坐标系统）的对象转换。默认值为 <i>-z</i> 轴 (0,0,-1)。
    
    </apiDesc></apiParam><apiParam><apiItemName>up</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>用于为显示对象定义“向上”方向的相对于对象的矢量。如果从上至下绘制对象，则 <i>+z</i> 轴为该对象的“up”矢量。相对于对象定义了相对于对象空间（即对象自己的参照帧和坐标系统）的对象转换。默认值为 <i>-y</i> 轴 (0,-1,0)。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    旋转显示对象以使其朝向指定的位置。此方法允许对方向进行就地修改。显示对象（即 <codeph>at</codeph> Vector3D 对象）的向前方向矢量指向指定的现实世界相关位置。显示对象的向上方向是用 <codeph>up</codeph> Vector3D 对象指定的。 
    
    <p><codeph>pointAt()</codeph> 方法可使缓存的显示对象旋转属性值无效。此方法可分解显示对象的矩阵并修改旋转元素，从而让对象转向指定位置。然后，此方法将重新组成（更新）显示对象的矩阵，这将执行转换。如果该对象指向正在移动的目标（例如正在移动的对象位置），则对于每个后续调用，此方法都会让对象朝正在移动的目标旋转。</p>
    
    </apiDesc><example conref="examples\PointAtExample.as"> 本示例中，一个三角形指向并沿循椭圆的运动路径移动。椭圆和三角形设置为不同的位置。然后，椭圆朝舞台角部上移。三角形沿循椭圆的平移更改。可以更改三角形的形状和 <codeph>pointAt()</codeph> 的“at”和“up”参数，以查看它们对三角形移动的影响。
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.geom.*;
    import flash.events.Event;

    public class PointAtExample extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var triangle:Shape = new Shape();

        public function PointAtExample():void {
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(30, 40, 50, 40);
            ellipse.graphics.endFill();
            ellipse.x = 100;
            ellipse.y = 150;
            ellipse.z = 1;

            triangle.graphics.beginFill(0x0000FF);
            triangle.graphics.moveTo(0, 0);
            triangle.graphics.lineTo(40, 40);
            triangle.graphics.lineTo(80, 0);
            triangle.graphics.lineTo(0, 0);
            triangle.graphics.endFill();
            triangle.x = 200;
            triangle.y = 50;
            triangle.z = 1;

            addChild(ellipse);
            addChild(triangle);

            ellipse.addEventListener(Event.ENTER_FRAME, ellipseEnterFrameHandler);
            triangle.addEventListener(Event.ENTER_FRAME, triangleEnterFrameHandler);
        }

        private function ellipseEnterFrameHandler(e:Event) {
            if(e.target.y > 0) {
                e.target.y -= 1;
                e.target.x -= 1;
            }
        }
        
        private function triangleEnterFrameHandler(e:Event) {
            e.target.transform.matrix3D.pointAt(ellipse.transform.matrix3D.position,
                                                Vector3D.X_AXIS, Vector3D.Y_AXIS);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Utils3D/pointTowards()"><linktext>flash.geom.Utils3D.pointTowards()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prepend"><apiName>prepend</apiName><shortdesc>
    通过将当前 Matrix3D 对象与另一个 Matrix3D 对象相乘来前置一个矩阵。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rhs</apiItemName><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier><apiDesc>一个右侧矩阵，它与当前 Matrix3D 对象相乘。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    通过将当前 Matrix3D 对象与另一个 Matrix3D 对象相乘来前置一个矩阵。得到的结果将合并两个矩阵转换。 
    
    <p>矩阵乘法运算与矩阵加法运算不同。矩阵乘法运算是不可交换的。换句话说，A 乘以 B 并不等于 B 乘以 A。在使用 <codeph>prepend()</codeph> 方法时，乘法运算将从右侧开始，这意味着 <codeph>rhs</codeph> Matrix3D 对象位于乘法运算符的右侧。</p>
    
    <codeph>thisMatrix = thisMatrix ~~ rhs</codeph>
      
    <p><codeph>prepend()</codeph> 方法所做的修改与对象空间相关。换句话说，这些修改始终与对象的初始参照帧相关。</p>
    
    <p><codeph>prepend()</codeph> 方法会将当前矩阵替换为前置的矩阵。如果要前置两个矩阵，而不更改当前矩阵，请先使用 <codeph>clone()</codeph> 方法复制当前矩阵，然后对生成的副本应用 <codeph>prepend()</codeph> 方法。</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/append()"><linktext>append()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependRotation"><apiName>prependRotation</apiName><shortdesc>
    在 Matrix3D 对象上前置一个增量旋转。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>degrees</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>旋转的角度。
    </apiDesc></apiParam><apiParam><apiItemName>axis</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>旋转的轴或方向。常见的轴为 <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>)、<codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) 和 <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>)。 
    </apiDesc></apiParam><apiParam><apiItemName>pivotPoint</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiData>null</apiData><apiDesc>一个用于确定旋转中心的点。对象的默认轴点为该对象的注册点。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    在 Matrix3D 对象上前置一个增量旋转。在将 Matrix3D 对象应用于显示对象时，矩阵会在 Matrix3D 对象中先执行旋转，然后再执行其它转换。 
    
    <p>显示对象的旋转由以下元素定义：一个轴、绕该轴旋转的增量角度和对象旋转中心的可选轴点。轴可以是任何常规方向。常见的轴为 <codeph>X_AXIS</codeph> (<codeph>Vector3D(1,0,0)</codeph>)、<codeph>Y_AXIS</codeph> (<codeph>Vector3D(0,1,0)</codeph>) 和 <codeph>Z_AXIS</codeph> (<codeph>Vector3D(0,0,1)</codeph>)。在航空术语中，有关 y 轴的旋转称为偏航。有关 x 轴的旋转称为俯仰。有关 z 轴的旋转称为翻滚。</p> 
    
    <p>转换的顺序很重要。先旋转再平移的转换所产生的效果与先平移再旋转所产生的效果不同。</p>
    
    <p>旋转效果不是绝对效果。此效果与对象有关，它与原始位置和方向的参照帧相对。要确保对转换进行绝对更改，请使用 <codeph>recompose()</codeph> 方法。</p>
    
    <p>在将 <codeph>prependRotation()</codeph> 方法的转换应用于显示对象的 Matrix3D 对象时，缓存的显示对象旋转属性值无效。</p> 
    
    <p>一种使一个显示对象围绕某个相对于其位置的特定点进行旋转的方法是：将该对象平移到指定的点，使用 <codeph>prependRotation()</codeph> 方法旋转该对象，然后将该对象平移回原始位置。在下面的示例中，<codeph>myObject</codeph> 3D 显示对象将围绕坐标 (10,10,0) 进行 y 轴旋转。</p>
    
    <codeblock rev="3.0">
    
    myObject.z = 1; 
    myObject.transform.matrix3D.prependTranslation(10,10,0);
    myObject.transform.matrix3D.prependRotation(1, Vector3D.Y_AXIS);
    myObject.transform.matrix3D.prependTranslation(-10,-10,0);
     
    </codeblock>
    
    </apiDesc><example conref="examples\Matrix3DprependRotationExample.as"> 在本示例中，用户可以通过移动鼠标将椭圆绕其 <i>x</i> 轴和 <i>y</i> 轴旋转。该椭圆是通过将其注册点设置为椭圆的中心而绘制的。椭圆使用鼠标的 <i>x</i> 坐标绕其 <i>y</i> 轴旋转；并使用鼠标的 <i>y</i> 坐标绕其 <i>x</i> 轴旋转。
 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.events.MouseEvent;
    
    public class Matrix3DprependRotationExample extends MovieClip {
        private var ellipse:Shape = new Shape();

        public function Matrix3DprependRotationExample():void {

            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(-50, -40, 100, 80);
            ellipse.graphics.endFill();

            ellipse.x = (this.stage.stageWidth / 2);
            ellipse.y = (this.stage.stageHeight / 2);
            ellipse.z = 1;
            
            addChild(ellipse);

            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        }

        private function mouseMoveHandler(e:MouseEvent):void {
            var y:int;
            var x:int;
            
            if(e.localX > ellipse.x) {
                y = (Math.round(e.localX) / 100);   
            } else {
                y = -(Math.round(e.localX) / 10);   
            }
            
            if(e.localY > ellipse.y) {
                x = (Math.round(e.localY) / 100);
            } else {
                x = -(Math.round(e.localY) / 100);
            }
            
            ellipse.transform.matrix3D.prependRotation(y, Vector3D.Y_AXIS);
            ellipse.transform.matrix3D.prependRotation(x, Vector3D.X_AXIS);
        }
        
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendRotation()"><linktext>appendRotation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependScale"><apiName>prependScale</apiName><shortdesc>
    在 Matrix3D 对象上前置一个增量缩放，沿 x、y 和 z 轴改变位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>xScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>用于沿 x 轴缩放对象的乘数。
    </apiDesc></apiParam><apiParam><apiItemName>yScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>用于沿 y 轴缩放对象的乘数。
    </apiDesc></apiParam><apiParam><apiItemName>zScale</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>用于沿 z 轴缩放对象的乘数。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    在 Matrix3D 对象上前置一个增量缩放，沿 x、y 和 z 轴改变位置。在将 Matrix3D 对象应用于显示对象时，矩阵会在 Matrix3D 对象中先执行缩放更改，然后再执行其它转换。这些更改与对象有关，它与原始位置和方向的参照帧相对。默认的缩放系数为 (1.0, 1.0, 1.0)。
    
    <p>缩放将作为沿三个轴（x、y、z）进行的三个增量更改集进行定义。可以将每个轴与不同的数字相乘。在将缩放更改应用于显示对象时，该对象的大小会增大或减小。例如，将 x、y 和 z 轴设置为 2 将使对象大小为原来的两倍，而将轴设置为 <codeph>0.5</codeph> 将使对象的大小为原来的一半。要确保缩放转换只影响特定的轴，请将其它参数设置为 1。参数为 1 表示不沿特定的轴进行任何缩放更改。</p>
    
    <p><codeph>prependScale()</codeph> 方法可用于调整大小和管理扭曲（例如显示对象的拉伸或收缩），还可用于某个位置上的放大和缩小。在显示对象的旋转和平移过程中，将自动执行缩放转换。</p>
    
    <p>转换的顺序很重要。先调整大小再平移的转换所产生的效果与先平移再调整大小的转换所产生的效果不同。</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendScale()"><linktext>appendScale()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:prependTranslation"><apiName>prependTranslation</apiName><shortdesc>
    在 Matrix3D 对象上前置一个增量平移，沿 x、y 和 z 轴重新定位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>沿 x 轴的增量平移。
    </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>沿 y 轴的增量平移。
    </apiDesc></apiParam><apiParam><apiItemName>z</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>沿 z 轴的增量平移。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    在 Matrix3D 对象上前置一个增量平移，沿 x、y 和 z 轴重新定位。在将 Matrix3D 对象应用于显示对象时，矩阵会在 Matrix3D 对象中先执行平移更改，然后再执行其它转换。 
       
    <p>平移指定显示对象从其当前位置沿 x、y 和 z 轴移动的距离。<codeph>prependTranslation()</codeph> 方法将平移设置为沿三个轴（x、y、z）进行的三个增量更改集。要让平移只影响特定的轴，请将其它参数设置为零。参数为零表示不沿特定的轴进行任何更改。</p>
    
    <p>平移更改不是绝对更改。此效果与对象有关，它与原始位置和方向的参照帧相对。要确保对转换矩阵进行绝对更改，请使用 <codeph>recompose()</codeph> 方法。转换的顺序也很重要。先平移再旋转的转换所产生的效果与先旋转再平移的转换所产生的效果不同。当使用 <codeph>prependTranslation()</codeph> 时，显示对象将继续按照其面对的方向移动，这与其它转换无关。例如，如果显示对象面向的是正向 x 轴，则该对象将继续按照 <codeph>prependTranslation()</codeph> 方法指定的方向移动，这与对象旋转的方式无关。要让平移更改在其它转换之后发生，请使用 <codeph>appendTranslation()</codeph> 方法。</p> 
    
    
    </apiDesc><example conref="examples\Matrix3DprependTranslationExample.as"> 在本示例中，用户可以使用鼠标将椭圆沿舞台的 <i>y</i> 轴向上推。当用户将鼠标移动到椭圆上方时，椭圆将沿 <i>y</i> 轴向上跳过十个坐标。当鼠标远离椭圆时，如果椭圆尚未到达顶部，则它会再次沿 <i>y</i> 轴向上跳过十个坐标。椭圆到达顶部后，将会移回动到舞台的底部。
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.geom.*;
    import flash.events.MouseEvent;

    public class Matrix3DprependTranslationExample extends MovieClip {
        private var ellipse:Sprite = new Sprite();

        public function Matrix3DprependTranslationExample():void {
            ellipse.x = this.stage.stageWidth / 2;
            ellipse.y = this.stage.stageHeight - 100;
            ellipse.z = 1;
            ellipse.graphics.beginFill(0xFF0000);
            ellipse.graphics.lineStyle(2);
            ellipse.graphics.drawEllipse(0, 0, 60, 50);
            ellipse.graphics.endFill();
            addChild(ellipse);

            ellipse.addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
            ellipse.addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        }

        private function mouseOverHandler(e:MouseEvent):void {
            if(ellipse.y > 0) { 
                ellipse.transform.matrix3D.prependTranslation(0, -10, 0);
            } 
        }
        
        private function mouseOutHandler(e:MouseEvent):void {
            if(ellipse.y > 0) { 
                ellipse.transform.matrix3D.prependTranslation(0, -10, 0);
            } else {
                ellipse.transform.matrix3D.prependTranslation(0, 
                                     (this.stage.stageHeight - 100), 0);
            }   
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/appendTranslation()"><linktext>appendTranslation()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:recompose"><apiName>recompose</apiName><shortdesc>
    设置转换矩阵的平移、旋转和缩放设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果任一缩放元素为零，则返回 <codeph>false</codeph>。
    
    </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>components</apiItemName><apiType value="Vector$flash.geom:Vector3D"/><apiDesc>一个由三个 Vector3D 对象组成的矢量，这些对象将替代 Matrix3D 对象的平移、旋转和缩放元素。 
    
    </apiDesc></apiParam><apiParam><apiItemName>orientationStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>eulerAngles</apiData><apiDesc>一个可选参数，它确定用于矩阵转换的方向样式。三种类型的方向样式分别为：<codeph>eulerAngles</codeph>（常量 <codeph>EULER_ANGLES</codeph>）、<codeph>axisAngle</codeph>（常量 <codeph>AXIS_ANGLE</codeph>）和 <codeph>quaternion</codeph>（常量 <codeph>QUATERNION</codeph>）。有关其它方向样式的附加信息，请参阅 <codeph>geom.Orientation3D</codeph> 类。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    设置转换矩阵的平移、旋转和缩放设置。与显示对象的旋转属性或 Matrix3D 对象的旋转方法所做的增量更改不同，<codeph>recompose()</codeph> 方法所做的更改是绝对更改。<codeph>recompose()</codeph> 方法将覆盖矩阵转换。
    
    <p>要使用绝对父级参照帧来修改矩阵转换，请使用 <codeph>decompose()</codeph> 方法检索设置，然后做出适当的更改。然后，可以使用 <codeph>recompose()</codeph> 方法将 Matrix3D 对象设置为修改后的转换。</p>
    
    <p><codeph>recompose()</codeph> 方法的参数指定用于转换的方向样式。默认方向为 <codeph>eulerAngles</codeph>，它通过三个不同的对应于每个轴的旋转角来定义方向。这些旋转是连续发生的，并且相互不更改轴。显示对象的轴旋转属性执行欧拉角方向样式转换。另外两个方向样式选项分别为 <codeph>axisAngle</codeph> 和 <codeph>quaternion</codeph>。轴角方向结合使用轴和角度来确定方向。对象绕其旋转的轴是一个单位矢量，它表示一个方向。角表示有关矢量的旋转幅度。方向还确定显示对象面对的方向，而角确定哪个方向是向上。<codeph>appendRotation()</codeph> 和 <codeph>prependRotation()</codeph> 方法使用轴角方向。四元数方向使用复数和矢量的第四个元素。方向由三个旋转轴（x、y、z）和一个旋转角 (w) 表示。<codeph>interpolate()</codeph> 方法使用四元数。</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Orientation3D"><linktext>flash.geom.Orientation3D</linktext></link><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>decompose()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transformVector"><apiName>transformVector</apiName><shortdesc>
    使用转换矩阵将 Vector3D 对象从一个空间坐标转换到另一个空间坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个包含转换后的坐标的 Vector3D 对象。
    
    </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>一个容纳要转换的坐标的 Vector3D 对象。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    使用转换矩阵将 Vector3D 对象从一个空间坐标转换到另一个空间坐标。返回的 Vector3D 对象将容纳转换后的新坐标。将对 Vector3D 对象中应用所有矩阵转换（包括平移）。
    
    <p>如果已将 <codeph>transformVector()</codeph> 方法的结果应用于显示对象的位置，则仅显示对象的位置会发生更改。显示对象的旋转和缩放元素保持不变。</p> 
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVectors()"><linktext>transformVectors()</linktext></link><link href="flash.geom.xml#Matrix3D/deltaTransformVector()"><linktext>deltaTransformVector()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transformVectors"><apiName>transformVectors</apiName><shortdesc>
    使用转换矩阵将由数字构成的矢量从一个空间坐标转换到另一个空间坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vin</apiItemName><apiType value="Vector$Number"/><apiDesc>一个由多个数字组成的矢量，其中每三个数字构成一个要转换的 3D 坐标 (x,y,z)。
    </apiDesc></apiParam><apiParam><apiItemName>vout</apiItemName><apiType value="Vector$Number"/><apiDesc>一个由多个数字组成的矢量，其中每三个数字构成一个已转换的 3D 坐标 (x,y,z)。
    
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    使用转换矩阵将由数字构成的矢量从一个空间坐标转换到另一个空间坐标。<codeph>tranformVectors()</codeph> 方法将读取 <codeph>vin</codeph> Vector 对象中的每三个数字作为一个 3D 坐标 (x,y,z)，并将转换后的 3D 坐标放置到 <codeph>vout</codeph> Vector 对象中。所有矩阵转换（包括平移）将应用于 <codeph>vin</codeph> Vector 对象。可以使用 <codeph>transformVectors()</codeph> 方法将 3D 对象作为网格进行呈现和转换。网格是一个顶点集合，这些顶点定义了对象的形状。
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D/transformVector()"><linktext>transformVector()</linktext></link><link href="flash.geom.xml#Matrix3D/deltaTransformVector()"><linktext>deltaTransformVector()</linktext></link><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix3D:transpose"><apiName>transpose</apiName><shortdesc>
    将当前 Matrix3D 对象转换为一个矩阵，并将互换其中的行和列。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    将当前 Matrix3D 对象转换为一个矩阵，并将互换其中的行和列。例如，如果当前 Matrix3D 对象的 <codeph>rawData</codeph> 包含以下 16 个数字：<codeph>1,2,3,4,11,12,13,14,21,22,23,24,31,32,33,34</codeph>，则 <codeph>transpose()</codeph> 方法会将每四个元素作为一个行读取并将这些行转换为列。生成的结果是一个矩阵，其 <codeph>rawData</codeph> 为：<codeph>1,11,21,31,2,12,22,32,3,13,23,33,4,14,24,34</codeph>。 
    
    <p><codeph>transpose()</codeph> 方法会将当前矩阵替换为转置矩阵。如果要转置矩阵，而不更改当前矩阵，请先使用 <codeph>clone()</codeph> 方法复制当前矩阵，然后对生成的副本应用 <codeph>transpose()</codeph> 方法。</p>
    
    <p>正交矩阵是一个正方形矩阵，该矩阵的转置矩阵和逆矩阵相同。</p> 
    
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Matrix3D:determinant:get"><apiName>determinant</apiName><shortdesc>
    一个用于确定矩阵是否可逆的数字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
    一个用于确定矩阵是否可逆的数字。 
    
    <p>Matrix3D 对象必须是可逆的。可以使用 <codeph>determinant</codeph> 属性确保 Matrix3D 对象是可逆的。如果行列式为零，则矩阵没有逆矩阵。例如，如果矩阵的整个行或列为零，或如果两个行或列相等，则行列式为零。行列式还可用于对一系列方程进行求解。</p> 
    
    <p>仅正方形矩阵（例如 Matrix3D 类）具有行列式。</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/invert()"><linktext>invert()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Matrix3D:position:set"><apiName>position</apiName><shortdesc>
    一个保存显示对象在转换参照帧中的 3D 坐标 (x,y,z) 位置的 Vector3D 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Vector3D</apiValueClassifier></apiValueDef><apiDesc>
    一个保存显示对象在转换参照帧中的 3D 坐标 (x,y,z) 位置的 Vector3D 对象。利用 <codeph>position</codeph> 属性，可立即访问显示对象矩阵的平移矢量，而无需分解和重新组合矩阵。 
    
    <p>利用 <codeph>position</codeph> 属性，可以获取和设置转换矩阵的平移元素。</p>
    
    
    </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.geom.xml#position/appendTranslation()"><linktext>appendTranslation()</linktext></link><link href="" invalidHref="flash.geom.xml#position/prependTranslation()"><linktext>prependTranslation()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Matrix3D:rawData:get"><apiName>rawData</apiName><shortdesc>
    一个由 16 个数字组成的矢量，其中，每四个元素可以是 4x4 矩阵的一行或一列。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
    一个由 16 个数字组成的矢量，其中，每四个元素可以是 4x4 矩阵的一行或一列。 
    
    <p>如果 <codeph>rawData</codeph> 属性设置为一个不可逆的矩阵，则会引发异常。Matrix3D 对象必须是可逆的。如果需要不可逆的矩阵，请创建 Matrix3D 对象的子类。</p>
    
    </apiDesc></apiValueDetail><related-links><link href="#Vector"><linktext>Vector</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:Transform"><apiName>Transform</apiName><shortdesc>
 利用 Transform 类，可以访问可应用于显示对象的颜色调整属性和二维或三维转换对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>还可以访问可应用于显示对象的颜色以及二维或三维转换对象和矩阵。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 利用 Transform 类，可以访问可应用于显示对象的颜色调整属性和二维或三维转换对象。在转换过程中，会将显示对象的颜色或方向和位置从当前值或坐标调整（偏移）到新值或坐标。Transform 类还收集有关应用于显示对象及其所有父对象的颜色和二维矩阵转换的数据。可以通过 <codeph>concatenatedColorTransform</codeph> 和 <codeph>concatenatedMatrix</codeph> 属性访问这些组合转换。
 
 <p>要应用颜色转换，请执行下列操作：创建一个 ColorTransform 对象，并使用该对象的方法和属性设置颜色调整，然后将显示对象的 <codeph>transform</codeph> 属性的 <codeph>colorTransformation</codeph> 属性分配给新的 ColorTransformation 对象。</p>
 
 <p>要应用二维转换，请执行下列操作：创建一个 Matrix 对象，并设置该矩阵的二维转换，然后将显示对象的 <codeph>transform.matrix</codeph> 属性分配给新的 Matrix 对象。</p>
 
 <p>要应用三维转换，应首先创建一个三维显示对象。三维显示对象具有一个非零的 <codeph>z</codeph> 属性值。您无需创建 Matrix3D 对象。对于所有三维对象，当您为显示对象分配 <codeph>z</codeph> 值时，将自动创建 Matrix3D 对象。可以通过显示对象的 <codeph>transform</codeph> 属性访问显示对象的 Matrix3D 对象。使用 Matrix3D 类的方法，可以添加或修改现有转换设置。还可以创建自定义 Matrix3D 对象，并设置该对象的转换元素，然后使用 <codeph>transform.matrix</codeph> 属性将新的 Matrix3D 对象分配给显示对象。</p>
 
 <p>要修改舞台或 root 对象的透视投影，请执行下列操作：使用 root 显示对象的 <codeph>transform.matrix</codeph> 属性以访问 PerspectiveProjection 对象。或者，通过设置显示对象的父级的透视投影属性，对显示对象应用不同的透视投影属性。子显示对象会继承新属性。具体而言，创建一个 PerspectiveProjection 对象并设置其属性，然后将此 PerspectiveProjection 对象分配给父显示对象的 <codeph>transform</codeph> 属性的 <codeph>perspectiveProjection</codeph> 属性。然后，指定的投影转换将应用于显示对象的所有三维子级。</p>
 
 <p>由于 PerspectiveProjection 对象和 Matrix3D 对象都会执行透视转换，因此不要将二者同时分配给显示对象。将 PerspectiveProjection 对象用于焦距和投影中心更改。要获取对透视转换的更多控制，请创建透视投影 Matrix3D 对象。</p>
 
 
 </apiDesc><example conref="examples\TransformExample.as"> 下面的示例使用 TransformExample 类来倾斜以渐变图案填充的正方形 Sprite 的底边。每次用户单击正方形时，应用程序都将通过以下步骤来倾斜正方形，从而转换 Sprite：
 
 <ol>
  <li><codeph>TransformExample()</codeph> 构造函数创建一个新的 sprite 对象 <codeph>target</codeph>。</li>
 
  <li><codeph>TransformExample()</codeph> 构造函数调用 <codeph>draw()</codeph> 方法，该方法在 sprite 中绘制一个渐变正方形。</li>
 
  <li><codeph>TransformExample()</codeph> 构造函数为 sprite 添加 click 事件侦听器，该侦听器由 <codeph>clickHandler()</codeph> 方法处理。 </li>
 
     <li><codeph>clickHandler()</codeph> 方法创建一个新的 Matrix 对象 <codeph>skewMatrix</codeph>，该对象被设置为应用倾斜效果。将另一个矩阵 <codeph>tempMatrix</codeph> 分配给 Sprite 的当前转换矩阵，然后使用 <codeph>concat()</codeph> 方法将它与 <codeph>skewMatrix</codeph> 合并。将此矩阵分配给正方形 Sprite 的 <codeph>transform.matrix</codeph> 属性。每次用户单击正方形时，对 <codeph>clickHandler()</codeph> 的调用都将通过倾斜正方形来修改其形状。  </li>
  <li>此外，<codeph>clickHandler()</codeph> 方法创建一个新的 ColorTransform 对象。新 ColorTransform 的 <codeph>redOffset</codeph> 属性设置为 redOffset 的当前值并且每次增加 25。同样，<codeph>blueOffset</codeph> 属性每次减少 25。每次单击时，Sprite 的颜色都会改变。 </li>
  </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.GradientType;
    import flash.geom.Matrix;
    import flash.geom.ColorTransform;
    import flash.events.MouseEvent;

    public class TransformExample extends Sprite {
        public function TransformExample() { 
            var target:Sprite = new Sprite();
            draw(target);
            addChild(target);
            target.useHandCursor = true;
            target.buttonMode = true;
            target.addEventListener(MouseEvent.CLICK, clickHandler)
        }
        public function draw(sprite:Sprite):void {
            var red:uint = 0xFF0000;
            var green:uint = 0x00FF00;
            var blue:uint = 0x0000FF;
            var size:Number = 100;
            sprite.graphics.beginGradientFill(GradientType.LINEAR, [red, blue, green], [1, 0.5, 1], [0, 200, 255]);
            sprite.graphics.drawRect(0, 0, 100, 100);
        }
        public function clickHandler(event:MouseEvent):void {
            var skewMatrix:Matrix = new Matrix();
            skewMatrix.c = 0.25;
            var tempMatrix:Matrix = this.transform.matrix;
            tempMatrix.concat(skewMatrix);
            this.transform.matrix = tempMatrix;
            
            var rOffset:Number = this.transform.colorTransform.redOffset + 25;
            var bOffset:Number = this.transform.colorTransform.blueOffset - 25;
            this.transform.colorTransform = new ColorTransform(1, 1, 1, 1, rOffset, 0, bOffset, 0);            
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links><apiOperation id="flash.geom:Transform:getRelativeMatrix3D"><apiName>getRelativeMatrix3D</apiName><shortdesc>
     返回一个 Matrix3D 对象，该对象可以相对于当前显示对象的空间转换指定显示对象的空间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 Matrix3D 对象，该对象可用于将 <codeph>relativeTo</codeph> 显示对象的空间转换为当前显示对象的空间。
     
     </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>relativeTo</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>相对于其发生转换的显示对象。要获取相对于舞台的 Matrix3D 对象，请将该参数设置为 <codeph>root</codeph> 或 <codeph>stage</codeph> 对象。要获取显示对象的相对于现实世界的矩阵，请将该参数设置为一个已应用透视转换的显示对象。
         
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回一个 Matrix3D 对象，该对象可以相对于当前显示对象的空间转换指定显示对象的空间。可以使用 <codeph>getRelativeMatrix3D()</codeph> 方法，将一个三维显示对象相对于另一个三维显示对象移动。 
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiOperation><apiValue id="flash.geom:Transform:colorTransform:get"><apiName>colorTransform</apiName><shortdesc>
     一个 ColorTransform 对象，其中包含整体调整显示对象颜色的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies the ColorTransform object <code>blueColorTransform</code> to 
    the Transform object <code>trans</code>.  This ColorTransform converts the color of the MovieClip 
    <code>rect</code> from red to blue.
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.ColorTransform;
    
    var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
    
    var trans:Transform = new Transform(rect);
    trace(trans.colorTransform);          
    // (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
    
    var blueColorTransform:ColorTransform = new ColorTransform(0, 1, 1, 1, 0, 0, 255, 0);
    
    parentTrans.colorTransform = blueColorTransform;
    trace(trans.colorTransform);          
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:ColorTransform</apiValueClassifier><apiException><apiDesc>设置时 colorTransform 为 null
     
    </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     一个 ColorTransform 对象，其中包含整体调整显示对象颜色的值。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:concatenatedColorTransform:get"><apiName>concatenatedColorTransform</apiName><shortdesc>
     一个 ColorTransform 对象，表示应用于此显示对象及其所有父级对象的组合颜色转换，回到根级别。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies two Transform objects to both a parent and child MovieClip.
    A <code>blueColorTransform</code> is then applied to the Transform object <code>parentTrans</code> which
    adjusts the color of both parent and child MovieClips towards blue.  Notice how <code>child.concatenatedColorTransform</code> is the
    combination of <code>parentTrans</code> and <code>childTrans</code>. 
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.ColorTransform;
    
    var parentRect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var childRect:MovieClip = createRectangle(10, 40, 0x00FF00, parentRect);
    
    var parentTrans:Transform = new Transform(parentRect);
    var childTrans:Transform = new Transform(childRect);
    
    var blueColorTransform:ColorTransform = new ColorTransform(0, 1, 1, 1, 0, 0, 255, 0);
    
    parentTrans.colorTransform = blueColorTransform;
    
    trace(childTrans.concatenatedColorTransform);     
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    trace(childTrans.colorTransform);                 
    // (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
    trace(parentTrans.concatenatedColorTransform);    
    // (redMultiplier=0, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=0, greenOffset=0, blueOffset=255, alphaOffset=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:ColorTransform</apiValueClassifier></apiValueDef><apiDesc>
     一个 ColorTransform 对象，表示应用于此显示对象及其所有父级对象的组合颜色转换，回到根级别。如果在不同级别上应用了不同的颜色转换，则将其中所有转换连接成此属性的一个 ColorTransform 对象。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:concatenatedMatrix:get"><apiName>concatenatedMatrix</apiName><shortdesc>
     一个 Matrix 对象，表示此显示对象及其所有父级对象的组合转换矩阵，回到根级别。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies two Transform objects to a parent movie clip and to a child movie clip.
    A <code>scaleMatrix</code> is then applied to the Transform object <code>parentTrans</code> which
    scales both parent and child MovieClips.  Notice how <code>child.concatenatedMatrix</code> is the
    combination of <code>parentTrans</code> and <code>childTrans</code>. 
    
    <listing version="2.0">
    import flash.geom.Transform;
    import flash.geom.Matrix;
    
    var parentRect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var childRect:MovieClip = createRectangle(10, 40, 0x00FF00, parentRect);
    
    var parentTrans:Transform = new Transform(parentRect);
    var childTrans:Transform = new Transform(childRect);
    
    var scaleMatrix:Matrix = new Matrix();
    scaleMatrix.scale(2, 2);
    
    parentTrans.matrix = scaleMatrix;
    
    trace(childTrans.concatenatedMatrix);     // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(childTrans.matrix);                 // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    trace(parentTrans.concatenatedMatrix);    // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     一个 Matrix 对象，表示此显示对象及其所有父级对象的组合转换矩阵，回到根级别。如果在不同级别上应用了不同的转换矩阵，则将其中所有矩阵连接成此属性的一个矩阵。此外，对于浏览器中运行的可调整大小的 SWF 内容，此属性将因调整窗口大小而造成的舞台坐标与窗口坐标之差视为重要因素。因此，该属性将局部坐标转换为窗口坐标，后者可能与舞台的坐标空间不同。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Transform:matrix:get"><apiName>matrix</apiName><shortdesc>
     一个 Matrix 对象，其中包含更改显示对象的缩放、旋转和平移的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example applies the Matrix object <code>scaleMatrix</code> to the Transform
     object <code>trans</code>.  This Matrix scales the MovieClip <code>rect</code> by a factor of two.
     <listing version="2.0">
     import flash.geom.Transform;
     import flash.geom.Matrix;
     
     var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
     
     var trans:Transform = new Transform(rect);
     trace(trans.matrix);         // (a=1, b=0, c=0, d=1, tx=0, ty=0)
          
     var scaleMatrix:Matrix = new Matrix();
     scaleMatrix.scale(2, 2);
     
     trans.matrix = scaleMatrix;
     trace(trans.matrix);         // (a=2, b=0, c=0, d=2, tx=0, ty=0)
     
     function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
     }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier><apiException><apiDesc>设置时矩阵为 null
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     一个 Matrix 对象，其中包含更改显示对象的缩放、旋转和平移的值。
     
     <p>如果将 <codeph>matrix</codeph> 属性设置为某个值（非 <codeph>null</codeph>），则 <codeph>matrix3D</codeph> 属性为 <codeph>null</codeph>。如果将 <codeph>matrix3D</codeph> 属性设置为某个值（非 <codeph>null</codeph>），则 <codeph>matrix</codeph> 属性为 <codeph>null</codeph>。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:matrix3D:get"><apiName>matrix3D</apiName><shortdesc>
     提供对三维显示对象的 Matrix3D 对象的访问。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Matrix3D</apiValueClassifier></apiValueDef><apiDesc>
     提供对三维显示对象的 Matrix3D 对象的访问。Matrix3D 对象表示一个转换矩阵，它确定显示对象的位置和方向。Matrix3D 对象还可以执行透视投影。
     
     <p>如果将 <codeph>matrix</codeph> 属性设置为某个值（非 <codeph>null</codeph>），则 <codeph>matrix3D</codeph> 属性为 <codeph>null</codeph>。如果将 <codeph>matrix3D</codeph> 属性设置为某个值（非 <codeph>null</codeph>），则 <codeph>matrix</codeph> 属性为 <codeph>null</codeph>。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:perspectiveProjection:get"><apiName>perspectiveProjection</apiName><shortdesc>
     提供对三维显示对象的 PerspectiveProjection 对象的访问。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:PerspectiveProjection</apiValueClassifier></apiValueDef><apiDesc>
     提供对三维显示对象的 PerspectiveProjection 对象的访问。可以使用 PerspectiveProjection 对象修改舞台的透视转换，也可以将透视转换分配给显示对象的所有三维子级。
     
     <p>基于视野和舞台的高宽比（尺寸），将默认的 PerspectiveProjection 对象分配给 root 对象。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links></apiValue><apiValue id="flash.geom:Transform:pixelBounds:get"><apiName>pixelBounds</apiName><shortdesc>
     一个 Rectangle 对象，它定义舞台上的显示对象的边界矩形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Transform object <code>trans</code> and traces out
    its <code>pixelBounds</code>.  Notice that pixel bounds returns a bounding box with values 
    equal to MovieClip's <code>getBounds()</code> and <code>getRect()</code> methods.
    <listing version="2.0">
    import flash.geom.Transform;
    
    var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
    var trans:Transform = new Transform(rect);
    trace(trans.pixelBounds);         // (x=0, y=0, w=20, h=80)
    
    var boundsObj:Object = rect.getBounds();
    trace(boundsObj.xMin);            // 0
    trace(boundsObj.yMin);            // 0
    trace(boundsObj.xMax);            // 20
    trace(boundsObj.yMax);            // 80
    
    var rectObj:Object = rect.getRect();
    trace(rectObj.xMin);              // 0
    trace(rectObj.yMin);              // 0
    trace(rectObj.xMax);              // 20
    trace(rectObj.yMax);              // 80
    
    function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
      scope = (scope == undefined) ? this : scope;
      var depth:Number = scope.getNextHighestDepth();
      var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     一个 Rectangle 对象，它定义舞台上的显示对象的边界矩形。
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Matrix"><apiName>Matrix</apiName><shortdesc>
 Matrix 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>一个标准的二维同类 Matrix 类。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Matrix 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 <codeph>matrix</codeph> 属性，然后应用该 Transform 对象作为显示对象的 <codeph>transform</codeph> 属性。这些转换函数包括平移（<i>x</i> 和 <i>y</i> 重新定位）、旋转、缩放和倾斜。 
 
 <p>这些转换类型统称为<i>仿射转换</i>。仿射转换在转换时保持线条笔直，因此平行线保持平行。</p>
 
 <p>要对显示对象应用转换矩阵，请创建一个 Transform 对象，将其 <codeph>matrix</codeph> 属性设置为转换矩阵，然后将显示对象的 <codeph>transform</codeph> 属性设置为 Transform 对象。Matrix 对象也被用作某些方法的参数，例如以下方法：</p>
 
 <ul>
 
 <li>BitmapData 对象的 <codeph>draw()</codeph> 方法</li>
 
 <li>Graphics 对象的 <codeph>beginBitmapFill()</codeph> 方法、<codeph>beginGradientFill()</codeph> 方法或 <codeph>lineGradientStyle()</codeph> 方法</li>
 
 </ul>
 
 <p>转换矩阵对象为具有如下内容的 3 x 3 的矩阵：</p>
 
 <p><adobeimage alt="以矩阵表示法表示的 Matrix 类属性" href="../../images/matrix_props1.jpg"/></p>
 
 <p>在传统的转换矩阵中，<codeph>u</codeph>、<codeph>v</codeph> 和 <codeph>w</codeph> 属性具有其它功能。Matrix 类只能在二维空间中操作，因此始终假定属性值 <codeph>u</codeph> 和 <codeph>v</codeph> 为 0.0，属性值 <codeph>w</codeph> 为 1.0。矩阵的有效值如下：</p>
 
 <p><adobeimage alt="以矩阵表示法表示的 Matrix 类属性显示 u、v 和 w 的假设值" href="../../images/matrix_props2.jpg"/></p>
 
 <p>您可以获取和设置 Matrix 对象的全部六个其它属性的值：<codeph>a</codeph>、<codeph>b</codeph>、<codeph>c</codeph>、<codeph>d</codeph>、<codeph>tx</codeph> 和 <codeph>ty</codeph>。</p>
 
 <p>Matrix 类支持四种主要类型的转换：平移、缩放、旋转和倾斜。您可以使用特定的方法来设置这些转换的其中三个，如下表中所述： </p>
 
 <adobetable class="innertable">
   
   
   
   
   
 <tgroup cols="5"><thead><row><entry>转换</entry><entry>方法</entry><entry>矩阵值</entry><entry>显示结果</entry><entry>说明</entry></row></thead><tbody><row valign="top">
  <entry>平移（置换）</entry>
  <entry outputclass="nowrap"><codeph>translate(tx, ty)</codeph> </entry>
  <entry><adobeimage alt="translate 方法参数的矩阵表示法" height="104" href="../../images/matrix_translate.jpg" width="150"/></entry>
  <entry><adobeimage alt="translate 方法效果的图示" height="91" href="../../images/matrix_translate_image.jpg" width="111"/></entry>
  <entry>将图像 <codeph>tx</codeph> 像素向右移动，将 <codeph>ty</codeph> 像素向下移动。</entry>
   </row><row valign="top">
  <entry>缩放</entry>
  <entry><codeph>scale(sx, sy)</codeph></entry>
  <entry><adobeimage alt="scale 方法参数的矩阵表示法" height="105" href="../../images/matrix_scale.jpg" width="140"/></entry>
  <entry><adobeimage alt="scale 方法效果的图示" height="84" href="../../images/matrix_scale_image.jpg" width="111"/></entry>
  <entry>将每个像素的位置乘以 <i>x</i> 轴的 <codeph>sx</codeph> 和 <i>y</i> 轴的 <codeph>sy</codeph>，从而调整图像的大小。</entry>
   </row><row valign="top">
  <entry>旋转</entry>
  <entry><codeph>rotate(q)</codeph></entry>
  <entry><adobeimage alt="rotate 方法属性的矩阵表示法" height="105" href="../../images/matrix_rotate.jpg" width="219"/></entry>
  <entry><adobeimage alt="rotate 方法效果的图示" height="91" href="../../images/matrix_rotate_image.jpg" width="111"/></entry>
  <entry>将图像旋转一个以弧度为单位的角度 <codeph>q</codeph>。</entry>
   </row><row valign="top">
  <entry>倾斜或剪切 </entry>
  <entry>无；必须设置属性 <codeph>b</codeph> 和 <codeph>c</codeph></entry>
  <entry><adobeimage alt="skew 函数属性的矩阵表示法" href="../../images/matrix_skew.jpg"/></entry>
  <entry><adobeimage alt="skew 函数效果的图示" height="77" href="../../images/matrix_skew_image.jpg" width="111"/></entry>
  <entry>以平行于 <i>x</i> 轴或 <i>y</i> 轴的方向逐渐滑动图像。Matrix 对象的 <codeph>b</codeph> 属性表示斜角沿 <i>y</i> 轴的正切；Matrix 对象的 <codeph>c</codeph> 属性表示斜角沿 <i>x</i> 轴的正切。</entry>
   </row></tbody></tgroup></adobetable>
 <p>每个转换函数都将更改当前矩阵的属性，所以您可以有效地合并多个转换。为此，请先调用多个转换函数，再将矩阵应用于其显示对象目标（通过使用该显示对象的 <codeph>transform</codeph> 属性）。</p>
 
 <p>使用 <codeph>new Matrix()</codeph> 构造函数创建 Matrix 对象后，才能调用 Matrix 对象的方法。</p>
 
 </apiDesc><example conref="examples\MatrixExample.as"> 下面的示例使用 <codeph>MatrixExample</codeph> 类来说明如何创建大的渐变填充正方形。这是由以下步骤完成的：
 <ol>
     <li>应用程序创建新的 Matrix 对象 <codeph>myMatrix</codeph>，该对象使用 <codeph>trace()</codeph> 方法输出 <codeph>myMatrix</codeph> 对象的默认属性值。</li>
     <li>应用程序调用 <codeph>createGradientBox()</codeph>，其 <codeph>width</codeph> 和 <codeph>height</codeph> 参数设置为 200 像素，无旋转，且沿 <i>x</i> 轴和 <i>y</i> 轴平移的距离设置为 50 像素。</li>
     <li>应用程序将再次打印 <codeph>myMatrix</codeph> 对象以显示调用 <codeph>createGradientBox()</codeph> 方法后的更改。</li>
     <li>应用程序设置三个变量以控制如何填充渐变框：
     <ul>
         <li><codeph>colors</codeph>：将渐变颜色设置为纯红和纯蓝范围之间。</li>
         <li><codeph>alphas</codeph>：将不透明度设置为纯色。</li>
         <li><codeph>ratios</codeph>：将红色和蓝色的颜色分布设置为相同。</li>
  </ul></li>
     <li>应用程序调用图形方法 <codeph>beginGradientFill()</codeph>（该方法作用于 <codeph>myMatrix</codeph> 对象），并且调用 <codeph>lineTo()</codeph> 方法，生成渐变填充框。</li>
 </ol>
<codeblock>
package {
    import flash.geom.Matrix;
    import flash.display.Sprite;
    import flash.display.GradientType;

    public class MatrixExample extends Sprite {

        public function MatrixExample() {
            var myMatrix:Matrix = new Matrix();
            trace(myMatrix.toString());    // (a=1, b=0, c=0, d=1, tx=0, ty=0)

            myMatrix.createGradientBox(200, 200, 0, 50, 50);
            trace(myMatrix.toString());    // (a=0.1220703125, b=0, c=0, d=0.1220703125, tx=150, ty=150)

            var colors:Array = [0xFF0000, 0x0000FF];
            var alphas:Array = [1, 1];
            var ratios:Array = [0, 0xFF];
            graphics.beginGradientFill(GradientType.LINEAR, colors, alphas, ratios, myMatrix);
            graphics.lineTo(0, 300);
            graphics.lineTo(300, 300);
            graphics.lineTo(300, 0);
            graphics.lineTo(0, 0);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiConstructor id="flash.geom:Matrix:Matrix"><apiName>Matrix</apiName><shortdesc>
    使用指定参数创建新的 Matrix 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
    
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>a</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>缩放或旋转图像时影响像素沿 <i>x</i> 轴定位的值。
    </apiDesc></apiParam><apiParam><apiItemName>b</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>旋转或倾斜图像时影响像素沿 <i>y</i> 轴定位的值。
    </apiDesc></apiParam><apiParam><apiItemName>c</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>旋转或倾斜图像时影响像素沿 <i>x</i> 轴定位的值。
    </apiDesc></apiParam><apiParam><apiItemName>d</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>缩放或旋转图像时影响像素沿 <i>y</i> 轴定位的值。
    </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>沿 <i>x</i> 轴平移每个点的距离。
    </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>沿 <i>y</i> 轴平移每个点的距离。
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>创建一个新的二维 Matrix 对象。
    
    </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
    使用指定参数创建新的 Matrix 对象。在矩阵表示法中，按如下方式组织属性：
    
    <p><adobeimage alt="以矩阵表示法表示的 Matrix 类属性显示 u、v 和 w 的假设值" href="../../images/matrix_props2.jpg"/></p>
    
    <p>如果不向 <codeph>new Matrix()</codeph> 构造函数提供任何参数，它将创建一个具有以下值的<i>恒等矩阵</i>：</p>
    <adobetable class="innertable">
    
    
    
    <tgroup cols="2"><tbody><row>
      <entry><pre>a = 1</pre></entry>
      <entry><pre>b = 0</pre></entry>
    </row><row>
      <entry><pre>c = 0</pre></entry>
      <entry><pre>d = 1</pre></entry>
    </row><row>
      <entry><pre>tx = 0</pre></entry>
      <entry><pre>ty = 0</pre></entry>
    </row></tbody></tgroup></adobetable>
    <p>在矩阵表示法中，恒等矩阵如下所示：</p>
    
    <p><adobeimage alt="以矩阵表示法表示的 Matrix 类属性" href="../../images/matrix_identity.jpg"/></p>
    
    </apiDesc><example conref="examples\Matrix.1.as"> 下面的示例通过不向 <codeph>Matrix()</codeph> 构造函数发送参数创建 <codeph>matrix_1</codeph>，而通过向该构造函数发送参数创建 <codeph>matrix_2</codeph>。请注意，未使用参数创建的 <codeph>matrix_1</codeph> 将生成一个具有值 <codeph>a</codeph>=1、<codeph>b</codeph>=0、<codeph>c</codeph>=0、<codeph>d</codeph>=1、<codeph>tx</codeph>=0、<codeph>ty</codeph>=0 的恒等矩阵。
<codeblock>
import flash.geom.Matrix;

var matrix_1:Matrix = new Matrix();
trace(matrix_1);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)

var matrix_2:Matrix = new Matrix(1, 2, 3, 4, 5, 6);
trace(matrix_2);  // (a=1, b=2, c=3, d=4, tx=5, ty=6)
</codeblock></example></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Matrix:clone"><apiName>clone</apiName><shortdesc>
    返回一个新的 Matrix 对象，它是此矩阵的克隆，带有与所含对象完全相同的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>clonedMatrix</code> from <code>myMatrix</code>.
    Notice that the Matrix class does not have an equals method, so the following example
    uses a custom written function to test the equality of two Matricies.
    
    <listing version="2.0">
    import flash.geom.Matrix;
       
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 0, 0);
    var clonedMatrix:Matrix = new Matrix();
    
    trace(myMatrix);                        // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(clonedMatrix);                    // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    trace(equals(myMatrix, clonedMatrix));  // false
    
    clonedMatrix = myMatrix.clone(); 
    
    trace(myMatrix);                        // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(clonedMatrix);                    // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    trace(equals(myMatrix, clonedMatrix));  // true
    
    function equals(m1:Matrix, m2:Matrix):Boolean {
        return m1.toString() == m2.toString();
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 Matrix 对象。
    
    </apiDesc><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>返回一个新的 Matrix 对象，该对象是当前矩阵的副本。
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    返回一个新的 Matrix 对象，它是此矩阵的克隆，带有与所含对象完全相同的副本。
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:concat"><apiName>concat</apiName><shortdesc>
    将某个矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three Matricies that define transformations for
    three rectangle MovieClips.  The first two Matricies <code>rotate45Matrix</code>
    and <code>doubleScaleMatrix</code> are applied to the two rectangles 
    <code>rectangleMc_1</code> and <code>rectangleMc_2</code>.  Then, the third
    Matrix is created using the <code>concat()</code> method on <code>rotate45Matrix</code> and 
    <code>doubleScaleMatrix</code> to create <code>scaleAndRotateMatrix</code>. 
    This Matrix is then applied to <code>rectangleMc_3</code> to scale and rotate it.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var rectangleMc_0:MovieClip = createRectangle(20, 80, 0x000000);
    var rectangleMc_1:MovieClip = createRectangle(20, 80, 0xFF0000);   
    var rectangleMc_2:MovieClip = createRectangle(20, 80, 0x00FF00);   
    var rectangleMc_3:MovieClip = createRectangle(20, 80, 0x0000FF);
    
    var rectangleTrans_1:Transform = new Transform(rectangleMc_1);
    var rectangleTrans_2:Transform = new Transform(rectangleMc_2);
    var rectangleTrans_3:Transform = new Transform(rectangleMc_3);
    
    var rotate45Matrix:Matrix = new Matrix();
    rotate45Matrix.rotate(Math.PI/4);
    rectangleTrans_1.matrix = rotate45Matrix;
    rectangleMc_1._x = 100;
    trace(rotate45Matrix.toString());    // (a=0.707106781186548, b=0.707106781186547, c=-0.707106781186547, d=0.707106781186548, tx=0, ty=0)
    
    var doubleScaleMatrix:Matrix = new Matrix();
    doubleScaleMatrix.scale(2, 2);
    rectangleTrans_2.matrix = doubleScaleMatrix;
    rectangleMc_2._x = 200;
    trace(doubleScaleMatrix.toString());  // (a=2, b=0, c=0, d=2, tx=0, ty=0)
    
    var scaleAndRotateMatrix:Matrix = doubleScaleMatrix.clone();
    scaleAndRotateMatrix.concat(rotate45Matrix);
    rectangleTrans_3.matrix = scaleAndRotateMatrix;
    rectangleMc_3._x = 300;
    trace(scaleAndRotateMatrix.toString());   // (a=1.4142135623731, b=1.41421356237309, c=-1.41421356237309, d=1.4142135623731, tx=0, ty=0)
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
        var depth:Number = this.getNextHighestDepth();
        var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
        mc.beginFill(color);
        mc.lineTo(0, height);
        mc.lineTo(width, height);
        mc.lineTo(width, 0);
        mc.lineTo(0, 0);
        return mc;
    }
    
    </listing>
    
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>m</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiDesc>要连接到源矩阵的矩阵。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    将某个矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。在数学术语中，将两个矩阵连接起来与使用矩阵乘法将它们结合起来是相同的。
    
    <p>例如，如果矩阵 <codeph>m1</codeph> 使用系数 4 缩放某个对象，而矩阵 <codeph>m2</codeph> 使用 1.5707963267949 弧度 (<codeph>Math.PI/2</codeph>) 旋转该对象，则 <codeph>m1.concat(m2)</codeph> 会将 <codeph>m1</codeph> 转换为一个使用系数 4 缩放对象并使用 <codeph>Math.PI/2</codeph> 弧度旋转该对象的矩阵。 </p>
    
    <p>此方法将源矩阵替换为连接矩阵。如果要在不更改两个源矩阵中的任何一个的情况下连接这两个矩阵，则可以通过使用 <codeph>clone()</codeph> 方法首先复制源矩阵，如“类示例”部分中所示。</p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:createBox"><apiName>createBox</apiName><shortdesc>
     包括用于缩放、旋转和转换的参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>scaleX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>水平缩放所用的系数。 
     
     </apiDesc></apiParam><apiParam><apiItemName>scaleY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>垂直缩放所用的系数。 
     
     </apiDesc></apiParam><apiParam><apiItemName>rotation</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>旋转量（以弧度为单位）。 
     
     </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>沿 <i>x</i> 轴向右平移（移动）的像素数。 
     
     </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>沿 <i>y</i> 轴向下平移（移动）的像素数。  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>创建含有缩放、旋转和平移值的 Matrix。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     包括用于缩放、旋转和转换的参数。当应用于矩阵时，该方法会基于这些参数设置矩阵的值。
     
     <p>通过使用 <codeph>createBox()</codeph> 方法，您可以获得与依次应用 <codeph>identity()</codeph>、<codeph>rotate()</codeph>、<codeph>scale()</codeph> 和 <codeph>translate()</codeph> 方法时得到的矩阵相同的矩阵。例如，<codeph>mat1.createBox(2,2, ,Math.PI/4, 100, 100)</codeph> 具有与如下所示代码相同的效果：</p>
     
     <codeblock platform="actionscript">
     import flash.geom.Matrix;
     
     var mat1:Matrix = new Matrix();
     mat1.identity();
     mat1.rotate(Math.PI/4);
     mat1.scale(2,2);
     mat1.translate(10,20);
     </codeblock>
     
     <codeblock platform="javascript">
     var mat1 = new air.Matrix();
     mat1.identity();
     mat1.rotate(Math.PI/4);
     mat1.scale(2, 2);
     mat1.translate(10, 20);
     </codeblock>
     
     </apiDesc><example conref="examples\Matrix_createBox.as"> 下面的示例通过调用 <codeph>myMatrix</codeph> 的 <codeph>createBox()</codeph> 方法来设置它的 x 缩放比例、y 缩放比例、旋转、x 位置和 y 位置。
<codeblock>

package
{
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    public class Matrix_createBox extends Sprite
    {
        public function Matrix_createBox()
        {
             var myMatrix:Matrix = new Matrix();
             trace(myMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
             myMatrix.createBox(1, 2, Math.PI/4, 50, 100);
             trace(myMatrix.toString());  
             // (a=0.7071067811865476, b=1.414213562373095, c=-0.7071067811865475, 
             //  d=1.4142135623730951, tx=100, ty=200)
             
             var rectangleShape:Shape = createRectangle(20, 80, 0xFF0000);   
             addChild(rectangleShape);
              
             var rectangleTrans:Transform = new Transform(rectangleShape);
             rectangleTrans.matrix = myMatrix;
        }
        
        public function createRectangle(w:Number, h:Number, color:Number):Shape 
        {
            var rect:Shape = new Shape();
            rect.graphics.beginFill(color);
            rect.graphics.drawRect(0, 0, w, h);
            addChild(rect);
            return rect;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix:createGradientBox"><apiName>createGradientBox</apiName><shortdesc>
     创建 Graphics 类的 beginGradientFill() 和 lineGradientStyle() 方法所需的矩阵的特定样式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Method
     
     </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>渐变框的宽度。
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>渐变框的高度。
     
     </apiDesc></apiParam><apiParam><apiItemName>rotation</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>旋转量（以弧度为单位）。 
     
     </apiDesc></apiParam><apiParam><apiItemName>tx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>沿 <i>x</i> 轴向右平移的距离（以像素为单位）。此值将偏移 <codeph>width</codeph> 参数的一半。 
     
     </apiDesc></apiParam><apiParam><apiItemName>ty</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>沿 <i>y</i> 轴向下平移的距离（以像素为单位）。此值将偏移 <codeph>height</codeph> 参数的一半。 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>创建 Graphics 类的 beginGradientFill() 方法所需的矩阵的特定样式。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     创建 Graphics 类的 <codeph>beginGradientFill()</codeph> 和 <codeph>lineGradientStyle()</codeph> 方法所需的矩阵的特定样式。宽度和高度被缩放为 <codeph>scaleX</codeph>/<codeph>scaleY</codeph> 对，而 <codeph>tx</codeph>/<codeph>ty</codeph> 值偏移了宽度和高度的一半。
     
     <p>例如，假设渐变具有以下特性：</p>
     
     <ul>
     
     <li><codeph>GradientType.LINEAR</codeph></li>
     <li>绿色和蓝色这两种颜色（比例数组设置为 <codeph>[0, 255]</codeph>）</li>
     <li><codeph>SpreadMethod.PAD</codeph></li>
     <li><codeph>InterpolationMethod.LINEAR_RGB</codeph></li>
     
     </ul>
     
     <p>下图显示了使用 <codeph>createGradientBox()</codeph> 方法以不同参数设置在其中定义矩阵的渐变：</p>
     
     <adobetable class="innertable">
     
      
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry><codeph>createGradientBox()</codeph> 设置</entry><entry>生成的渐变</entry></row></thead><tbody><row>
     
      <entry><pre>width = 25;
     height = 25; 
     rotation = 0; 
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="生成的线性渐变" href="../../images/createGradientBox-1.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 25; 
     height = 25; 
     rotation = 0; 
     tx = 25; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="生成的线性渐变" href="../../images/createGradientBox-2.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 50; 
     height = 50; 
     rotation = 0; 
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="生成的线性渐变" href="../../images/createGradientBox-3.jpg"/></entry>
     
     </row><row>
     
      <entry><pre>width = 50;
     height = 50; 
     rotation = Math.PI / 4; // 45 degrees
     tx = 0; 
     ty = 0;</pre></entry>
     
     <entry align="center"><adobeimage alt="生成的线性渐变" href="../../images/createGradientBox-4.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\Matrix_createGradientBox.as"> 下面的示例通过调用 <codeph>myMatrix</codeph> 的 <codeph>createBox()</codeph> 方法来设置它的 x 缩放比例、y 缩放比例、旋转、x 位置和 y 位置。
<codeblock>

package
{
    import flash.display.GradientType;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    
    public class Matrix_createGradientBox extends Sprite
    {
        public function Matrix_createGradientBox()
        {
             var myMatrix:Matrix = new Matrix();
             trace(myMatrix.toString());          // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
             myMatrix.createGradientBox(200, 200, 0, 50, 50);
             trace(myMatrix.toString());          // (a=0.1220703125, b=0, c=0, d=0.1220703125, tx=150, ty=150)
             
             var colors:Array = [0xFF0000, 0x0000FF];
             var alphas:Array = [100, 100];
             var ratios:Array = [0, 0xFF];
             
             this.graphics.beginGradientFill(GradientType.LINEAR, colors, alphas, ratios, myMatrix);
             this.graphics.drawRect(0, 0, 300, 200);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Matrix:deltaTransformPoint"><apiName>deltaTransformPoint</apiName><shortdesc>
    如果给定预转换坐标空间中的点，则此方法返回发生转换后该点的坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>deltaTransformPoint()</code> method 
    to create <code>deltaTransformedPoint</code> from <code>myPoint</code>.  Notice that
    the <code>translate()</code> method has no affect on the position of <code>deltaTransformedPoint</code>.
    In the example, however, <code>scale()</code> does affect the position.  It
    increases the original <code>x</code> value by a factor of three from 50 to 150.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Point;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    myMatrix.translate(100, 0);
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=100, ty=0)
    
    myMatrix.scale(3, 3);
    trace(myMatrix);  // (a=3, b=0, c=0, d=3, tx=300, ty=0)
    
    var myPoint:Point = new Point(50,0);
    trace(myPoint);   // (50, 0)              
    
    var deltaTransformedPoint:Point = myMatrix.deltaTransformPoint(myPoint);
    trace(deltaTransformedPoint); // (150, 0)
    
    var pointMc_0:MovieClip = createRectangle(10, 10, 0xFF0000);
    pointMc_0._x = myPoint.x;
    
    var pointMc_1:MovieClip = createRectangle(10, 10, 0x00FF00);
    pointMc_1._x = deltaTransformedPoint.x;
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>由应用矩阵转换所产生的点。
    
    </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>想要获得其矩阵转换结果的点。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    如果给定预转换坐标空间中的点，则此方法返回发生转换后该点的坐标。与使用 <codeph>transformPoint()</codeph> 方法应用的标准转换不同，<codeph>deltaTransformPoint()</codeph> 方法的转换不考虑转换参数 <codeph>tx</codeph> 和 <codeph>ty</codeph>。
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:identity"><apiName>identity</apiName><shortdesc>
    为每个矩阵属性设置一个值，该值将导致 null 转换。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Method
    </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
    为每个矩阵属性设置一个值，该值将导致 null 转换。通过应用恒等矩阵转换的对象将与原始对象完全相同。
    
    <p>调用 <codeph>identity()</codeph> 方法后，生成的矩阵具有以下属性：<codeph>a</codeph>=1、<codeph>b</codeph>=0、<codeph>c</codeph>=0、<codeph>d</codeph>=1、<codeph>tx</codeph>=0 和 <codeph>ty</codeph>=0。</p>
    
    <p>在矩阵表示法中，恒等矩阵如下所示：</p>
    
    <p><adobeimage alt="以矩阵表示法表示的 Matrix 类属性" href="../../images/matrix_identity.jpg"/></p>
    
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:invert"><apiName>invert</apiName><shortdesc>
     执行原始矩阵的逆转换。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     执行原始矩阵的逆转换。您可以将一个逆矩阵应用于对象来撤消在应用原始矩阵时执行的转换。
     
     </apiDesc><example conref="examples\Matrix_invert.as"> 下面的示例创建一个 <codeph>halfScaleMatrix</codeph>，方法是调用 <codeph>doubleScaleMatrix</codeph> 的 <codeph>invert()</codeph> 方法。然后它将显示这两个矩阵互为逆矩阵（即两个矩阵互相撤消由另一个矩阵执行的所有转换操作），方法是通过创建 <codeph>originalAndInverseMatrix</codeph>，它等同于 <codeph>noScaleMatrix</codeph>。
<codeblock>

package
{
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    public class Matrix_invert extends Sprite
    {
        public function Matrix_invert()
        {
            var rect0:Shape = createRectangle(20, 80, 0xFF0000);   
            var rect1:Shape = createRectangle(20, 80, 0x00FF00);   
            var rect2:Shape = createRectangle(20, 80, 0x0000FF);
            var rect3:Shape = createRectangle(20, 80, 0x000000);
            
            var trans0:Transform = new Transform(rect0);
            var trans1:Transform = new Transform(rect1);
            var trans2:Transform = new Transform(rect2);
            var trans3:Transform = new Transform(rect3);
             
            var doubleScaleMatrix:Matrix = new Matrix(2, 0, 0, 2, 0, 0);
            trans0.matrix = doubleScaleMatrix;
            trace(doubleScaleMatrix.toString());  // (a=2, b=0, c=0, d=2, tx=0, ty=0)
             
            var noScaleMatrix:Matrix = new Matrix(1, 0, 0, 1, 0, 0);
            trans1.matrix = noScaleMatrix;
            rect1.x = 50;
            trace(noScaleMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
             
            var halfScaleMatrix:Matrix = doubleScaleMatrix.clone();
            halfScaleMatrix.invert();
            trans2.matrix = halfScaleMatrix;
            rect2.x = 100;
            trace(halfScaleMatrix.toString());  // (a=0.5, b=0, c=0, d=0.5, tx=0, ty=0)
             
            var originalAndInverseMatrix:Matrix = doubleScaleMatrix.clone();
            originalAndInverseMatrix.concat(halfScaleMatrix);
            trans3.matrix = originalAndInverseMatrix;
            rect3.x = 150;
            trace(originalAndInverseMatrix.toString());  // (a=1, b=0, c=0, d=1, tx=0, ty=0)            
        }
        
        public function createRectangle(w:Number, h:Number, color:Number):Shape 
        {
            var rect:Shape = new Shape();
            rect.graphics.beginFill(color);
            rect.graphics.drawRect(0, 0, w, h);
            addChild(rect);
            return rect;
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:rotate"><apiName>rotate</apiName><shortdesc>
     对 Matrix 对象应用旋转转换。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example the <code>rotate()</code> method rotates <code>rectangleMc</code>
    30 degrees clockwise.  Notice that applying <code>myMatrix</code> to <code>rectangleMc</code>
    resets its <i>_x</i> value leaving us to reset it to 100 manually.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix.toString());           // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    var degrees:Number = 30;
    var radians:Number = (degrees/180) ~~ Math.PI;
    myMatrix.rotate(radians);
    trace(myMatrix.toString());           // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=0, ty=0)
    
    var rectangleMc:MovieClip = createRectangle(20, 80, 0xFF0000);
    trace(rectangleMc._x);                // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);                // 100
    
    var rectangleTrans:Transform = new Transform(rectangleMc);
    rectangleTrans.matrix = myMatrix;
    trace(rectangleMc._x);                // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);                // 100
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
    The above example uses the <code>_x</code> property of the MovieClip object 
    to position <code>rectangleMc</code>.  Generally, when dealing with Matrix
    positioning, mixing positioning techniques is considered bad style.  The  
    example above written in good style would concatenate a translation Matrix to
    <code>myMatrix</code> to change the horizontal location of <code>rectangleMc</code>. 
    The following example demonstrates this. 
    <listing version="2.0">
    import flash.geom.Matrix;
    import flash.geom.Transform;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix.toString());   // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    var degrees:Number = 30;
    var radians:Number = (degrees/180) ~~ Math.PI;
    myMatrix.rotate(radians);
    trace(myMatrix.toString());   // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=0, ty=0)
    
    var translateMatrix:Matrix = new Matrix();
    translateMatrix.translate(100, 0);
    myMatrix.concat(translateMatrix);
    trace(myMatrix.toString());   // (a=0.866025403784439, b=0.5, c=-0.5, d=0.866025403784439, tx=100, ty=0)
    
    var rectangleMc:MovieClip = createRectangle(20, 80, 0xFF0000);
    trace(rectangleMc._x);        // 0
    rectangleMc._x = 100;
    trace(rectangleMc._x);        // 100
    
    var rectangleTrans:Transform = new Transform(rectangleMc);
    rectangleTrans.matrix = myMatrix;
    trace(rectangleMc._x);        // 100
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>以弧度为单位的旋转角度。
     
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     对 Matrix 对象应用旋转转换。 
     
     <p><codeph>rotate()</codeph> 方法将更改 Matrix 对象的 <codeph>a</codeph>、<codeph>b</codeph>、<codeph>c</codeph> 和 <codeph>d</codeph> 属性。在矩阵表示法中，当前矩阵与以下矩阵连接也产生同样的结果：</p>
     
     <p><adobeimage alt="scale 方法参数的矩阵表示法" height="105" href="../../images/matrix_rotate.jpg" width="219"/></p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:scale"><apiName>scale</apiName><shortdesc>
     对矩阵应用缩放转换。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>scale()</code> method to
    scale <code>myMatrix</code> by a factor of 3 horizontally and a factor of 4 
    vertically.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 100, 100);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=100, ty=100)
    
    myMatrix.scale(3, 4);
    trace(myMatrix.toString());   // (a=6, b=0, c=0, d=8, tx=300, ty=400)
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>用于沿 <i>x</i> 轴缩放对象的乘数。
     </apiDesc></apiParam><apiParam><apiItemName>sy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>用于沿 <i>y</i> 轴缩放对象的乘数。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     对矩阵应用缩放转换。<i>x</i> 轴乘以 <codeph>sx</codeph>，<i>y</i> 轴乘以 <codeph>sy</codeph>。
     
     <p><codeph>scale()</codeph> 方法将更改 Matrix 对象的 <codeph>a</codeph> 和 <codeph>d</codeph> 属性。在矩阵表示法中，当前矩阵与以下矩阵连接也产生同样的结果：</p>
     <p><adobeimage alt="scale 方法参数的矩阵表示法" height="105" href="../../images/matrix_scale.jpg" width="140"/></p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:toString"><apiName>toString</apiName><shortdesc>
     返回列出该 Matrix 对象属性的文本值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>myMatrix</code> and converts its values 
     to a String in the format of (a=A, b=B, c=C, d=D, tx=TX, ty=TY).
     
     <listing version="2.0">
     import flash.geom.Matrix;
     
     var myMatrix:Matrix = new Matrix();
     trace("myMatrix: " + myMatrix.toString()); // (a=1, b=0, c=0, d=1, tx=0, ty=0)
     </listing>
      
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个字符串，它包含 Matrix 对象的属性值：<codeph>a</codeph>、<codeph>b</codeph>、<codeph>c</codeph>、<codeph>d</codeph>、<codeph>tx</codeph> 和 <codeph>ty</codeph>。
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>返回列出该 Matrix 对象属性的文本值。
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     返回列出该 Matrix 对象属性的文本值。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:transformPoint"><apiName>transformPoint</apiName><shortdesc>
     返回将 Matrix 对象表示的几何转换应用于指定点所产生的结果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>transformPoint()</code> method 
    to create <code>transformedPoint</code> from <code>myPoint</code>.  Notice that
    the <code>translate()</code> method does have an affect on the position of <code>transformedPoint</code>.
    In the example, <code>scale()</code> increases the original <code>x</code> 
    value by a factor of three from 50 to 150, and <code>translate()</code> increases 
    <code>x</code> by 300 for a total value of 450.
    
    <listing version="2.0">
    import flash.geom.Matrix;     
    import flash.geom.Point;
    
    var myMatrix:Matrix = new Matrix();
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=0, ty=0)
    
    myMatrix.translate(100, 0);
    trace(myMatrix);  // (a=1, b=0, c=0, d=1, tx=100, ty=0)
    
    myMatrix.scale(3, 3);
    trace(myMatrix);  // (a=3, b=0, c=0, d=3, tx=300, ty=0)
    
    var myPoint:Point = new Point(50,0);
    trace(myPoint);                   // (50, 0)
          
    var transformedPoint:Point = myMatrix.transformPoint(myPoint);
    trace(transformedPoint);  // (450, 0)
    
    var pointMc_0:MovieClip = createRectangle(10, 10, 0xFF0000);
    pointMc_0._x = myPoint.x;
    
    var pointMc_1:MovieClip = createRectangle(10, 10, 0x00FF00);
    pointMc_1._x = transformedPoint.x;
    
    function createRectangle(width:Number, height:Number, color:Number):MovieClip {
      var depth:Number = this.getNextHighestDepth();
      var mc:MovieClip = this.createEmptyMovieClip("mc_" + depth, depth);
      mc.beginFill(color);
      mc.lineTo(0, height);
      mc.lineTo(width, height);
      mc.lineTo(width, 0);
      mc.lineTo(0, 0);
      return mc;
    }
    </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>由应用矩阵转换所产生的点。
    
    
    </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>想要获得其矩阵转换结果的点。
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>返回 Point 对象的几何转换的结果。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     返回将 Matrix 对象表示的几何转换应用于指定点所产生的结果。 
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Matrix:translate"><apiName>translate</apiName><shortdesc>
    沿 x 和 y 轴平移矩阵，由 dx 和 dy 参数指定。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example uses the <code>translate()</code> method to position 
    <code>rectangleMc</code> x:100 and y:50. Notice that <code>translate()</code> affects 
    the translate values <code>tx</code> and <code>ty</code> but not <code>a</code>, <code>b</code>,
    <code>c</code>, or <code>d</code>.
    
    <listing version="2.0">
    import flash.geom.Matrix;
    
    var myMatrix:Matrix = new Matrix(2, 0, 0, 2, 100, 100);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=100, ty=100)
    
    myMatrix.translate(100, 50);
    trace(myMatrix.toString());   // (a=2, b=0, c=0, d=2, tx=200, ty=150)
    </listing>
    </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>沿 <i>x</i> 轴向右移动的量（以像素为单位）。
    
    </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>沿 <i>y</i> 轴向下移动的量（以像素为单位）。
    
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>沿 x 和 y 轴平移矩阵。
    
    <p><codeph>translate()</codeph> 方法将更改 matrix 对象的 <codeph>tx</codeph> 和 <codeph>ty</codeph> 属性。在矩阵表示法中，当前矩阵与以下矩阵连接也产生同样的结果：</p>
    
    <p><adobeimage alt="scale 方法参数的矩阵表示法" height="105" href="../../images/matrix_translate.jpg" width="150"/></p>
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    沿 <i>x</i> 和 <i>y</i> 轴平移矩阵，由 <codeph>dx</codeph> 和 <codeph>dy</codeph> 参数指定。
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Matrix:a"><apiName>a</apiName><shortdesc>
     缩放或旋转图像时影响像素沿 x 轴定位的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>缩放或旋转图像时影响像素沿 x 轴定位的值。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     缩放或旋转图像时影响像素沿 <i>x</i> 轴定位的值。
     
     </apiDesc><example conref="examples\Matrix.a.1.as"> 下面的示例将创建 Matrix 对象 <codeph>myMatrix</codeph> 并设置它的 <codeph>a</codeph> 值。
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.a);  // 1

myMatrix.a = 2;
trace(myMatrix.a);  // 2
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:b"><apiName>b</apiName><shortdesc>
     旋转或倾斜图像时影响像素沿 y 轴定位的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>旋转或倾斜图像时影响像素沿 y 轴定位的值。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     旋转或倾斜图像时影响像素沿 <i>y</i> 轴定位的值。
     
     </apiDesc><example conref="examples\Matrix.b.1.as"> 下面的示例将创建 Matrix 对象 <codeph>myMatrix</codeph> 并设置它的 <codeph>b</codeph> 值。
<codeblock>
import flash.geom.Matrix;
 
var myMatrix:Matrix = new Matrix();
trace(myMatrix.b);  // 0

var degrees:Number = 30;
var radians:Number = (degrees/180) ~~ Math.PI;
myMatrix.b = Math.tan(radians);
trace(myMatrix.b);  // 0.5773502691896257
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:c"><apiName>c</apiName><shortdesc>
     旋转或倾斜图像时影响像素沿 x 轴定位的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>旋转或倾斜图像时影响像素沿 x 轴定位的值。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     旋转或倾斜图像时影响像素沿 <i>x</i> 轴定位的值。
     
     </apiDesc><example conref="examples\Matrix.c.1.as"> 下面的示例将创建 Matrix 对象 <codeph>myMatrix</codeph> 并设置它的 <codeph>c</codeph> 值。
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.c);  // 0

var degrees:Number = 30;
var radians:Number = (degrees/180) ~~ Math.PI;
myMatrix.c = Math.tan(radians);
trace(myMatrix.c);  // 0.5773502691896257
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:d"><apiName>d</apiName><shortdesc>
     缩放或旋转图像时影响像素沿 y 轴定位的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>缩放或旋转图像时影响像素沿 y 轴定位的值。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     缩放或旋转图像时影响像素沿 <i>y</i> 轴定位的值。
     
     </apiDesc><example conref="examples\Matrix.d.1.as"> 下面的示例将创建 Matrix 对象 <codeph>myMatrix</codeph> 并设置它的 <codeph>d</codeph> 值。
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.d);  // 1

myMatrix.d = 2;
trace(myMatrix.d);  // 2
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:tx"><apiName>tx</apiName><shortdesc>
     沿 x 轴平移每个点的距离。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>沿 x 轴平移每个点的距离。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     沿 <i>x</i> 轴平移每个点的距离。
     
     </apiDesc><example conref="examples\Matrix.tx.1.as"> 下面的示例将创建 Matrix 对象 <codeph>myMatrix</codeph> 并设置它的 <codeph>tx</codeph> 值。
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.tx);  // 0

myMatrix.tx = 50;  // 50
trace(myMatrix.tx);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.geom:Matrix:ty"><apiName>ty</apiName><shortdesc>
     沿 y 轴平移每个点的距离。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>沿 y 轴平移每个点的距离。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     沿 <i>y</i> 轴平移每个点的距离。
     
     </apiDesc><example conref="examples\Matrix.ty.1.as"> 下面的示例将创建 Matrix 对象 <codeph>myMatrix</codeph> 并设置它的 <codeph>ty</codeph> 值。
<codeblock>
import flash.geom.Matrix;

var myMatrix:Matrix = new Matrix();
trace(myMatrix.ty);  // 0

myMatrix.ty = 50;
trace(myMatrix.ty);  // 50
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Rectangle"><apiName>Rectangle</apiName><shortdesc>
 Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Rectangle 对象是按其位置（由它左上角的点 (<i>x</i>, <i>y</i>) 确定）以及宽度和高度定义的区域。 
 
 <p>Rectangle 类的 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性相互独立；更改一个属性的值不会影响其它属性。但是，<codeph>right</codeph> 和 <codeph>bottom</codeph> 属性与这四个属性是整体相关的。例如，如果更改 <codeph>right</codeph> 属性的值，则 <codeph>width</codeph> 属性的值将发生变化；如果更改 <codeph>bottom</codeph> 属性，则 <codeph>height</codeph> 属性的值将发生变化。 </p>
 
 <p platform="actionscript">以下方法和属性使用 Rectangle 对象：</p>
 
 <ul platform="actionscript">
 
 	<li><codeph>applyFilter()</codeph>、<codeph>colorTransform()</codeph>、<codeph>copyChannel()</codeph>、<codeph>copyPixels()</codeph>、<codeph>draw()</codeph>、<codeph>fillRect()</codeph>、<codeph>generateFilterRect()</codeph>、<codeph>getColorBoundsRect()</codeph>、<codeph>getPixels()</codeph>、<codeph>merge()</codeph>、<codeph>paletteMap()</codeph>、<codeph>pixelDisolve()</codeph>、<codeph>setPixels()</codeph> 和 <codeph>threshold()</codeph> 方法，以及 BitmapData 类的 <codeph>rect</codeph> 属性</li>
 
 	<li><codeph>getBounds()</codeph> 和 <codeph>getRect()</codeph> 方法，以及 DisplayObject 类的 <codeph>scrollRect</codeph> 和 <codeph>scale9Grid</codeph> 属性</li>
 
 	<li>TextField 类的 <codeph>getCharBoundaries()</codeph> 方法</li>
 
 	<li>Transform 类的 <codeph>pixelBounds</codeph> 属性</li>
 
 	<li>Sprite 类的 <codeph>startDrag()</codeph> 方法的 <codeph>bounds</codeph> 参数</li>
 
 	<li>PrintJob 类的 <codeph>addPage()</codeph> 方法的 <codeph>printArea</codeph> 参数</li>
 
 </ul>
 
 <p>您可以使用 <codeph>new Rectangle()</codeph> 构造函数创建 Rectangle 对象。</p>
 
 <p platform="actionscript"><b>注意：</b>Rectangle 类不定义矩形 Shape 显示对象。要在屏幕上绘制矩形 Shape 对象，请使用 Graphics 类的 <codeph>drawRect()</codeph> 方法。</p>
 
 </apiDesc><example conref="examples\RectangleExample.as"> 下面的示例使用 RectangleExample 类以不同的高度和宽度在不同的 <i>x</i> , <i>y</i> 坐标处创建三个新的 Rectangle 对象，随后使用 <codeph>trace()</codeph> 方法确认是否成功创建了 Rectangle 实例。然后将布尔变量 <codeph>isContained</codeph> 赋予对 <codeph>containsRect()</codeph> 方法的调用结果，该方法确定第二个矩形未完全包含第三个矩形。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.geom.Rectangle;

    public class RectangleExample extends Sprite {

        public function RectangleExample() {
            var firstRect:Rectangle = new Rectangle();
            trace(firstRect);  // (x=0, y=0, w=0, h=0)
            var secondRect:Rectangle = new Rectangle(1, 3, 11, 13);
            trace(secondRect); // (x=1, y=3, w=11, h=13)
            var thirdRect:Rectangle = new Rectangle(5, 8, 17, 19);
            trace(thirdRect);  // (x=5, y=8, w=17, h=19)
            var isContained:Boolean = secondRect.containsRect(thirdRect);
            trace(isContained); // false
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/scrollRect"><linktext>flash.display.DisplayObject.scrollRect</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.text.xml#TextField/getCharBoundaries()"><linktext>flash.text.TextField.getCharBoundaries()</linktext></link><link href="flash.geom.xml#Transform/pixelBounds"><linktext>flash.geom.Transform.pixelBounds</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>flash.display.Sprite.startDrag()</linktext></link><link href="flash.printing.xml#PrintJob/addPage()"><linktext>flash.printing.PrintJob.addPage()</linktext></link></related-links><apiConstructor id="flash.geom:Rectangle:Rectangle"><apiName>Rectangle</apiName><shortdesc>
	创建一个新 Rectangle 对象，其左上角由 x 和 y 参数指定，并具有指定的 width 和 height 参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a new Rectangle with with specific parameters.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 10, 50, 100);
	trace(rect.toString()); // (x=5, y=10, w=50, h=100)
	</listing>
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>矩形左上角的 <i>x</i> 坐标。
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>矩形左上角的 <i>y</i> 坐标。
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>矩形的宽度（以像素为单位）。
	</apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>矩形的高度（以像素为单位）。
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>创建一个新 Rectangle 对象，其左上角由 x 和 y 参数指定，并具有指定的宽度和高度。
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	创建一个新 Rectangle 对象，其左上角由 <codeph>x</codeph> 和 <codeph>y</codeph> 参数指定，并具有指定的 <codeph>width</codeph> 和 <codeph>height</codeph> 参数。如果调用此函数时不使用任何参数，将创建一个 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性均设置为 0 的矩形。
	
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiConstructor><apiOperation id="flash.geom:Rectangle:clone"><apiName>clone</apiName><shortdesc>
	返回一个新的 Rectangle 对象，其 x、y、width 和 height 属性的值与原始 Rectangle 对象的对应值相同。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates the <code>clone</code> member.
	<listing version="2.0">
	import flash.geom.Rectangle;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	var shadow:Rectangle = rect.clone();
	shadow.offset(5, 5);
	trace(rect); // (x=1, y=2, w=4, h=8)
	trace(shadow); // (x=6, y=7, w=4, h=8)
	</listing>

	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>新的 Rectangle 对象，其 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性的值与原始 Rectangle 对象的对应值相同。
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>返回此 Rectangle 对象的副本。
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	返回一个新的 Rectangle 对象，其 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性的值与原始 Rectangle 对象的对应值相同。
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:contains"><apiName>contains</apiName><shortdesc>
	确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Do the coordinates fall inside of the Rectangle?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(10, 10, 50, 50);
	var doesContain_1:Boolean = rect.contains(59, 59);
	trace(doesContain_1); // true
	var doesContain_2:Boolean = rect.contains(10, 10);
	trace(doesContain_2); // true
	var doesContain_3:Boolean = rect.contains(60, 60);
	trace(doesContain_3); // false
	</listing>

	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果 Rectangle 对象包含指定的点，则值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>点的 <i>x</i> 坐标（水平位置）。  
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>点的 <i>y</i> 坐标（垂直位置）。
	</apiDesc></apiParam><apiTipTexts><apiTipText>确定指定的点是否包含在矩形区域内。
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:containsPoint"><apiName>containsPoint</apiName><shortdesc>
	确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Do the specified Points fall inside of the Rectangle?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(10, 10, 50, 50);
	var containsPoint_1:Boolean = rect.containsPoint(new Point(10, 10));
	trace(containsPoint_1); // true
	var containsPoint_2:Boolean = rect.containsPoint(new Point(59, 59));
	trace(containsPoint_2); // true
	var containsPoint_3:Boolean = rect.containsPoint(new Point(60, 60));
	trace(containsPoint_3); // false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果 Rectangle 对象包含指定的点，则值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>用其 <i>x</i> 和 <i>y</i> 坐标表示的点。  
	</apiDesc></apiParam><apiTipTexts><apiTipText>确定指定的点是否包含在由此 Rectangle 对象（此对象将 Point 对象用作参数）定义的矩形区域内。
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。此方法与 <codeph>Rectangle.contains()</codeph> 方法类似，只不过它采用 Point 对象作为参数。
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/contains()"><linktext>contains()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:containsRect"><apiName>containsRect</apiName><shortdesc>
	确定此 Rectangle 对象内是否包含由 rect 参数指定的 Rectangle 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>A Rectangle is said to contain another if that second 
	Rectangle falls entirely within the boundaries of the first.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rectA:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectB:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectC:Rectangle = new Rectangle(10, 10, 51, 51);
	var rectD:Rectangle = new Rectangle(15, 15, 45, 45);
	var rectAContainsB:Boolean = rectA.containsRect(rectB); // true
	var rectAContainsC:Boolean = rectA.containsRect(rectC); // false
	var rectAContainsD:Boolean = rectA.containsRect(rectD); // true
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果此 Rectangle 对象包含您指定的 Rectangle 对象，则返回 <codeph>true</codeph> 值，否则返回 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>所检查的 Rectangle 对象。
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>确定此 Rectangle 对象内是否包含由 rect 参数指定的 Rectangle 对象。
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	确定此 Rectangle 对象内是否包含由 <codeph>rect</codeph> 参数指定的 Rectangle 对象。如果一个 Rectangle 对象完全在另一个 Rectangle 的边界内，我们说第二个 Rectangle 包含第一个 Rectangle。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:equals"><apiName>equals</apiName><shortdesc>
	确定在 toCompare 参数中指定的对象是否等于此 Rectangle 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Even though the method signature only expects an abstract Object
	only other Rectangle instances will ever be treated as equal.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 100);
	var nonRect:Object = new Object();
	nonRect.x = 0;
	nonRect.y = 0;
	nonRect.width = 50;
	nonRect.height = 100;
	trace(rect_1.equals(nonRect));
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果对象具有与此 Rectangle 对象完全相同的 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性值，则返回 <codeph>true</codeph> 值，否则返回 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>要与此 Rectangle 对象进行比较的矩形。
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>确定在 toCompare 参数中指定的对象是否等于此 Rectangle 对象。
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	确定在 <codeph>toCompare</codeph> 参数中指定的对象是否等于此 Rectangle 对象。此方法将某个对象的 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性与此 Rectangle 对象所对应的相同属性进行比较。
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:inflate"><apiName>inflate</apiName><shortdesc>
	按指定量增加 Rectangle 对象的大小（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and increase its <code>width</code> by 16 ~~ 2 (32) and it's <code>height</code> by 32 ~~ 2 (64)
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.toString()); // (x=1, y=2, w=4, h=8)
	rect.inflate(16, 32);
	trace(rect.toString()); // (x=-15, y=-30, w=36, h=72)	
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Rectangle 对象横向增加的值。下列等式用于计算矩形的新宽度和位置：
	
	<codeblock>
	x -= dx;
	width += 2 ~~ dx;
	</codeblock>
	
	</apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Rectangle 纵向增加的值。下列等式用于计算矩形的新高度和位置：
	
	<codeblock>
	y -= dy;
	height += 2 ~~ dy;
	</codeblock>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	按指定量增加 Rectangle 对象的大小（以像素为单位）。保持 Rectangle 对象的中心点不变，使用 <codeph>dx</codeph> 值横向增加它的大小，使用 <codeph>dy</codeph> 值纵向增加它的大小。
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:inflatePoint"><apiName>inflatePoint</apiName><shortdesc>
	 增加 Rectangle 对象的大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and inflate it by the <i>x</i> <i>horizontal</i> and <i>y</i> <i>vertical</i> amounts found in Point
	 
	 <listing version="2.0">
	 import flash.geom.~~;
	 var rect:Rectangle = new Rectangle(0, 0, 2, 5);
	 var myPoint:Point = new Point(2, 2);
	 rect.inflatePoint(myPoint);
	 trace(rect.toString()); // (x=-2, y=-2, w=6, h=9)
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>此 Point 对象的 <codeph>x</codeph> 属性用于增加 Rectangle 对象的水平尺寸。<codeph>y</codeph> 属性用于增加 Rectangle 对象的垂直尺寸。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>增加将 Point 对象用作参数的 Rectangle 对象的大小。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 增加 Rectangle 对象的大小。此方法与 <codeph>Rectangle.inflate()</codeph> 方法类似，只不过它采用 Point 对象作为参数。
	 
	  <p>下面的两个代码示例产生相同的结果：</p>
	 
	 <codeblock platform="actionscript">
	 var rect1:Rectangle = new Rectangle(0,0,2,5);
	 rect1.inflate(2,2)
	 </codeblock>
	 
	 <codeblock platform="actionscript">
	 var rect1:Rectangle = new Rectangle(0,0,2,5);
	 var pt1:Point = new Point(2,2);
	 rect1.inflatePoint(pt1)
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var rect1 = new air.Rectangle(0,0,2,5);
	 rect1.inflate(2,2)
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var rect1 = new air.Rectangle(0,0,2,5);
	 var pt1 = new air.Point(2,2);
	 rect1.inflatePoint(pt1)
	 </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:intersection"><apiName>intersection</apiName><shortdesc>
	如果在 toIntersect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>What area overlaps <code>rect_1</code> between <code>rect_2</code>?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 50);
	var rect_2:Rectangle = new Rectangle(25, 25, 100, 100);
	var intersectingArea:Rectangle = rect_1.intersection(rect_2);
	trace(intersectingArea.toString()); // (x=25, y=25, w=25, h=25)
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>等于交集区域的 Rectangle 对象。如果该矩形不相交，则此方法返回一个空的 Rectangle 对象；即，其 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性均设置为 0 的矩形。
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>toIntersect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>要对照比较以查看其是否与此 Rectangle 对象相交的 Rectangle 对象。
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>返回交集区域。
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	如果在 <codeph>toIntersect</codeph> 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。如果矩形不相交，则此方法返回一个空的 Rectangle 对象，其属性设置为 0。
	
    <p><adobeimage alt="生成的相交矩形。" href="../../images/rectangle_intersect.jpg"/></p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:intersects"><apiName>intersects</apiName><shortdesc>
	确定在 toIntersect 参数中指定的对象是否与此 Rectangle 对象相交。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Does <code>rect_1</code> intersect with <code>rect_2</code>?
	
	<listing version="2.0">
	import flash.geom.~~;
	var rectA:Rectangle = new Rectangle(10, 10, 50, 50);
	var rectB:Rectangle = new Rectangle(59, 59, 50, 50);
	var rectC:Rectangle = new Rectangle(60, 60, 50, 50);
	var rectAIntersectsB:Boolean = rectA.intersects(rectB);
	var rectAIntersectsC:Boolean = rectA.intersects(rectC);
	trace(rectAIntersectsB); // true
	trace(rectAIntersectsC); // false
	
	var firstPixel:Rectangle = new Rectangle(0, 0, 1, 1);
	var adjacentPixel:Rectangle = new Rectangle(1, 1, 1, 1);
	var pixelsIntersect:Boolean = firstPixel.intersects(adjacentPixel);
	trace(pixelsIntersect); // false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果指定的对象与此 Rectangle 对象相交，则返回 <codeph>true</codeph> 值，否则返回 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toIntersect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>要与此 Rectangle 对象比较的 Rectangle 对象。 
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>确定在 toIntersect 参数中指定的对象是否与此 Rectangle 对象相交。
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	确定在 <codeph>toIntersect</codeph> 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性，以查看它是否与此 Rectangle 对象相交。
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:isEmpty"><apiName>isEmpty</apiName><shortdesc>
	确定此 Rectangle 对象是否为空。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a non-empty Rectangle and make it become empty.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.isEmpty()); // false
	rect.width = 0;
	trace(rect.isEmpty()); // true
	rect.width = 4;
	trace(rect.isEmpty()); // false
	rect.height = 0;
	trace(rect.isEmpty()); // true
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果 Rectangle 对象的宽度或高度小于等于 0，则返回 <codeph>true</codeph> 值，否则返回 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	确定此 Rectangle 对象是否为空。 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:offset"><apiName>offset</apiName><shortdesc>
	 按指定量调整 Rectangle 对象的位置（由其左上角确定）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and offset it's <i>x</i> and <i>y</i> values by 5 and 10 respectively
	 
	 <listing version="2.0">
	 import flash.geom.~~;
	 var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	 rect.offset(16, 32);
	 trace(rect.toString()); // (x=17, y=34, w=4, h=8)
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>将 Rectangle 对象的 <i>x</i> 值移动此数量。
	 </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>将 Rectangle 对象的 <i>y</i> 值移动此数量。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>调整 Rectangle 对象的位置。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 按指定量调整 Rectangle 对象的位置（由其左上角确定）。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Rectangle:offsetPoint"><apiName>offsetPoint</apiName><shortdesc>
	 将 Point 对象用作参数来调整 Rectangle 对象的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Offset a Rectangle by using the values found in a Point
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	var myPoint:Point = new Point(16, 32);
	rect.offsetPoint(myPoint);
	trace(rect.toString()); // (x=17, y=34, w=4, h=8)
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>要用于偏移此 Rectangle 对象的 Point 对象。
	 
	</apiDesc></apiParam><apiTipTexts><apiTipText>将 Point 对象用作参数来调整 Rectangle 对象的位置。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 将 Point 对象用作参数来调整 Rectangle 对象的位置。此方法与 <codeph>Rectangle.offset()</codeph> 方法类似，只不过它采用 Point 对象作为参数。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:setEmpty"><apiName>setEmpty</apiName><shortdesc>
	将 Rectangle 对象的所有属性设置为 0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a non-empty Rectangle and make it empty.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 10, 50, 100);
	trace(rect.isEmpty()); // false
	rect.setEmpty();
	trace(rect.isEmpty()); // true
	</listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>将所有属性设置为 0。
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	将 Rectangle 对象的所有属性设置为 0。如果 Rectangle 对象的宽度或高度小于或等于 0，则该对象为空。
	
	<p> 此方法将 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性设置为 0。</p>
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:toString"><apiName>toString</apiName><shortdesc>
	生成并返回一个字符串，该字符串列出 Rectangle 对象的水平位置和垂直位置以及高度和宽度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Concatenate a String representation of <code>rect_1</code> with some helpful 
	debugging text.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(0, 0, 50, 100);
	trace("Rectangle 1 : " + rect_1.toString()); // Rectangle 1 : (x=0, y=0, w=50, h=100)
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个字符串，它列出了 Rectangle 对象的下列各个属性的值：<codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph>。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	生成并返回一个字符串，该字符串列出 Rectangle 对象的水平位置和垂直位置以及高度和宽度。
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Rectangle:union"><apiName>union</apiName><shortdesc> 
	 通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a new Rectangle out of the Union of two others.
	<p>For example, consider a rectangle with properties <code>x=20</code>, <code>y=50</code>, <code>width=60</code>, and 
	<code>height=30</code> (20, 50, 60, 30) and a second rectangle with properties (150, 130, 50, 30). 
	The union of these two rectangles would be a larger rectangle encompassing the two rectangles 
	with the properties (20, 50, 180, 110).</p>
	<listing version="2.0">
	import flash.geom.~~;
	var rect_1:Rectangle = new Rectangle(20, 50, 60, 30);
	var rect_2:Rectangle = new Rectangle(150, 130, 50, 30);
	var combined:Rectangle = rect_1.union(rect_2);
	trace(combined.toString()); // (x=20, y=50, w=180, h=110)
	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>充当两个矩形的联合的新 Rectangle 对象。
	
	</apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>toUnion</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>要添加到此 Rectangle 对象的 Rectangle 对象。
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>将两个矩形添加到一起以创建新的 Rectangle 对象。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc> 
	 通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。
	 
    <p><adobeimage alt="生成的联合矩形。" href="../../images/rectangle_union.jpg"/></p>
	<p><b>注意：</b><codeph>union()</codeph> 方法忽略高度或宽度值为 <codeph>0</codeph> 的矩形，如：<codeph>var rect2:Rectangle = new Rectangle(300,300,50,0);</codeph></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Rectangle:height"><apiName>height</apiName><shortdesc>
	矩形的高度（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>width</i> property 
	from 10 to 20. Notice that <code>rect.right</code> is also
	changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.width = 20;
	trace(rect.width); // 20
	trace(rect.right); // 25
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>矩形的高度，以像素为单位。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	矩形的高度（以像素为单位）。更改 Rectangle 对象的 <codeph>height</codeph> 值对 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>width</codeph> 属性没有影响。
	
    <p><adobeimage alt="显示 location 和 measurement 属性的矩形图像。" href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:width"><apiName>width</apiName><shortdesc>
	矩形的宽度（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Rectangle object and change its <code>width</code> property 
	from 10 to 20. Notice that <code>rect.right</code> also
	changes.

	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.width = 20;
	trace(rect.width); // 20
	trace(rect.right); // 25
	</listing>
    </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>矩形的宽度。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	矩形的宽度（以像素为单位）。更改 Rectangle 对象的 <codeph>width</codeph> 值对 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>height</codeph> 属性没有影响。
	
	<p><adobeimage alt="显示 location 和 measurement 属性的矩形图像。" href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:x"><apiName>x</apiName><shortdesc>
	矩形左上角的 x 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates an empty Rectangle and sets its <i>x</i> property 
	to 10. Notice that <code>rect.left</code> is also changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.x); // 0
	trace(rect.left); // 0
	rect.x = 10;
	trace(rect.x); // 10
	trace(rect.left); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>矩形左上角的 x 坐标。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	矩形左上角的 <i>x</i> 坐标。更改 Rectangle 对象的 <codeph>x</codeph> 属性的值对 <codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性没有影响。 
	
	<p><codeph>x</codeph> 属性的值等于 <codeph>left</codeph> 属性的值。</p>
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/left"><linktext>left</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:y"><apiName>y</apiName><shortdesc>
	矩形左上角的 y 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates an empty Rectangle and sets its <i>y</i> property
	to 10. Notice that <code>rect.top</code> is also changed.
	
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.y); // 0
	trace(rect.top); // 0
	rect.y = 10;
	trace(rect.y); // 10
	trace(rect.top); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>左上角的 y 坐标。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	矩形左上角的 <i>y</i> 坐标。更改 Rectangle 对象的 <codeph>y</codeph> 属性的值对 <codeph>x</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性没有影响。
	
	<p><codeph>y</codeph> 属性的值等于 <codeph>top</codeph> 属性的值。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link><link href="flash.geom.xml#Rectangle/top"><linktext>top</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:bottom:get"><apiName>bottom</apiName><shortdesc>
	y 和 height 属性的和。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>bottom</i> property 
	from 15 to 30. Notice that <code>rect.height</code> is also
	changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.height); // 10
	trace(rect.bottom); // 15
	rect.bottom = 30;
	trace(rect.height); // 25
	trace(rect.bottom); // 30
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>y 和 height 属性的和。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	<codeph>y</codeph> 和 <codeph>height</codeph> 属性的和。
	
    <p><adobeimage alt="显示 location 和 measurement 属性的矩形图像。" href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:bottomRight:get"><apiName>bottomRight</apiName><shortdesc>
	由 right 和 bottom 属性的值确定的 Rectangle 对象的右下角的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Get the Rectangle <code>bottomRight</code> property as a Point object.
	<listing version="2.0">
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	trace(rect.bottom); // 5
	trace(rect.right); // 10
	var myBottomRight:Point = rect.bottomRight;
	trace(myBottomRight.x); // 5
	trace(myBottomRight.y); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>由 right 和 bottom 属性确定的 Rectangle 对象的右下角的位置。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	由 <codeph>right</codeph> 和 <codeph>bottom</codeph> 属性的值确定的 Rectangle 对象的右下角的位置。
	
    <p><adobeimage alt="显示 location 和 measurement 属性的矩形图像。" href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:left:get"><apiName>left</apiName><shortdesc>
	矩形左上角的 x 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Change the <i>left</i> property and notice that 
	<code>rect.x</code> is also changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.left); // 0
	trace(rect.x); // 0
	rect.left = 10;
	trace(rect.left); // 10
	trace(rect.x); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>矩形左上角的 x 坐标。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	矩形左上角的 <i>x</i> 坐标。更改 Rectangle 对象的 <codeph>left</codeph> 属性对 <codeph>y</codeph> 和 <codeph>height</codeph> 属性没有影响。但是，它会影响 <codeph>width</codeph> 属性，而更改 <codeph>x</codeph> 值<i>不会</i>影响 <codeph>width</codeph> 属性。
	
	<p><codeph>left</codeph> 属性的值等于 <codeph>x</codeph> 属性的值。</p>
	
	
    <p><adobeimage alt="显示 location 和 measurement 属性的矩形图像。" href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:right:get"><apiName>right</apiName><shortdesc>
	x 和 width 属性的和。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create a Rectangle and change its <i>right</i> property 
	from 15 to 30. Notice that <code>rect.width</code> is also
	changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle(5, 5, 10, 10);
	trace(rect.width); // 10
	trace(rect.right); // 15
	rect.right = 30;
	trace(rect.width); // 25
	trace(rect.right); // 30
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>x 和 width 属性的和。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	<codeph>x</codeph> 和 <codeph>width</codeph> 属性的和。
	
    <p><adobeimage alt="显示 location 和 measurement 属性的矩形图像。" href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:size:get"><apiName>size</apiName><shortdesc>
	Rectangle 对象的大小，该对象表示为具有 width 和 height 属性的值的 Point 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new Rectangle, retrieves it's <code>size</code>,
	changes the <code>size</code> and sets the new values on the Rectangle instance.
	It is critical to remember that the <code>Point</code> object used by <code>size</code>
	uses x and y values to represent the <code>width</code> and <code>height</code> properties
	of the Rectangle.
	<listing version="2.0">
	import flash.geom.Rectangle;
	import flash.geom.Point;
	var rect:Rectangle = new Rectangle(1, 2, 4, 8);
	
	var size:Point = rect.size;
	trace(size.x); // 4;
	trace(size.y); // 8;
	
	size.x = 16;
	size.y = 32;
	rect.size = size;
	trace(rect.x); // 1
	trace(rect.y); // 2
	trace(rect.width); // 16
	trace(rect.height); // 32
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>以具有宽度值和高度值的 Point 对象形式表示的 Rectangle 对象的大小。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Rectangle 对象的大小，该对象表示为具有 <codeph>width</codeph> 和 <codeph>height</codeph> 属性的值的 Point 对象。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:top:get"><apiName>top</apiName><shortdesc>
	矩形左上角的 y 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Change the <i>top</i> property and notice that 
	<code>rect.y</code> is also changed.
	<listing version="2.0">
	import flash.geom.~~;
	var rect:Rectangle = new Rectangle();
	trace(rect.top); // 0
	trace(rect.y); // 0
	rect.top = 10;
	trace(rect.top); // 10
	trace(rect.y); // 10
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>矩形左上角的 y 坐标。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	矩形左上角的 <i>y</i> 坐标。更改 Rectangle 对象的 <codeph>top</codeph> 属性对 <codeph>x</codeph> 和 <codeph>width</codeph> 属性没有影响。但是，它会影响 <codeph>height</codeph> 属性，而更改 <codeph>y</codeph> 值<i>不会</i>影响 <codeph>height</codeph> 属性。
	
	<p><codeph>top</codeph> 属性的值等于 <codeph>y</codeph> 属性的值。</p>
	
    <p><adobeimage alt="显示 location 和 measurement 属性的矩形图像。" href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link><link href="flash.geom.xml#Rectangle/width"><linktext>width</linktext></link><link href="flash.geom.xml#Rectangle/height"><linktext>height</linktext></link></related-links></apiValue><apiValue id="flash.geom:Rectangle:topLeft:get"><apiName>topLeft</apiName><shortdesc>
	由该点的 x 和 y 坐标确定的 Rectangle 对象左上角的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Get the Rectangle <code>topLeft</code> property as a Point object.
	<listing version="2.0">
	var rect:Rectangle = new Rectangle(5, 15);
	var myTopLeft:Point = rect.topLeft;
	trace(myTopLeft.x); // 5;
	trace(myTopLeft.y); // 15;
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiTipTexts><apiTipText>由该点的 x 和 y 值确定的 Rectangle 对象左上角的位置。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	由该点的 <i>x</i> 和 <i>y</i> 坐标确定的 Rectangle 对象左上角的位置。
	
    <p><adobeimage alt="显示 location 和 measurement 属性的矩形图像。" href="../../images/rectangle.jpg"/></p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link><link href="flash.geom.xml#Rectangle/x"><linktext>x</linktext></link><link href="flash.geom.xml#Rectangle/y"><linktext>y</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:ColorTransform"><apiName>ColorTransform</apiName><shortdesc>
 可使用 ColorTransform 类调整显示对象的颜色值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 可使用 ColorTransform 类调整显示对象的颜色值。可以将颜色调整或<i>颜色转换</i>应用于所有四种通道：红色、绿色、蓝色和 Alpha 透明度。
 
 <p>当 ColorTransform 对象应用于显示对象时，将按如下方法为每个颜色通道计算新值：</p>
 
 <ul>
 <li>新红色值 = (旧红色值 * <codeph>redMultiplier</codeph>) + <codeph>redOffset</codeph></li>
 <li>新绿色值 = (旧绿色值 * <codeph>greenMultiplier</codeph>) + <codeph>greenOffset</codeph></li>
 <li>新蓝色值 = (旧蓝色值 * <codeph>blueMultiplier</codeph>) + <codeph>blueOffset</codeph></li>
 <li>新 Alpha 值 = (旧 Alpha 值 * <codeph>alphaMultiplier</codeph>) + <codeph>alphaOffset</codeph></li>
 </ul>
 
 <p>如果计算后任何一个颜色通道值大于 255，则该值将被设置为 255。如果该值小于 0，它将被设置为 0。</p>
 
 <p>可以通过下列方式使用 ColorTransform 对象：</p>
 
 <ul>
 
 	<li>在 BitmapData 类的 <codeph>colorTransform()</codeph> 方法的 <codeph>colorTransform</codeph> 参数中</li>
 
 	<li>作为 Transform 对象（此对象可以用作显示对象的 <codeph>transform</codeph> 属性）的 <codeph>colorTransform</codeph> 属性</li>
 
 </ul>
 
 <p>必须使用 <codeph>new ColorTransform()</codeph> 构造函数创建 ColorTransform 对象后，才能调用 ColorTransform 对象的方法。</p>
 
 <p>颜色转换不会应用于影片剪辑（如加载的 SWF 对象）的背景色，它们仅应用于附加到影片剪辑的图形和元件。</p>
 
 </apiDesc><example conref="examples\ColorTransformExample.as"> 下面的示例使用 TransformExample 类在以渐变图案填充的正方形中创建简单的 sprite。每次用户单击正方形时，应用程序都将转换正方形 sprite 的颜色，同时添加到红色通道并加亮蓝色通道。这是由以下步骤完成的：
 
 <ol>
     <li>构造函数创建一个新的 sprite 对象 <codeph>target</codeph>。</li>
 
     <li><codeph>CustomButton()</codeph> 构造函数调用 <codeph>draw()</codeph> 方法，该方法在 sprite 中绘制一个渐变正方形。</li>
 
     <li><codeph>CustomButton()</codeph> 构造函数为 sprite 添加 click 事件侦听器，该侦听器由 <codeph>clickHandler()</codeph> 方法处理。  </li>
 
     <li>在 <codeph>clickHandler()</codeph> 方法中，两个属性被设置为当前颜色转换的 <codeph>redOffset</codeph> 和 <codeph>blueOffset</codeph> 属性。将每项的值调整 25。然后修改正方形 sprite 的 <codeph>transform.colorTransform</codeph> 属性，以使用新的偏移量值。每次用户单击正方形时，对 <codeph>clickHandler()</codeph> 方法的调用都将修改正方形的颜色，方法是增大其红色值并减小其蓝色值。  </li>
  </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.GradientType;
    import flash.geom.ColorTransform;
    import flash.events.MouseEvent;

    public class ColorTransformExample extends Sprite {
        public function ColorTransformExample() {
            var target:Sprite = new Sprite();
            draw(target);
            addChild(target);
            target.useHandCursor = true;
            target.buttonMode = true;
            target.addEventListener(MouseEvent.CLICK, clickHandler)
        }
        public function draw(sprite:Sprite):void {
            var red:uint = 0xFF0000;
            var green:uint = 0x00FF00;
            var blue:uint = 0x0000FF;
            var size:Number = 100;
            sprite.graphics.beginGradientFill(GradientType.LINEAR, [red, blue, green], [1, 0.5, 1], [0, 200, 255]);
            sprite.graphics.drawRect(0, 0, 100, 100);
        }
        public function clickHandler(event:MouseEvent):void {
            var rOffset:Number = transform.colorTransform.redOffset + 25;
            var bOffset:Number = transform.colorTransform.redOffset - 25;
            this.transform.colorTransform = new ColorTransform(1, 1, 1, 1, rOffset, 0, bOffset, 0);
        }
    }
}    
</codeblock></example></apiClassifierDetail><related-links><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.display.xml#BitmapData/colorTransform()"><linktext>flash.display.BitmapData.colorTransform()</linktext></link></related-links><apiConstructor id="flash.geom:ColorTransform:ColorTransform"><apiName>ColorTransform</apiName><shortdesc>
	 用指定的颜色通道值和 Alpha 值为显示对象创建 ColorTransform 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new ColorTransform, constructor
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>红色乘数的值，在 0 到 1 范围内。
	 </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>绿色乘数的值，在 0 到 1 范围内。
	 </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>蓝色乘数的值，在 0 到 1 范围内。
	 </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Alpha 透明度乘数的值，在 0 到 1 范围内。
	 </apiDesc></apiParam><apiParam><apiItemName>redOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>红色通道值的偏移量，在 -255 到 255 范围内。
	 </apiDesc></apiParam><apiParam><apiItemName>greenOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>绿色通道值的偏移量，在 -255 到 255 范围内。
	 </apiDesc></apiParam><apiParam><apiItemName>blueOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>蓝色通道值的偏移量，在 -255 到 255 范围内。
	 </apiDesc></apiParam><apiParam><apiItemName>alphaOffset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Alpha 透明度通道值的偏移量，在 -255 到 255 范围内。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>为显示对象创建 ColorTransform 对象。
	 
	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 用指定的颜色通道值和 Alpha 值为显示对象创建 ColorTransform 对象。 
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:ColorTransform:concat"><apiName>concat</apiName><shortdesc>
	 将 second 参数指定的 ColorTranform 对象与当前 ColorTransform 对象连接，并将当前对象设置为结果，即两个颜色转换的相加组合。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example concatenates the ColorTransform object <code>colorTrans_2</code>
	to <code>colorTrans_1</code> resulting in a full red offset combined with a .5 alpha multiplier.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans_1:ColorTransform = new ColorTransform(1, 1, 1, 1, 255, 0, 0, 0);
	trace(colorTrans_1);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=1, redOffset=255, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	var colorTrans_2:ColorTransform = new ColorTransform(1, 1, 1, .5, 0, 0, 0, 0);
	trace(colorTrans_2);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=0.5, redOffset=0, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	colorTrans_1.concat(colorTrans_2);
	trace(colorTrans_1);		// (redMultiplier=1, greenMultiplier=1, blueMultiplier=1, alphaMultiplier=0.5, redOffset=255, greenOffset=0, blueOffset=0, alphaOffset=0)
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans_1;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>要与当前 ColorTransform 对象合并的 ColorTransform 对象。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将 <codeph>second</codeph> 参数指定的 ColorTranform 对象与当前 ColorTransform 对象连接，并将当前对象设置为结果，即两个颜色转换的相加组合。在应用级联的 ColorTransform 对象时，其效果与在<i>原始</i> 颜色转换后应用 <codeph>second</codeph> 颜色转换的效果相同。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:ColorTransform:toString"><apiName>toString</apiName><shortdesc>
	 设置字符串格式并将其返回，该字符串描述 ColorTransform 对象的所有属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and calls its <code>toSting()</code> method.  This method results in a string with the format
	(redMultiplier=RM, greenMultiplier=GM, blueMultiplier=BM, alphaMultiplier=AM, redOffset=RO, greenOffset=GO, blueOffset=BO, alphaOffset=AO).
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
 	var colorTrans:ColorTransform = new ColorTransform(1, 2, 3, 4, -255, -128, 128, 255);
 	trace(colorTrans.toString());		// (redMultiplier=1, greenMultiplier=2, blueMultiplier=3, alphaMultiplier=4, redOffset=-255, greenOffset=-128, blueOffset=128, alphaOffset=255)
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>用于列出 ColorTransform 对象的所有属性的字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 设置字符串格式并将其返回，该字符串描述 ColorTransform 对象的所有属性。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:ColorTransform:alphaMultiplier"><apiName>alphaMultiplier</apiName><shortdesc>
	 与 Alpha 透明度通道值相乘的十进制值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>alphaMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	import flash.geom.Transform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.alphaMultiplier);		// 1
	
	colorTrans.alphaMultiplier = .5;	
	trace(colorTrans.alphaMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 与 Alpha 透明度通道值相乘的十进制值。
	 
	 <p>如果您使用 DisplayObject 实例的 <codeph>alpha</codeph> 属性直接设置显示对象的 Alpha 透明度值，它将影响该显示对象的 <codeph>transform.colorTransform</codeph> 属性的 <codeph>alphaMultiplier</codeph> 属性的值。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/alpha"><linktext>flash.display.DisplayObject.alpha</linktext></link></related-links></apiValue><apiValue id="flash.geom:ColorTransform:alphaOffset"><apiName>alphaOffset</apiName><shortdesc>
	 -255 到 255 之间的数字，它先与 alphaMultiplier 值相乘，再与 Alpha 透明度通道值相加。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>alphaOffset</code> from 0 to -128.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.alphaOffset);			// 0
	
	colorTrans.alphaOffset = -128;
	trace(colorTrans.alphaOffset);			// -128
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>-255 到 255 之间的数字，它先与 alphaMultiplier 值相乘，再与 Alpha 透明度通道值相加。
   	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 -255 到 255 之间的数字，它先与 <codeph>alphaMultiplier</codeph> 值相乘，再与 Alpha 透明度通道值相加。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:blueMultiplier"><apiName>blueMultiplier</apiName><shortdesc>
	 与蓝色通道值相乘的十进制值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>blueMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.blueMultiplier);		// 1
	
	colorTrans.blueMultiplier = .5;
	trace(colorTrans.blueMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x0000FF);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 与蓝色通道值相乘的十进制值。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:blueOffset"><apiName>blueOffset</apiName><shortdesc>
	 -255 到 255 之间的数字，它先与 blueMultiplier 值相乘，再与蓝色通道值相加。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>blueOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.blueOffset);			// 0
	
	colorTrans.blueOffset = 255;
	trace(colorTrans.blueOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>-255 到 255 之间的数字，它先与 blueMultiplier 值相乘，再与蓝色通道值相加。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 -255 到 255 之间的数字，它先与 <codeph>blueMultiplier</codeph> 值相乘，再与蓝色通道值相加。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:greenMultiplier"><apiName>greenMultiplier</apiName><shortdesc>
	 与绿色通道值相乘的十进制值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>greenMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.greenMultiplier);		// 1
	
	colorTrans.greenMultiplier = .5;
	trace(colorTrans.greenMultiplier);		// .5
	
	var rect:MovieClip = createRectangle(20, 80, 0x00FF00);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 与绿色通道值相乘的十进制值。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:greenOffset"><apiName>greenOffset</apiName><shortdesc>
	 -255 到 255 之间的数字，它先与 greenMultiplier 值相乘，再与绿色通道值相加。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>greenOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.greenOffset);			// 0
	
	colorTrans.redOffset = 255;
	trace(colorTrans.greenOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>-255 到 255 之间的数字，它先与 greenMultiplier 值相乘，再与绿色通道值相加。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 -255 到 255 之间的数字，它先与 <codeph>greenMultiplier</codeph> 值相乘，再与绿色通道值相加。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:redMultiplier"><apiName>redMultiplier</apiName><shortdesc>
	 与红色通道值相乘的十进制值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>redMultiplier</code> from 1 to .5.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
 	var colorTrans:ColorTransform = new ColorTransform();
 	trace(colorTrans.redMultiplier);		// 1
 	
 	colorTrans.redMultiplier = .5;
 	trace(colorTrans.redMultiplier);		// .5
 	
 	var rect:MovieClip = createRectangle(20, 80, 0xFF0000);
 	var trans:Transform = new Transform(rect);
 	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 与红色通道值相乘的十进制值。 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:redOffset"><apiName>redOffset</apiName><shortdesc>
	 -255 到 255 之间的数字，它先与 redMultiplier 值相乘，再与红色通道值相加。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates the ColorTransform object <code>colorTrans</code>
	and adjusts its <code>redOffset</code> from 0 to 255.
	<listing version="2.0">
	import flash.geom.ColorTransform;
	
	var colorTrans:ColorTransform = new ColorTransform();
	trace(colorTrans.redOffset);			// 0
	
	colorTrans.redOffset = 255;
	trace(colorTrans.redOffset);			// 255
	
	var rect:MovieClip = createRectangle(20, 80, 0x000000);
	var trans:Transform = new Transform(rect);
	trans.colorTransform = colorTrans;
	
	function createRectangle(width:Number, height:Number, color:Number, scope:MovieClip):MovieClip {
		scope = (scope == undefined) ? this : scope;
		var depth:Number = scope.getNextHighestDepth();
		var mc:MovieClip = scope.createEmptyMovieClip("mc_" + depth, depth);
		mc.beginFill(color);
		mc.lineTo(0, height);
		mc.lineTo(width, height);
		mc.lineTo(width, 0);
		mc.lineTo(0, 0);
		return mc;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>-255 到 255 之间的数字，它先与 redMultiplier 值相乘，再与红色通道值相加。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 -255 到 255 之间的数字，它先与 <codeph>redMultiplier</codeph> 值相乘，再与红色通道值相加。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:ColorTransform:color:get"><apiName>color</apiName><shortdesc>
	 ColorTransform 对象的 RGB 颜色值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>This example sets the RGB color value for the movie clip <code>my_mc</code>.<span class="flashonly"> To see this code work, place a movie clip on the Stage with the instance name <code>my_mc</code>. Then place the following code on Frame 1 in the main Timeline and select Control > Test Movie:</span>
	 <pre>
	 <code>var my_color:Color = new Color(my_mc);</code>
	 <code>my_color.setRGB(0xFF0000); // my_mc turns red</code>
	 </pre>
	  
	  </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 ColorTransform 对象的 RGB 颜色值。
	 
	 <p>设置此属性时，会相应地更改三种颜色的偏移量值（<codeph>redOffset</codeph>、<codeph>greenOffset</codeph> 和 <codeph>blueOffset</codeph>），并将这三个颜色乘数值（<codeph>redMultiplier</codeph>、<codeph>greenMultiplier</codeph> 和 <codeph>blueMultiplier</codeph>）设置为 0。Alpha 透明度乘数和偏移量值不变。</p>
	 
	 <p>在传递此属性的值时，请使用格式 0x <i>RRGGBB</i>。<i>RR</i>、<i>GG</i> 和 <i>BB</i> 均包含两个十六进制数字，这些数字指定每个颜色成分的偏移量。ActionScript 编译器从 0x 获知数字是十六进制值。</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Point"><apiName>Point</apiName><shortdesc>
 Point 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Point 类表示二维坐标系统中的某个位置。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Point 对象表示二维坐标系统中的某个位置，其中 <i>x</i> 表示水平轴，<i>y</i> 表示垂直轴。 
 
 <p>下面的代码在 (0,0) 处创建一个点：</p>
 
 <codeblock platform="actionscript">var myPoint:Point = new Point();</codeblock>
 
 <codeblock platform="javascript">var myPoint = new Point();</codeblock>
 
 <p>以下类的方法和属性使用 Point 对象：</p>
 
 <ul>
 
 <li platform="actionscript">BitmapData</li>
 
 <li platform="actionscript">DisplayObject</li>
 
 <li platform="actionscript">DisplayObjectContainer</li>
 
 <li platform="actionscript">DisplacementMapFilter</li>
 
 <li>NativeWindow</li>
 
 <li platform="actionscript">Matrix</li>
 
 <li>Rectangle</li>
 
 </ul>
 
 <p>您可以使用 <codeph>new Point()</codeph> 构造函数创建 Point 对象。</p>
 
 </apiDesc><example conref="examples\PointExample.as"> 下面的示例使用 PointExample 类在不同的 <i>x,y</i> 坐标处创建多个新 Point 对象，然后使用 <codeph>trace()</codeph> 方法输出各种类方法的结果。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.geom.Point;

    public class PointExample extends Sprite {

        public function PointExample() {
        var point1:Point = new Point();
        trace(point1);  // (x=0, y=0)
        
        var point2:Point = new Point(6, 8);
        trace(point2); // (x=6, y=8)
        
        trace(Point.interpolate(point1, point2, 0.5)); // (x=3, y=4)
        
        trace(Point.distance(point1, point2)); // 10
        
        trace(point1.add(point2)); // (x=6, y=8)
        
        var point3:Point = point2.clone();
        trace(point2.equals(point3)); // true
        
        point3.normalize(2.5);
        trace(point3); // (x=1.5, y=2)
        
        trace(point2.subtract(point3)); // (x=4.5, y=6)
        
        trace(point1.offset(2, 3)); // 
        
        var angle:Number = Math.PI * 2 * (30 / 360); // 30Â°
        trace(Point.polar(4, angle)) // (x=3.464101615137755, y=1.9999999999999998)   
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links><apiConstructor id="flash.geom:Point:Point"><apiName>Point</apiName><shortdesc>
	 创建一个新点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The first example creates <code>point_1</code> with the default constructor.
	 <listing version="2.0">
	 import flash.geom.Point;
	 var point_1:Point = new Point();
	 trace(point_1.x); // 0
	 trace(point_1.y); // 0
	 </listing>
	 The second example creates <code>point_2</code> with the coordinates x = 1 and y = 2.
     <listing version="2.0">
	 import flash.geom.Point;
	 var point_2:Point = new Point(1, 2);
	 trace(point_2.x); // 1
	 trace(point_2.y); // 2
	 </listing>
	 
	  
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>水平坐标。 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>垂直坐标。 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新点。如果不向此方法传递任何参数，则在 (0,0) 处创建一个点。
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:Point:add"><apiName>add</apiName><shortdesc>
      	 将另一个点的坐标添加到此点的坐标以创建一个新点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Point object <code>resultPoint</code> by adding <code>point_2</code> to 
	 <code>point_1</code>.
   	 
   	 <listing version="2.0">
   	 import flash.geom.Point;
   	 var point_1:Point = new Point(4, 8);
   	 var point_2:Point = new Point(1, 2);
   	 var resultPoint:Point = point_1.add(point_2);
   	 trace(resultPoint.toString()); // (x=5, y=10)
   	 </listing>
	 
   	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>新点。
   	 
	 </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>要添加的点。
	 
      	 </apiDesc></apiParam></apiOperationDef><apiDesc>
      	 将另一个点的坐标添加到此点的坐标以创建一个新点。
	 
      	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:clone"><apiName>clone</apiName><shortdesc>
	 创建此 Point 对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a <code>clonedPoint</code> from the values found in 
 	 <code>myPoint</code>.  The <code>clonedPoint</code> contains all the
	 the values from <code>myPoint</code> but is not the same object.
	 
	 <listing version="2.0">
	 import flash.geom.Point;
	 var myPoint:Point = new Point(1, 2);
	 var clonedPoint:Point = myPoint.clone();
	 trace(clonedPoint.x); // 1
	 trace(clonedPoint.y); // 2
	 trace(myPoint.equals(clonedPoint)); // true
	 trace(myPoint === clonedPoint); // false
	 </listing>
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>新的 Point 对象。
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>创建此 Point 对象的副本。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 创建此 Point 对象的副本。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:distance"><apiName>distance</apiName><shortdesc>
	 返回 pt1 和 pt2 之间的距离。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>第一个点和第二个点之间的距离。
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>第一个点。
	 </apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>第二个点。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回 <codeph>pt1</codeph> 和 <codeph>pt2</codeph> 之间的距离。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:equals"><apiName>equals</apiName><shortdesc>
	 确定两个点是否相同。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果该对象与此 Point 对象相同，则为 <codeph>true</codeph> 值，如果不相同，则为 <codeph>false</codeph>。
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>toCompare</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>要比较的点。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 确定两个点是否相同。如果两个点具有相同的 <i>x</i> 和 <i>y</i> 值，则它们是相同的点。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:interpolate"><apiName>interpolate</apiName><shortdesc>
    确定两个指定点之间的点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example locates the interpolated point (<code>interpolatedPoint</code>) half way (50%) between <code>point_1</code> and <code>point_2</code>.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var point_1:Point = new Point(-100, -100);
   	var point_2:Point = new Point(50, 50);
   	var interpolatedPoint:Point = Point.interpolate(point_1, point_2, .5);
   	trace(interpolatedPoint.toString()); // (x=-25, y=-25)
   	</listing> 
	
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>新的内插点。 
   	
   	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>pt1</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>第一个点。
	</apiDesc></apiParam><apiParam><apiItemName>pt2</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>第二个点。
	</apiDesc></apiParam><apiParam><apiItemName>f</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>两个点之间的内插级别。指示新点将位于 <codeph>pt1</codeph> 和 <codeph>pt2</codeph> 连成的直线上的什么位置。如果 <codeph>f</codeph>=1，则返回 <codeph>pt1</codeph>；如果 <codeph>f</codeph>=0，则返回 <codeph>pt2</codeph>。
   	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
    确定两个指定点之间的点。参数 <codeph>f</codeph> 确定新的内插点相对于参数 <codeph>pt1</codeph> 和 <codeph>pt2</codeph> 指定的两个端点所处的位置。参数 <codeph>f</codeph> 的值越接近 <codeph>1.0</codeph>，则内插点就越接近第一个点（参数 <codeph>pt1</codeph>）。参数 <codeph>f</codeph> 的值越接近 0，则内插点就越接近第二个点（参数 <codeph>pt2</codeph>）。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:normalize"><apiName>normalize</apiName><shortdesc>
	将 (0,0) 和当前点之间的线段缩放为设定的长度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example extends the length of the <code>normalizedPoint</code> object from 5 to 10.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var normalizedPoint:Point = new Point(3, 4);
   	trace(normalizedPoint.length); // 5
   	trace(normalizedPoint.toString()); // (x=3, y=4)
   	normalizedPoint.normalize(10);
   	trace(normalizedPoint.length); // 10
   	trace(normalizedPoint.toString()); // (x=6, y=8)
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>标准点。
	
   	</apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>缩放值。例如，如果当前点为 (0,5) 并且您将它规范化为 1，则返回的点位于 (0,1) 处。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	将 (0,0) 和当前点之间的线段缩放为设定的长度。 
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point/length"><linktext>length</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Point:offset"><apiName>offset</apiName><shortdesc>
	 按指定量偏移 Point 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dx</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>水平坐标 <i>x</i> 的偏移量。
	 </apiDesc></apiParam><apiParam><apiItemName>dy</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>垂直坐标 <i>y</i> 的偏移量。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按指定量偏移 Point 对象。<codeph>dx</codeph> 的值将添加到 <i>x</i> 的原始值中以创建新的 <i>x</i> 值。<codeph>dy</codeph> 的值将添加到 <i>y</i> 的原始值中以创建新的 <i>y</i> 值。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:polar"><apiName>polar</apiName><shortdesc>
	将一对极坐标转换为笛卡尔点坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a Point object <code>cartesianPoint</code> from the value of <code>angleInRadians</code>
	and a line length of 5.  The <code>angleInRadians</code> value equal to Math.atan(3/4)
   	is used because of the characteristics of right triangles with sides that 
   	have ratios of 3:4:5.
	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var len:Number = 5;
   	var angleInRadians:Number = Math.atan(3/4);
   	var cartesianPoint:Point = Point.polar(len, angleInRadians);
   	trace(cartesianPoint.toString()); // (x=4, y=3)
   	</listing>
	
	When computers work with transcendental numbers such as pi, some round-off
	error occurs because floating-point arithmetic has only finite precision.
	When you use <code>Math.PI</code>, consider using the <code>Math.round()</code> function, as shown 
	in the following example.
	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var len:Number = 10;
   	var angleInRadians:Number = Math.PI;
    	var cartesianPoint:Point = Point.polar(len, angleInRadians);
   	trace(cartesianPoint.toString()); // should be (x=-10, y=0), but is (x=-10, y=1.22460635382238e-15)
   	trace(Math.round(cartesianPoint.y)); // 0
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>笛卡尔点。
   	
   	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>len</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>极坐标对的长度。
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>极坐标对的角度（以弧度表示）。
   	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	将一对极坐标转换为笛卡尔点坐标。
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Point/length"><linktext>length</linktext></link><link href="#Math/round()"><linktext>Math.round()</linktext></link></related-links></apiOperation><apiOperation id="flash.geom:Point:subtract"><apiName>subtract</apiName><shortdesc>
	从此点的坐标中减去另一个点的坐标以创建一个新点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates <code>point_3</code> by subtracting <code>point_2</code> from <code>point_1</code>.
   	
   	<listing version="2.0">
   	import flash.geom.Point;
   	var point_1:Point = new Point(4, 8);
   	var point_2:Point = new Point(1, 2);
   	var resultPoint:Point = point_1.subtract(point_2);
   	trace(resultPoint.toString()); // (x=3, y=6)
   	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>新点。
   	
     	</apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>v</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>要减去的点。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	从此点的坐标中减去另一个点的坐标以创建一个新点。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.geom:Point:toString"><apiName>toString</apiName><shortdesc>
	 返回包含 x 和 y 坐标的值的字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>坐标的字符串表示形式。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>返回包含 x 和 y 坐标的值的字符串。 

	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回包含 <i>x</i> 和 <i>y</i> 坐标的值的字符串。该字符串的格式为 <codeph>"(x=<i>x</i>, y=<i>y</i>)"</codeph>，因此为点 23,17 调用 <codeph>toString()</codeph> 方法将返回 <codeph>"(x=23, y=17)"</codeph>。
   	 
   	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.geom:Point:x"><apiName>x</apiName><shortdesc>
	 该点的水平坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example sets the <i>x</i> (horizontal) coordinate of <code>myPoint</code> and gets <code>myX</code> from <code>myPoint.x</code>.
	 
     <listing version="2.0">	
	 import flash.geom.Point;
	 var myPoint:Point = new Point();
	 trace(myPoint.x); // 0
	 myPoint.x = 5;
	 trace(myPoint.x); // 5
	 var myX:Number = myPoint.x;
	 trace(myX); // 5
     </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 该点的水平坐标。默认值为 0。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Point:y"><apiName>y</apiName><shortdesc>
	 该点的垂直坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example sets the <i>y</i> (vertical) coordinate of <code>myPoint</code> and gets <code>myY</code> from <code>myPoint.y</code>.
     
     <listing version="2.0">	
	 import flash.geom.Point;
	 var myPoint:Point = new Point();
	 trace(myPoint.y); // 0
	 myPoint.y = 5;
	 trace(myPoint.y); // 5
	 var myY:Number = myPoint.y;
	 trace(myY); // 5
  	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 该点的垂直坐标。默认值为 0。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:Point:length:get"><apiName>length</apiName><shortdesc>
	 从 (0,0) 到此点的线段长度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new Point, <code>myPoint</code>, and determines the length of a line from (0, 0) to that Point.
	 
	 <listing version="2.0">
	 import flash.geom.Point;
	 var myPoint:Point = new Point(3,4);
	 trace(myPoint.length); // 5
	 </listing>
	 
   	  
   	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 从 (0,0) 到此点的线段长度。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point/polar()"><linktext>Point.polar()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.geom:PerspectiveProjection"><apiName>PerspectiveProjection</apiName><shortdesc> 
 利用 PerspectiveProjection 类，可以轻松分配或修改显示对象及其所有子级的透视转换。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 利用 PerspectiveProjection 类，可以轻松分配或修改显示对象及其所有子级的透视转换。对于更加复杂的或自定义的透视转换，请使用 Matrix3D 类。PerspectiveProjection 类提供了基本的三维演示属性，而 Matrix3D 类提供了针对显示对象的三维演示的更细化的控制。
 
 <p>投影是一种用于在二维空间内表示三维对象的方式，例如，投影到计算机屏幕上的立方体。透视投影使用视见平截头体（四棱锥）来建模并将三维世界及其对象投影到屏幕上。随着视见平截头体远离视点原点，它会变得越来越宽。视点原点可以是面向屏幕的摄像头或观察者的眼睛。投影透视会在深度和距离上产生三维错觉，其中接近屏幕的对象比远离屏幕的对象要大得多。</p>
 
 <p><adobeimage alt="平截头体视见区域" href="../../images/frustum.jpg"/></p>
 
 <p>默认的 PerspectiveProjection 对象是基于视野和舞台的高宽比（尺寸）为 root 对象的透视转换定义的框架。投影中心（即消失点）将设置为舞台中心，这意味着当三维显示对象沿 z 轴后移时，这些对象会朝着舞台中心消失。默认视点位于正向 z 轴向下的点 (0,0)。y 轴朝下指向屏幕底部。可以访问 <codeph>root</codeph> 显示对象的透视投影设置，并通过 <codeph>root</codeph> 对象的 <codeph>DisplayObject.transform</codeph> 属性来更改 <codeph>perspectiveProjection</codeph> 属性的视野和投影中心属性。</p> 
 
 <p>也可以通过父级透视投影为显示对象设置不同的透视投影设置。首先，创建一个 PerspectiveProjection 对象并将设置其 <codeph>fieldOfView</codeph> 和 <codeph>projectionCenter</codeph> 属性。紧接着，使用 <codeph>DisplayObject.transform</codeph> 属性将 PerspectiveProjection 对象分配给父级显示对象。然后，指定的投影矩阵和转换将应用于显示对象的所有三维子级。</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/transform"><linktext>flash.display.DisplayObject.transform</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Utils3D"><linktext>flash.geom.Utils3D</linktext></link></related-links><apiConstructor id="flash.geom:PerspectiveProjection:PerspectiveProjection"><apiName>PerspectiveProjection</apiName><shortdesc>
     创建 PerspectiveProjection 对象的实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><helpid>
     </helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     创建 PerspectiveProjection 对象的实例。 
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.geom:PerspectiveProjection:toMatrix3D"><apiName>toMatrix3D</apiName><shortdesc>
     返回显示对象的基本 Matrix3D 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>基本 Matrix3D 对象。 
     
     </apiDesc><apiOperationClassifier>flash.geom:Matrix3D</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     返回显示对象的基本 Matrix3D 对象。  
     
     <p>显示对象（例如 root 对象）可以包含 PerspectiveProjection 对象，而无需为其转换定义 Matrix3D 属性。实际上，将使用 PerspectiveProjection 或 Matrix3D 对象指定透视转换。如果在使用 PerspectiveProjection 对象时需要 Matrix3D 对象，则 <codeph>toMatrix3D()</codeph> 方法可以检索显示对象的基本 Matrix3D 对象。例如，<codeph>toMatrix3D()</codeph> 方法可以与 <codeph>Utils3D.projectVectors()</codeph> 方法配合使用。</p> 
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link></related-links></apiOperation><apiValue id="flash.geom:PerspectiveProjection:fieldOfView:set"><apiName>fieldOfView</apiName><shortdesc>
     为三维视野指定一个角度（介于 0 度到 180 度之间）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>为三维视野指定一个角度（介于 0 度到 180 度之间）。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     为三维视野指定一个角度（介于 <codeph>0</codeph> 度到 <codeph>180</codeph> 度之间）。此值可确定应用于具有非零 z 坐标的三维显示对象的透视转换和扭曲的强度。
     
     <p>若角度接近于 <codeph>0</codeph>，则表示屏幕的二维 x 和 y 坐标与三维 x、y 和 z 坐标大致相同，只不过具有少许扭曲或无扭曲。换句话说，若角度较小，则沿 z 轴下移的显示对象看起来大小不变且移动距离很小。 </p>
     
     <p>若值接近于 <codeph>180</codeph> 度，则会产生鱼眼镜头效果，即 <codeph>z</codeph> 值小于 <codeph>0</codeph> 的位置将被放大，而 <codeph>z</codeph> 值大于 <codeph>0</codeph> 的位置将被最小化。若角度较大，则沿 z 轴下移的显示对象看起来大小变化很快且移动距离很大。如果视野设置为 <codeph>0</codeph> 或 <codeph>180</codeph>，则屏幕上不会显示任何内容。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.geom:PerspectiveProjection:focalLength:get"><apiName>focalLength</apiName><shortdesc>
     眼睛或视点的原点 (0,0,0) 与位于 z 轴的显示对象之间的距离。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     眼睛或视点的原点 (0,0,0) 与位于 z 轴的显示对象之间的距离。在透视转换过程中，将使用视野的角度和舞台的高宽比（舞台宽度除以舞台高度）来自动计算 <codeph>focalLength</codeph>。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection/fieldOfView"><linktext>fieldOfView</linktext></link></related-links></apiValue><apiValue id="flash.geom:PerspectiveProjection:projectionCenter:set"><apiName>projectionCenter</apiName><shortdesc>
     表示投影中心的二维点，它是显示对象的消失点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
     表示投影中心的二维点，它是显示对象的消失点。 
     
     <p><codeph>projectionCenter</codeph> 属性是相对于默认注册点（即舞台左上角的点 (0,0)）的偏移量。默认的投影转换中心位于舞台中间，这意味着当三维显示对象沿 z 轴后移时，这些对象会朝着舞台中心消失。</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.geom:Orientation3D"><apiName>Orientation3D</apiName><shortdesc>
Orientation3D 类是用于表示 Matrix3D 对象的方向样式的常量值枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Orientation3D 类是用于表示 Matrix3D 对象的方向样式的常量值枚举。方向的三个类型分别为欧拉角、轴角和四元数。Matrix3D 对象的 <codeph>decompose</codeph> 和 <codeph>recompose</codeph> 方法采用其中的某一个枚举类型来标识矩阵的旋转组件。

</apiDesc></apiClassifierDetail><related-links><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.geom.xml#Transform"><linktext>flash.geom.Transform</linktext></link><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link></related-links><apiValue id="flash.geom:Orientation3D:AXIS_ANGLE"><apiName>AXIS_ANGLE</apiName><shortdesc>
    轴角方向结合使用轴和角度来确定方向。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>axisAngle</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    轴角方向结合使用轴和角度来确定方向。例如，从三维球体中心到表面的直线或矢量就是一个轴。对象绕其旋转的轴是一个单位矢量，它表示三维空间中任何可能的方向。角表示有关矢量的旋转幅度。方向确定显示对象面对的方向，而横摇角确定哪个方向是向上。可以使用 Vector3D 和 Matrix3D 对象来确定各种矩阵转换，并确定重要的三维编程值，例如与两个对象的相交部分的距离（可用于检测三维对象之间的简单冲突）。
    
    <p><codeph>Matrix3D.appendRotation()</codeph> 和 <codeph>Matrix3D.prependRotation()</codeph> 方法均使用轴角方向。</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Orientation3D:EULER_ANGLES"><apiName>EULER_ANGLES</apiName><shortdesc> 
    欧拉角（decompose() 和 recompose() 方法的默认方向）通过三个不同的对应于每个轴的旋转角来定义方向。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>eulerAngles</apiData><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>通过三个不同的对应于每个轴的旋转角来定义方向。
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
    欧拉角（<codeph>decompose()</codeph> 和 <codeph>recompose()</codeph> 方法的默认方向）通过三个不同的对应于每个轴的旋转角来定义方向。通常，先进行绕 x 轴的旋转，然后进行绕 y 轴的旋转，最后进行绕 z 轴的旋转。 
    
    <p>由于存在一些问题（如绕 x 轴旋转时出现的奇异性问题或万向节锁定情况），欧拉角有时会导致动画错误。例如，由于使用欧拉角的每个轴均被单独处理，因此在绕两个或更多轴旋转的过程中，会发生万向节锁定情况。这些轴可能会对齐，从而导致意外结果。</p>
    
    <p>显示对象的轴旋转属性会执行欧拉角旋转。</p>
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue><apiValue id="flash.geom:Orientation3D:QUATERNION"><apiName>QUATERNION</apiName><shortdesc>
    四元数方向使用复数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>quaternion</apiData><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>四元数中的方向使用三个轴（x、y、z）和一个旋转角 (w)。
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    四元数方向使用复数。四元数中的方向由三个旋转轴（x、y、z）和一个旋转角 (w) 确定。四元数可以确保旋转的路径最短且最有效。它还生成平滑的、无万向节锁定的旋转。在绕两个或更多轴旋转的过程中若出现轴对齐，则会发生万向节锁定，从而导致意外结果。 
    
    <p><codeph>Matrix3D.interpolate()</codeph> 方法使用四元数。</p> 
    
    </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix3D/decompose()"><linktext>flash.geom.Matrix3D.decompose()</linktext></link><link href="flash.geom.xml#Matrix3D/recompose()"><linktext>flash.geom.Matrix3D.recompose()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>