<?xml version="1.0"?>
<apiPackage id="flash.media"><apiName>flash.media</apiName><apiDetail/><apiClassifier id="flash.media:SoundCodec"><apiName>SoundCodec</apiName><shortdesc>
SoundCodec 类是在设置 Microphone 类的 codec 属性时使用的常量值的枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
SoundCodec 类是在设置 <codeph>Microphone</codeph> 类的 <codeph>codec</codeph> 属性时使用的常量值的枚举。

</apiDesc></apiClassifierDetail><apiValue id="flash.media:SoundCodec:NELLYMOSER"><apiName>NELLYMOSER</apiName><shortdesc> 
	指定将使用 Nellymoser 编解码器进行音频压缩。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>NellyMoser</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	指定将使用 Nellymoser 编解码器进行音频压缩。此常量为 <codeph>Microphone.codec</codeph> 属性的默认值。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundCodec:SPEEX"><apiName>SPEEX</apiName><shortdesc> 
	指定将使用 Speex 编解码器进行音频压缩。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>Speex</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	指定将使用 Speex 编解码器进行音频压缩。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:ID3Info"><apiName>ID3Info</apiName><shortdesc>
	 ID3Info 类包含反映 ID3 元数据的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ID3Info 类包含反映 ID3 元数据的属性。可以通过访问 Sound 类的 <codeph>id3</codeph> 属性来获取 MP3 文件的其它元数据；例如，<codeph>mySound.id3.TIME</codeph>。有关详细信息，请在 <xref href="http://www.id3.org">http://www.id3.org</xref> 上参阅 <codeph>Sound.id3</codeph> 条目和 ID3 标签定义。
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links><apiValue id="flash.media:ID3Info:album"><apiName>album</apiName><shortdesc>
		 专辑的名称；对应于 ID3 2.0 标签 TALB。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 专辑的名称；对应于 ID3 2.0 标签 TALB。
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:artist"><apiName>artist</apiName><shortdesc>
		 歌手的姓名；对应于 ID3 2.0 标签 TPE1。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 歌手的姓名；对应于 ID3 2.0 标签 TPE1。
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:comment"><apiName>comment</apiName><shortdesc>
		 录制的相关注解；对应于 ID3 2.0 标签 COMM。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 录制的相关注解；对应于 ID3 2.0 标签 COMM。
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:genre"><apiName>genre</apiName><shortdesc>
		 歌曲的流派；对应于 ID3 2.0 标签 TCON。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 歌曲的流派；对应于 ID3 2.0 标签 TCON。
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:songName"><apiName>songName</apiName><shortdesc>
		 歌曲的名称；对应于 ID3 2.0 标签 TIT2。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 歌曲的名称；对应于 ID3 2.0 标签 TIT2。
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:track"><apiName>track</apiName><shortdesc>
		 曲目编号；对应于 ID3 2.0 标签 TRCK。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 曲目编号；对应于 ID3 2.0 标签 TRCK。
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:year"><apiName>year</apiName><shortdesc>
		 录制的年份；对应于 ID3 2.0 标签 TYER。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 录制的年份；对应于 ID3 2.0 标签 TYER。
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Microphone"><apiName>Microphone</apiName><shortdesc>
 使用 Microphone 类可从连接到运行 Flash Player 或 Adobe AIR 的计算机的麦克风中捕获音频。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 Microphone 类可从连接到运行 <ph platform="actionScript">Flash Player 或 </ph>Adobe AIR 的计算机的麦克风中捕获音频。使用 Microphone 类可在本地监视音频。使用 NetConnection 和 NetStream 类可将音频传输到 Flash Media Server。Flash Media Server 可以将音频发送到其它服务器，并向运行 <ph platform="actionScript">Flash Player 或 </ph>Adobe AIR 的其它客户端广播此音频。
 
 <p>
 有关捕获视频的信息，请参阅 Camera 类。
 </p>
 
 <p>
 <b>重要说明：</b>Flash Player 将显示“隐私”对话框，用户可从中选择是允许还是拒绝访问麦克风。请确保应用程序窗口大小至少为 215 x 138 像素，这是显示对话框所需的最小尺寸。
 </p>
 
 <p>
 要创建或引用 Microphone 对象，请使用 <codeph>Microphone.getMicrophone()</codeph> 方法。
 </p>
 
 <p platform="actionscript"><b>警告：</b>对于应用程序安全沙箱以外的内容，会显示“隐私”对话框，用户可以从中选择是允许还是拒绝对麦克风的访问。此对话框要求应用程序窗口大小至少为 215 x 138 个像素。对于应用程序安全沙箱内的 Adobe AIR 内容，将允许访问麦克风，且不再显示该对话框。</p>
 
 </apiDesc><example conref="examples\MicrophoneExample.as"> 以下示例在用户允许访问其计算机的麦克风后通过使用麦克风的回音抑制捕获声音。<codeph>Security.showSettings()</codeph> 方法显示 Flash Player 对话框，请求提供对用户的麦克风的访问权限。对 <codeph>setLoopBack(true)</codeph> 的调用会将输入重新发送到本地扬声器，以便在运行示例时可以听到声音。
 
 <p>有两个侦听器用于侦听 <codeph>activity</codeph> 和 <codeph>status</codeph> 事件。<codeph>activity</codeph> 事件在会话开始和结束（如果有）时被分派，并由 <codeph>activityHandler()</codeph> 方法捕获（此方法跟踪有关该事件的信息）。<codeph>status</codeph> 事件在附加的 Microphone 对象报告任何状态信息时被分派；将使用 <codeph>statusHandler()</codeph> 方法捕获并跟踪此信息。</p>
 
 <p><b>注意：</b>必须将麦克风与计算机连接，此示例才能正常运行。</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Microphone;
    import flash.system.Security;

    public class MicrophoneExample extends Sprite {
        public function MicrophoneExample() {
            var mic:Microphone = Microphone.getMicrophone();
            Security.showSettings("2");
            mic.setLoopBack(true);
                    
            if (mic != null) {
                mic.setUseEchoSuppression(true);
                mic.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                mic.addEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }

        private function statusHandler(event:StatusEvent):void {
            trace("statusHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 在麦克风报告其状态时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在麦克风报告其状态时分派。如果 <codeph>code</codeph> 属性的值为“<codeph>Microphone.Muted</codeph>”，则表示用户拒绝 SWF 文件访问麦克风。如果 <codeph>code</codeph> 属性的值为“<codeph>Microphone.Unmuted</codeph>”，则表示用户允许 SWF 文件访问麦克风。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>Microphone.getMicrophone()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Microphone_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 在麦克风开始或结束会话时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在麦克风开始或结束会话时分派。 
 
 <p>
 要指定触发 <codeph>activating</codeph> 属性值为 <codeph>true</codeph> 的此事件所需的音量，或者指定在没有声音的情况下经过多长时间才会触发 <codeph>activating</codeph> 属性值为 <codeph>false</codeph> 的此事件，请使用 <codeph>Microphone.setSilenceLevel()</codeph>。
 </p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>setSilenceLevel()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.media:Microphone:getMicrophone"><apiName>getMicrophone</apiName><shortdesc>
	 
	 返回对用于捕获音频的 Microphone 对象的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, Microphone.getMicropone, getMicrophone
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>对用于捕获音频的 Microphone 对象的引用。
	 
 	 </apiDesc><apiOperationClassifier>flash.media:Microphone</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>麦克风的索引值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 返回对用于捕获音频的 Microphone 对象的引用。要开始捕获音频，您必须将 Microphone 对象附加到 NetStream 对象（请参阅 <codeph>NetStream.attachAudio()</codeph>）。
	 
	 <p>
	 对 <codeph>Microphone.get()</codeph> 的多次调用会引用同一个麦克风。因此，如果代码包含 <codeph>mic1 = Microphone.get()</codeph> 和 <codeph>mic2 = Microphone.get()</codeph> 行，则 <codeph>mic1</codeph> 和 <codeph>mic2</codeph> 将引用同一个（默认）麦克风。</p>
	 <p>
	 如果要获取默认的麦克风，则需要使用 -1 调用 <codeph>getMicrophone()</codeph>。如果调用此方法时不使用任何参数，则会返回列表中的第一个麦克风。
	 </p>
	 
	 <p>
	 可以使用 <codeph>index</codeph> 属性来获取当前 Microphone 对象的索引值。然后，可以将该值传递给 Microphone 类的其它方法。
	 </p>
	 
	 <p>
	 通常，不应传递 <codeph>index</codeph> 的值。只需使用 <codeph>Microphone.getMicrophone()</codeph> 方法即可返回对默认麦克风的引用。通过使用“麦克风设置”面板，用户可以指定应用程序应使用的默认麦克风。如果传递 <codeph>index</codeph> 的值，则可能会引用非用户选择的其它麦克风。在极少数情况下（例如，应用程序同时从两个麦克风捕获音频），您可能会使用 <codeph>index</codeph>。
	 </p>
	 
	 <p>
	 当 SWF 文件尝试访问 <codeph>Microphone.getMicrophone()</codeph> 返回的对象时（例如，在调用 <codeph>NetStream.attachAudio()</codeph> 时），Flash Player 将显示“隐私”对话框，用户可从中选择是允许还是拒绝访问麦克风。（确保舞台大小至少为 215 x 138 个像素；这是 Flash Player 显示该对话框所需的最小大小。）
	 </p>
	 
	 <p>
     当用户对此对话框做出响应时，将分派 <codeph>status</codeph> 事件以指示用户的响应。还可以检查 <codeph>Microphone.muted</codeph> 属性以确定用户是允许还是拒绝访问麦克风。 
	 </p>
	 
	 <p>
	 如果 <codeph>Microphone.getMicrophone()</codeph> 返回 <codeph>null</codeph>，则表明麦克风正由其它应用程序使用，或者系统上没有安装任何麦克风。要确定是否安装了任何麦克风，请使用 <codeph>Microphones.names.length</codeph>。要显示 Flash Player 的“麦克风设置”面板（用户可从中选择 <codeph>Microphone.getMicrophone</codeph> 所引用的麦克风），请使用 <codeph>Security.showSettings()</codeph>。 
	 
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/event:status"><linktext>Microphone.status</linktext></link><link href="flash.net.xml#NetStream/attachAudio()"><linktext>flash.net.NetStream.attachAudio()</linktext></link><link href="flash.system.xml#Security/showSettings()"><linktext>flash.system.Security.showSettings()</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone:getMicrophone_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在麦克风报告其状态时分派。如果 <codeph>code</codeph> 属性的值为 <codeph>"Microphone.Muted"</codeph>，则表示用户拒绝 SWF 文件访问其麦克风。如果 <codeph>code</codeph> 属性的值为 <codeph>"Microphone.Unmuted"</codeph>，则表示用户允许 SWF 文件访问其麦克风。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在麦克风报告其状态时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Microphone:setLoopBack"><apiName>setLoopBack</apiName><shortdesc>
	 将麦克风捕获的音频传送到本地扬声器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>state</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData></apiParam></apiOperationDef><apiDesc>
	 将麦克风捕获的音频传送到本地扬声器。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.media:Microphone:setSilenceLevel"><apiName>setSilenceLevel</apiName><shortdesc>
	 设置可认定为有声的最低音量输入水平，以及实际静音前需经历的无声时间长度（可选）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setSilenceLevel, setSilenceLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>silenceLevel</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>激活麦克风并分派 <codeph>activity</codeph> 事件所需的音量。可接受值的范围为 0 到 100。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>在没有活动的情况下经过的毫秒数，必须经过这么长的时间，Flash Player 或 Adobe AIR 才会认为声音已停止并分派 <codeph>dispatch</codeph> 事件。默认值为 2000（2 秒）。(<b>注意：</b>在签名中显示的默认值 -1 是一个内部值，用于指示 Flash Player 或 Adobe AIR 使用 2000。）
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 设置可认定为有声的最低音量输入水平，以及实际静音前需经历的无声时间长度（可选）。
	 <ul>
	   <li>要完全禁止麦克风检测声音，请为 <codeph>silenceLevel</codeph> 传递值 100；这样就决不会再分派 <codeph>activity</codeph> 事件了。 </li>
	   <li>要确定麦克风当前所检测的音量，请使用 <codeph>Microphone.activityLevel</codeph>。 </li>
	 </ul>
	 
	 <p>活动检测是检测声音级别在何时表示某人正在谈话的功能。当某人没有谈话时，由于不需要发送关联的音频流，因此可以节约带宽。此信息也可用于视频反馈，以便让用户知道他们（或其它人）没有谈话。</p>
	 
	 <p>静音值与活动值直接对应。完全静音对应于活动值 0。持续噪音（根据当前增益设置可以检测到的噪音）对应于活动值 100。当增益得到适当调整之后，在您没有说话时，活动值将小于静音值；在您说话时，活动值将大于静音值。</p>
	 
	 <p>此方法与 <codeph>Camera.setMotionLevel()</codeph> 类似；这两种方法都用于指定何时分派 <codeph>activity</codeph> 事件。不过，这两种方法在对发布流的影响上具有显著的差异：</p>
	 
	 <ul>
	   <li><codeph>Camera.setMotionLevel()</codeph> 设计用于检测运动，并且不影响带宽用量。即使视频流未检测到运动，仍将发送视频。</li>
	 
	   <li><codeph>Microphone.setSilenceLevel()</codeph> 设计用于优化带宽。在认为音频流被静音时，不发送任何音频数据。而改为发送一条指示静音已启动的消息。 </li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>flash.media.Camera.setMotionLevel()</linktext></link><link href="flash.media.xml#Microphone/activityLevel"><linktext>flash.media.Microphone.activityLevel</linktext></link><link href="flash.media.xml#Microphone/event:activity"><linktext>flash.media.Microphone.activity</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/silenceLevel"><linktext>flash.media.Microphone.silenceLevel</linktext></link><link href="flash.media.xml#Microphone/silenceTimeout"><linktext>flash.media.Microphone.silenceTimeout</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Microphone:setUseEchoSuppression"><apiName>setUseEchoSuppression</apiName><shortdesc>
	 指定是否使用音频编解码器的回音抑制功能。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setUseEchoSuppression, setUseEchoSuppression
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>useEchoSuppression</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>一个用于指示是应该使用 (<codeph>true</codeph>) 还是不应该使用 (<codeph>false</codeph>) 回音抑制的布尔值。 	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定是否使用音频编解码器的回音抑制功能。除非用户已经在 Flash Player 的“麦克风设置”面板中选择了“降低回音”，否则默认值为 <codeph>false</codeph>。
	 
	 <p>回音抑制是指降低音频回馈效果，当扬声器发出的声音由同一台计算机上的麦克风拾取时，将导致音频回馈。（这不同于回音消除，后者完全消除回馈。）</p>
	 
	 <p>通常情况下，当通过同一台计算机上的扬声器（而不是耳机）播放所捕获的声音时，建议使用回音抑制。如果您的 SWF 文件允许用户指定声音输出设备，则当他们指定使用扬声器并且还将使用麦克风时，您可能需要调用 <codeph>Microphone.setUseEchoSuppression(true)</codeph>。 </p>
	 
	 <p>用户也可以在 Flash Player 的“麦克风设置”面板中调整这些设置。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link><link href="flash.media.xml#Microphone/useEchoSuppression"><linktext>flash.media.Microphone.useEchoSuppression</linktext></link></related-links></apiOperation><apiValue id="flash.media:Microphone:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 麦克风正在检测的音量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.activityLevel, activityLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 麦克风正在检测的音量。值的范围为 0（未检测到声音）到 100（检测到非常大的声音）。此属性的值有助于确定向 <codeph>Microphone.setSilenceLevel()</codeph> 方法传递的适当值。
	 
	 <p>如果麦克风可用，但却因为尚未调用 <codeph>Microphone.getMicrophone()</codeph> 而未被使用，则此属性设置为 -1。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:codec:get"><apiName>codec</apiName><shortdesc>
	 用于压缩音频的编解码器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.getCodec, getCodec
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 用于压缩音频的编解码器。可用编解码器为 Nellymoser（默认值）和 Speex。枚举类 <codeph>SoundCodec</codeph> 包含各种对 <codeph>codec</codeph> 属性有效的值。
	 
	 <p>如果使用 Nellymoser 编解码器，可使用 <codeph>Microphone.rate()</codeph> 设置采样率。如果使用 Speex 编解码器，则采样率会设置为 16 kHz。</p>
	 
	 <p>Speex 具有语音活动检测功能 (VAD)，在未检测到语音时将自动减小带宽。使用 Speex 编解码器时，Adobe 建议将静音级别设置为 0。要设置静音级别，请使用 <codeph>Microphone.setSilenceLevel()</codeph> 方法。</p>
	 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()s"><linktext>setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:encodeQuality:get"><apiName>encodeQuality</apiName><shortdesc>
	 使用 Speex 编解码器时的编码语音品质。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 使用 Speex 编解码器时的编码语音品质。可能值为从 0 到 10 的值。默认值为 6。数字越大，表示品质越高，但需要更多的带宽，如下表所示。列出的比特率值表示净比特率，并不包括信息分包开销。
	 <p>
	  <adobetable class="innertable">
	 
	    
	    
	    
	    
	    
	    
	    
	    
	 
	    
	    
	  <tgroup cols="2"><thead><row><entry>品质值</entry><entry>所需的比特率（KB/秒）</entry></row></thead><tbody><row>
	      <entry>0</entry>
	      <entry> 3.95</entry>
	    </row><row>
	      <entry>1</entry>
	      <entry>5.75</entry>
	    </row><row>
	      <entry>2</entry>
	      <entry>7.75</entry>
	    </row><row>
	      <entry>3</entry>
	      <entry>9.80</entry>
	    </row><row>
	      <entry>4</entry>
	      <entry>12.8</entry>
	    </row><row>
	      <entry>5</entry>
	      <entry>16.8</entry>
	    </row><row>
	      <entry>6</entry>
	      <entry>20.6</entry>
	    </row><row>
	      <entry>7</entry>
	      <entry>23.8</entry>
	    </row><row>
	 <entry>8</entry>
	 <entry>27.8</entry>
	    </row><row>
	      <entry>9</entry>
	      <entry>34.2</entry>
	    </row><row>
	      <entry>10</entry>
	      <entry>42.2</entry>
	    </row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>codec</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:framesPerPacket:get"><apiName>framesPerPacket</apiName><shortdesc>
	 在一个包（消息）中传输的 Speex 语音帧的数目。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 在一个包（消息）中传输的 Speex 语音帧的数目。每帧长 20 ms。默认值为每个包两帧。
	 
	 <p>消息中包含的 Speex 帧越多，需要的带宽就越小，但发送消息延迟的时间就越长。Speex 帧越少，需要的带宽就越大，而延迟的时间就会越短。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:gain:get"><apiName>gain</apiName><shortdesc>
	 麦克风放大信号的程度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.gain, gain
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 麦克风放大信号的程度。有效值为 0 到 100。默认值为 50。
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:index:get"><apiName>index</apiName><shortdesc>
	 麦克风的索引，它反映在 Microphone.names 返回的数组中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.index, index
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 麦克风的索引，它反映在 <codeph>Microphone.names</codeph> 返回的数组中。
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:muted:get"><apiName>muted</apiName><shortdesc>
	 指定用户是已经拒绝对麦克风的访问 (true) 还是已经允许对麦克风的访问 (false)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.muted, muted
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 指定用户是已经拒绝对麦克风的访问 (<codeph>true</codeph>) 还是已经允许对麦克风的访问 (<codeph>false</codeph>)。当该值发生变化时，将分派 <codeph>status</codeph> 事件。有关详细信息，请参阅 <codeph>Microphone.getMicrophone()</codeph>。 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/event:status"><linktext>flash.media.Microphone.status</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:name:get"><apiName>name</apiName><shortdesc>
	 当前声音捕获设备的名称，它由声音捕获硬件返回。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.name, name
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 当前声音捕获设备的名称，它由声音捕获硬件返回。
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:names:get"><apiName>names</apiName><shortdesc>
	 包含所有可用声音捕获设备名称的字符串数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.names, names
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 包含所有可用声音捕获设备名称的字符串数组。返回名称，但不必向用户显示 Flash Player 的“专用设置”面板。此数组通过 <codeph>Microphone.names.length</codeph> 属性提供每个声音捕获设备的从零开始的索引和系统上声音捕获设备的数量。有关详细信息，请参阅 Array 类条目。
	 
	 <p>调用 <codeph>Microphone.names</codeph> 要求全面检查硬件，并可能需要几秒钟时间才能生成数组。大多数情况下，使用默认麦克风即可。</p>
	 
	 <p><b>注意：</b>要确定当前麦克风的名称，请使用 <codeph>name</codeph> 属性。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Array"><linktext>Array</linktext></link><link href="flash.media.xml#Microphone/name"><linktext>flash.media.Microphone.name</linktext></link><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:rate:get"><apiName>rate</apiName><shortdesc>
	 麦克风捕获声音时使用的速率，单位是 kHz。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.rate, rate
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 麦克风捕获声音时使用的速率，单位是 kHz。可接受的值为 5、8、11、22 和 44。如果您的声音捕获设备支持 8 kHz，则默认值为 8 kHz。否则，默认值为您的声音捕获设备支持的高于 8 kHz 的下一个可用捕获级别，通常为 11 kHz。Flash Player 10 和 AIR 1.5 或更高版本支持 16kHz 速率值。
	 
	 <p><b>注意：</b>如果对 Flash Player 10 和 AIR 1.5 或更高版本使用 Speex 编解码器 (<codeph>Microphone.codec = SoundCodec.SPEEX</codeph>)，则默认速率值为 16kHz。如果使用 Speex 编解码器，然后将编解码器值更改为 Nellymoser (<codeph>Microphone.codec = SoundCodec.NELLYMOSER</codeph>)，则速率将保持为 16kHz，直到您明确更改该值为止。要使用 Flash Player 10 之前的版本和 AIR 1.5 之前的版本接收音频，请在发布音频时更改编解码器值及速率值。</p>
	 
	 
 	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>flash.media.Microphone.codec</linktext></link><link href="flash.media.xml#SoundCodec"><linktext>flash.media.SoundCodec</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceLevel:get"><apiName>silenceLevel</apiName><shortdesc>
	 激活麦克风并分派 activity 事件所需的音量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceLevel, silenceLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 激活麦克风并分派 <codeph>activity</codeph> 事件所需的音量。默认值为 10。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceTimeout:get"><apiName>silenceTimeout</apiName><shortdesc>
	 麦克风停止检测声音的时间和分派 activity 事件的时间之间相差的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceTimeout, silenceTimeout
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 麦克风停止检测声音的时间和分派 <codeph>activity</codeph> 事件的时间之间相差的毫秒数。默认值为 2000（2 秒）。
	 
	 <p>要设置此值，请使用 <codeph>Microphone.setSilenceLevel()</codeph> 方法。</p>
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 在此麦克风对象处于环回模式时，控制它的声音。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 在此麦克风对象处于环回模式时，控制它的声音。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:useEchoSuppression:get"><apiName>useEchoSuppression</apiName><shortdesc>
	 如果启用了回音抑制，则设置为 true；否则，设置为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.useEchoSuppression, useEchoSuppression
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 如果启用了回音抑制，则设置为 <codeph>true</codeph>；否则，设置为 <codeph>false</codeph>。除非用户已经在 Flash Player 的“麦克风设置”面板中选择了“降低回音”，否则默认值为 <codeph>false</codeph>。
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:flash.media:scanHardware"><apiName>scanHardware</apiName><shortdesc>
	 强制重新扫描系统上的麦克风和摄像头。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 强制重新扫描系统上的麦克风和摄像头。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiClassifier id="flash.media:Camera"><apiName>Camera</apiName><shortdesc>
 使用 Camera 类可从连接到运行 Flash Player 的计算机的摄像头中捕获视频。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 Camera 类可从连接到运行 Flash Player 的计算机的摄像头中捕获视频。使用 Video 类可在本地监视视频。使用 NetConnection 和 NetStream 类可将视频传输到 Flash Media Server。Flash Media Server 可以将视频流发送到其它服务器，并向运行 Flash Player 的其它客户端广播此视频流。
 
 <p>
 有关捕获音频的信息，请参阅 Microphone 类。
 </p>
 
 <p>
 <b>重要说明：</b>Flash Player 将显示“隐私”对话框，用户可从中选择是允许还是拒绝访问摄像头。确保应用程序窗口大小至少为 215 x 138 个像素；这是显示该对话框所需的最小大小。
 </p>
 
 <p>要创建或引用 Camera 对象，请使用 <codeph>getCamera()</codeph> 方法。</p>
 
 </apiDesc><example conref="examples\CameraExample.as"> 以下示例显示了在确认安全警告之后来自摄像头的图像。舞台被设置为无法进行缩放，并与播放器窗口左上角对齐。<codeph>activity</codeph> 事件在会话开始和结束（如果有）时被分派，并由 <codeph>activityHandler()</codeph> 方法捕获，该方法会输出有关这一事件的信息。
 
 <p><b>注意：</b>必须将摄像头与计算机连接，此示例才能正常运行。</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Camera;
    import flash.media.Video;

    public class CameraExample extends Sprite {
        private var video:Video;
        
        public function CameraExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            
            var camera:Camera = Camera.getCamera();
            
            if (camera != null) {
                camera.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                video = new Video(camera.width * 2, camera.height * 2);
                video.attachCamera(camera);
                addChild(video);
            } else {
                trace("You need a camera.");
            }
        }
        
        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Microphone"><linktext>flash.media.Microphone</linktext></link></related-links><adobeApiEvent id="flash.media:Camera_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 在摄像头报告其状态时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在摄像头报告其状态时分派。若 <codeph>code</codeph> 属性的值为 <codeph>"Camera.Muted"</codeph>，则表示用户已拒绝 SWF 文件访问其摄像头。如果 <codeph>code</codeph> 属性的值为“<codeph>Camera.Unmuted</codeph>”，则表示用户允许 SWF 文件访问其摄像头。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>Camera.getCamera()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Camera_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 在摄像头开始或结束会话时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在摄像头开始或结束会话时分派。可以调用 <codeph>Camera.setMotionLevel()</codeph> 以指定触发 <codeph>activating</codeph> 值为 <codeph>true</codeph> 的 <codeph>activity</codeph> 事件所需的运动量，或者指定在没有活动的情况下经过多长时间才会触发 <codeph>activating</codeph> 值为 <codeph>false</codeph> 的 <codeph>activity</codeph> 事件。
 
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:Camera:getCamera"><apiName>getCamera</apiName><shortdesc>
	 返回对用于捕获视频的 Camera 对象的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, constructor, Camera.getCamera, getCamera
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>如果未指定 <codeph>name</codeph> 参数，则此方法返回对默认摄像头的引用；或者，如果默认摄像头正由另一个应用程序使用，则此方法返回对第一个可用摄像头的引用。（如果安装了多个摄像头，则用户可以在 Flash Player 的“摄像头设置”面板中指定默认的摄像头。）如果没有可用摄像头或没有安装摄像头，则该方法返回 <codeph>null</codeph>。 
 	  
 	 </apiDesc><apiOperationClassifier>flash.media:Camera</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>指定要获取哪一个摄像头，这由 <codeph>names</codeph> 属性返回的数组确定。对于大多数应用程序，可省略此参数来获取默认摄像头。要为此参数指定值，请使用 Camera.names 数组内从零开始的索引位置的字符串表示形式。例如，要在数组中指定第三个摄像头，请使用 <codeph>Camera.getCamera("2")</codeph>。 
 	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回对用于捕获视频的 Camera 对象的引用。要开始捕获视频，必须将 Camera 对象附加到 Video 对象（请参阅 <codeph>Video.attachCamera() </codeph>）。要将视频传输到 Flash Media Server，请调用 <codeph>NetStream.attachCamera()</codeph> 以将 Camera 对象附加到 NetStream 对象。
	 
	 <p>对 <codeph>getCamera()</codeph> 方法的多次调用会引用相同的摄像头驱动程序。因此，如果代码包含诸如 <codeph>firstCam:Camera = getCamera()</codeph> 和 <codeph>secondCam:Camera = getCamera()</codeph> 之类的代码，则 <codeph>firstCam</codeph> 和 <codeph>secondCam</codeph> 会引用同一个摄像头，该摄像头为用户的默认摄像头。</p>
	 
	 <p>通常不应为 <codeph>name</codeph> 参数传递值，而只是使用 <codeph>getCamera()</codeph> 来返回对默认摄像头的引用。通过“摄像头设置”面板（将在本节的后面进行讨论），用户可以指定 Flash Player 应使用的默认摄像头。 </p>
	 
  	 <p>您不能使用 ActionScript 来设置用户用于访问摄像头的 Allow 或 Deny 权限设置，但可以显示“Adobe Flash Player 设置”摄像头设置对话框，用户可以在其中设置摄像头权限。当使用 <codeph>attachCamera()</codeph> 方法的 SWF 文件尝试将 <codeph>getCamera()</codeph> 方法返回的摄像头附加到 Video 或 NetStream 对象时，Flash Player 将显示一个对话框，用户可从中选择是允许还是拒绝访问摄像头。（确保应用程序窗口大小至少为 215 x 138 个像素；这是 Flash Player 显示该对话框所需的最小大小。）当用户对摄像头设置对话框做出响应时，Flash Player 将在指示用户响应的 <codeph>status</codeph> 事件中返回信息对象：<codeph>Camera.muted</codeph> 指示用户拒绝访问摄像头；<codeph>Camera.Unmuted</codeph> 指示用户允许访问摄像头。要在不处理 <codeph>status</codeph> 事件的情况下确定用户是拒绝还是允许访问摄像头，请使用 <codeph>muted</codeph> 属性。</p>
  	 
 	 <p>用户可以为特定的域指定永久保密性设置，方法是在 SWF 文件播放时右键单击 (Windows 和 Linux) 或按住 Control 的同时单击 (Macintosh)，选择“设置”，打开“保密性”对话框，然后选择“记住”。如果用户选择“记住”，Flash Player 将不再询问用户是允许还是拒绝此域的 SWF 文件访问摄像头。</p>
  	 
  	 <p><b>注意：</b>如果用户已通过选择“Flash Player 设置”对话框中的“记住”来拒绝访问摄像头，则 <codeph>attachCamera()</codeph> 方法将不会调用该对话框来允许或拒绝对摄像头的访问。在这种情况下，您可以通过使用 <codeph>Security.showSettings(SecurityPanel.PRIVACY)</codeph> 为用户显示“Flash Player 隐私”面板，提示用户更改 Allow 或 Deny 设置。</p>
 	 
 	 <p>如果 <codeph>getCamera()</codeph> 返回 <codeph>null</codeph>，则表明摄像头正由另一个应用程序使用，或者系统上没有安装摄像头。要确定是否安装了任何摄像头，请使用 <codeph>names.length</codeph> 属性。要显示 Flash Player 的“摄像头设置”面板（让用户选择将由 <codeph>getCamera()</codeph> 引用的摄像头），请使用 <codeph>Security.showSettings(SecurityPanel.CAMERA)</codeph>。 </p>
 	 
	 <p>扫描硬件以找到摄像头需要花一些时间。当 Flash Player 找到至少一个摄像头后，在该播放器实例的生存期内将不再扫描硬件。不过，如果 Flash Player 没有找到任何摄像头，则在每次调用 <codeph>getCamera</codeph> 时都进行扫描。这在用户忘记连接摄像头时非常有用；如果 SWF 文件提供了调用 <codeph>getCamera</codeph> 的“重试”按钮，则用户不必重新启动该 SWF 文件，Flash Player 即可找到摄像头。</p>
 	 
	 </apiDesc><example conref="examples\Camera_getCameraExample.as"> 在下面的示例中，在用户允许访问摄像头后，使用连接的摄像头捕获视频图像。还会显示有关视频流的信息，如当前每秒帧数。
 
 <p><codeph>Camera.getCamera()</codeph> 方法将返回对 camera 对象的引用，如果没有可用的摄像头或未安装摄像头，则返回 null。if 语句检查是否找到摄像头，以及用户是否允许访问该摄像头。如果用户拒绝访问，则 <codeph>muted</codeph> 属性设置为 <codeph>true</codeph>。</p> 
 
 <p>通常，在调用 <codeph>attachCamera()</codeph> 方法时，将出现一个对话框，提示用户允许或拒绝 Flash Player 访问该摄像头。但是，如果用户拒绝访问并选择了<codeph>“记住”</codeph>选项，则不会出现该对话框并且不会显示任何信息。为确保向用户提供允许访问摄像头的选项，<codeph>myTextField</codeph> 文本字段将指示用户单击该文本字段以调用“Flash Player 设置”对话框。</p>
 
 <p><codeph>clickHandler()</codeph> 方法调用 <codeph>Security.showSettings()</codeph> 方法，后者会显示“设置”对话框的<codeph>“隐私”</codeph>面板。如果用户允许访问，则分派 <codeph>StatusEvent.STATUS</codeph> 事件，并将该事件的 <codeph>code</codeph> 属性值设置为 <codeph>Camera.Unmuted</codeph>。（摄像头对象的 <codeph>mute</codeph> 属性值也设置为 <codeph>false</codeph>。）</p>
 
 <p>如果用户允许访问，则为侦听用户设置状态更改而添加的 <codeph>statusHandler()</codeph> 方法将调用 <codeph>connectCamera()</codeph> 方法。<codeph>connectCamera()</codeph> 方法使用捕获的流的宽度和高度实例化视频对象。要显示摄像头捕获的视频，请将对视频流的引用附加到该视频对象，并将该视频对象添加到显示列表中。</p>
 
 <p>还将启动一个 Timer 对象。每秒都会分派 Timer 对象的 timer 事件并调用 <codeph>timerHandler()</codeph> 方法。将显示 <codeph>timerHandler()</codeph> 方法并更新 Camera 对象的许多属性。 </p> 
 <p><b>注意：</b>对于本示例，唯一发生更改的属性是 <codeph>currentFPS</codeph> 属性。</p>    
    
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.StatusEvent;
    import flash.events.MouseEvent;
    import flash.system.SecurityPanel;
    import flash.system.Security;

    public class Camera_getCameraExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);
        
        public function Camera_getCameraExample() {
            myTextField = new TextField();
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";
                
            } else if (cam.muted) {
                myTextField.text = "To enable the use of the camera,\n"
                                 + "please click on this text field.\n" 
                                 + "When the Flash Player Settings dialog appears,\n"
                                 + "make sure to select the Allow radio button\n" 
                                 + "to grant access to your camera.";

                myTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            }else {
                myTextField.text = "Connecting";
                connectCamera(); 
            }
   
            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function clickHandler(e:MouseEvent):void {
            Security.showSettings(SecurityPanel.PRIVACY);

            cam.addEventListener(StatusEvent.STATUS, statusHandler);

            myTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
        }

        private function statusHandler(event:StatusEvent):void {

            if (event.code == "Camera.Unmuted") {
                connectCamera(); 
                cam.removeEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                t.start();
        }

        private function timerHandler(event:TimerEvent):void {
            myTextField.y = cam.height + 20;
            myTextField.text = "";
            myTextField.appendText("bandwidth: " + cam.bandwidth + "\n");
            myTextField.appendText("currentFPS: " + Math.round(cam.currentFPS) + "\n");
            myTextField.appendText("fps: " + cam.fps + "\n");
            myTextField.appendText("keyFrameInterval: " + cam.keyFrameInterval + "\n");
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/muted"><linktext>muted</linktext></link><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links><adobeApiEvent id="flash.media:Camera:getCamera_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在摄像头报告其状态时分派。若 <codeph>code</codeph> 属性的值为 <codeph>"Camera.muted"</codeph>，则表示用户拒绝 SWF 文件访问他的摄像头。如果 <codeph>code</codeph> 属性的值为“<codeph>Camera.Unmuted</codeph>”，则表示用户允许 SWF 文件访问其摄像头。
 	 </apiDesc></adobeApiEventDetail><shortdesc>在摄像头报告其状态时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Camera:setKeyFrameInterval"><apiName>setKeyFrameInterval</apiName><shortdesc>
	 指定进行完整传输而不由视频压缩算法进行插值处理的视频帧（称为关键帧）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>keyFrameInterval</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个值，用于指定将哪些视频帧（作为关键帧）进行完整传输而不由视频压缩算法进行插补处理。值 1 表示每一帧都是关键帧，值 3 表示每隔两个帧后的那一帧为关键帧，依此类推。可接受值为 1 至 48。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定进行完整传输而不由视频压缩算法进行插值处理的视频帧（称为<i>关键帧</i>）。此方法仅在使用 Flash Media Server 传输视频时适用。
	 
	 <p>Flash 视频压缩算法通过只传输自视频的上一帧以来的更改内容来压缩视频；这些部分被视为插补帧。可以根据前一帧的内容插补视频帧。但是，关键帧是完整的视频帧；它并不是根据前面的帧插补的。</p> 
	 
	 <p>要确定如何设置 <codeph>keyFrameInterval</codeph> 参数的值，请考虑带宽使用率和视频回放辅助功能。例如，为 <codeph>keyFrameInterval</codeph> 指定较高的值（以较低的频率发送关键帧）可降低带宽使用率。但是，这可能会增加在视频某一特定点上定位播放头所需的时间量；可能需要插补更多以前的视频帧才能继续播放视频。</p> 
	 
	 <p>反之，为 <codeph>keyFrameInterval</codeph> 指定较低的值（以较高的频率发送关键帧）会提高带宽使用率（因为会更频繁地传输所有的视频帧），但可能会减少在已录制视频内搜索特定视频帧所需的时间量。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/keyFrameInterval"><linktext>keyFrameInterval</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setLoopback"><apiName>setLoopback</apiName><shortdesc>
	 指定在本地查看摄像头时是否使用压缩视频流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>compress</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>针对本地查看摄像头所接收内容指定是使用压缩视频流 (<codeph>true</codeph>) 还是使用未压缩的流 (<codeph>false</codeph>)。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定在本地查看摄像头时是否使用压缩视频流。此方法仅在使用 Flash Media Server 传输视频时适用；如果将 <codeph>compress</codeph> 设置为 <codeph>true</codeph>，则可以更精确地看到在用户实时查看视频时向用户呈现视频的方式。
	 
	 <p>虽然压缩流在用于测试（如预览视频品质设置）时很有用，但对它进行处理要花很大的代价，因为对本地视图并不只是进行压缩处理；就像通过实时连接进行传输那样，需要对视频进行压缩和编辑以进行传输，然后要对其进行解压缩处理以供本地查看。</p>
	 
	 <p>要在 <codeph>compress</codeph> 设置为 <codeph>true</codeph> 的情况下设置使用的压缩量，请使用 <codeph>Camera.setQuality()</codeph>。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMode"><apiName>setMode</apiName><shortdesc>
	 将摄像头的捕获模式设置为最符合指定要求的本机模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMode, setMode
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>请求的捕获宽度，以像素为单位。默认值为 160。	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>请求的捕获高度，以像素为单位。默认值为 120。	 
	 </apiDesc></apiParam><apiParam><apiItemName>fps</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>摄像头捕获数据应使用的请求速率，以每秒帧数为单位。默认值为 15。	 
	 </apiDesc></apiParam><apiParam><apiItemName>favorArea</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>指定在摄像头不具有满足指定要求的本机模式的情况下是否控制宽度、高度和帧速率。默认值为 <codeph>true</codeph>，这意味着支持保持捕获大小；使用此参数选择与 <codeph>width</codeph> 和 <codeph>height</codeph> 值最匹配的模式，即使这样做会由于降低帧速率而对性能造成不利影响。要最大限度地提高帧速率，而不考虑摄像头的高度和宽度，请将 <codeph>false</codeph> 传递给 <codeph>favorArea</codeph> 参数。
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将摄像头的捕获模式设置为最符合指定要求的本机模式。如果摄像头没有与您传递的所有参数相匹配的本机模式，Flash Player 将选择与所请求的模式最接近的合成捕获模式。此操作可能涉及裁切图像和删除帧。 
	 
	 <p>默认情况下，Flash Player 根据需要删除一些帧以保持图像大小。要将删除的帧数降至最低（即使这意味着减小图像大小），请为 <codeph>favorArea</codeph> 参数传递 <codeph>false</codeph>。</p>
	 
	 <p>在选择本机模式时，Flash Player 将设法尽量保持所请求的高宽比。例如，如果发出 <codeph>myCam.setMode(400, 400, 30)</codeph> 命令，并且摄像头上可用的最大宽度和高度值分别为 320 和 288，则 Flash Player 将宽度和高度都设置为 288；通过将这些属性设置为相同的值，Flash Player 可以保持所请求的 1:1 高宽比。</p>
	 
	 <p>要确定在 Flash Player 选择与所请求的值最匹配的模式后分配给这些属性的值，请使用 <codeph>width</codeph>、<codeph>height</codeph> 和 <codeph>fps</codeph> 属性。</p>
	 
	 <p>
	 如果使用 Flash Media Server，您也可以捕获单个帧或创建延时拍摄。有关详细信息，请参阅 <codeph>NetStream.attachCamera()</codeph>。
	 </p>
	 
	 </apiDesc><example conref="examples\Camera_setModeExample.as"> 在下面的示例中，当用户单击舞台时，将调整视频大小并将每秒帧数捕获率设置为新值。  
 
 <p>舞台的设置使其不会缩放。<codeph>Camera.getCamera()</codeph> 方法将返回对 camera 对象的引用，如果没有可用的摄像头或未安装摄像头，则返回 null。如果存在摄像头，则调用 <codeph>connectCamera()</codeph> 方法。<codeph>connectCamera()</codeph> 方法实例化一个视频对象。要显示摄像头捕获的视频，请将对视频流的引用附加到该视频对象，并将该视频对象添加到显示列表中。还为 <codeph>MouseEvent.CLICK</codeph> 事件设置了一个事件侦听器。当用户单击舞台之后，将调用 <codeph>clickHandler()</codeph> 方法。该方法检查捕获视频的宽度并设置摄像头捕获模式的宽度、高度和每秒帧数请求速率。为了使这些设置生效，必须删除并重新创建该视频对象。还必须将该视频的宽度和高度设置为 camera 对象的宽度和高度。</p>      
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.events.MouseEvent;
    import flash.display.StageScaleMode;

    public class Camera_setModeExample extends Sprite {
        private var cam:Camera;
        private var vid:Video;

        public function Camera_setModeExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;

            cam = Camera.getCamera();
            
            if (!cam) {
                trace("No camera is installed.");
            }else {
                connectCamera();
            }
        }

        private function connectCamera():void {
            vid = new Video();
            vid.width = cam.width;
            vid.height = cam.height; 
            vid.attachCamera(cam);
            addChild(vid);    

            stage.addEventListener(MouseEvent.CLICK, clickHandler);
        }
    
        private function clickHandler(e:MouseEvent):void {

            switch (cam.width) {
                case 160:
                cam.setMode(320, 240, 10); 
                break;
                case 320:
                cam.setMode(640, 480, 5); 
                break;
                default:
                cam.setMode(160, 120, 15); 
                break;
            } 

            removeChild(vid);           
            connectCamera();
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/fps"><linktext>fps</linktext></link><link href="flash.media.xml#Camera/height"><linktext>height</linktext></link><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.net.xml#NetStream/attachCamera()"><linktext>flash.net.NetStream.attachCamera()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMotionLevel"><apiName>setMotionLevel</apiName><shortdesc>
	 指定分派 activity 事件所需的运动量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMotionLevel, setMotionLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>motionLevel</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>指定分派 <codeph>activity</codeph> 事件所需的运动量。可接受值的范围为 0 到 100。默认值为 50。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>2000</apiData><apiDesc>指定在没有活动的情况下经过多长时间（以毫秒为单位）后，Flash Player 才会认为活动已停止并分派 <codeph>activity</codeph> 事件。默认值为 2000 毫秒（2 秒）。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定分派 <codeph>activity</codeph> 事件所需的运动量。可以选择设置在没有活动的情况下经过多长时间（以毫秒为单位）后，Flash Player 才会认为动作已停止并分派该事件。 
	 <p><b>注意：</b>不管 <codeph>motionLevel</codeph> 参数值是什么，都可以显示视频。此参数只确定在何时以及哪些情况下分派事件，并不确定实际上是在捕获视频还是显示视频。</p>
	 <p>
	 要完全阻止摄像头检测动作，请将值 100 传递到 <codeph>motionLevel</codeph> 参数；从不分派 <codeph>activity</codeph> 事件。（您可能只将此值用于测试目的 -- 例如，暂时禁用在分派事件时通常会触发的任何处理函数。）
	 </p>
	 <p>
	 要确定摄像头当前检测到的运动量，请使用 <codeph>activityLevel</codeph> 属性。运动敏感度值直接对应于活动值。完全不运动对应于活动值 0。持续运动对应于活动值 100。您不移动时，活动值小于运动敏感度值；当您移动时，活动值通常会超过运动敏感度值。
	 </p>
	 <p>
	 此方法和 <codeph>Microphone.setSilenceLevel()</codeph> 方法在目的上类似；这两种方法都用于指定应该在何时分派 <codeph>activity</codeph> 事件。不过，这两种方法在对发布流的影响上具有显著的差异：
	 </p>
	 
	 <ul>
	   <li><codeph>Microphone.setSilenceLevel()</codeph> 设计用于优化带宽。在认为音频流被静音时，不发送任何音频数据。而改为发送一条指示静音已启动的消息。 </li>
	   <li><codeph>Camera.setMotionLevel()</codeph> 设计用于检测运动，并且不影响带宽用量。即使视频流未检测到运动，仍将发送视频。</li>
	 </ul>
	   
	 
	 
	 </apiDesc><example conref="examples\Camera_setMotionLevelExample.as"> 在下面的示例中，将用户的摄像头用作监视器或监视摄像头。摄像头检测运动，文本字段显示活动级别。（可以扩展此示例，以使其发出警报声音或将通过 Web 服务向其它应用程序发送消息。）
 
 <p><codeph>Camera.getCamera()</codeph> 方法将返回对 camera 对象的引用，如果没有可用的摄像头或未安装摄像头，则返回 null。if 语句检查摄像头是否可用，并在摄像头可用时调用 <codeph>connectCamera()</codeph> 方法。<codeph>connectCamera()</codeph> 方法使用捕获的流的宽度和高度实例化视频对象。要显示摄像头捕获的视频，请将对视频流的引用附加到该视频对象，并将该视频对象添加到显示列表中。（通常，在调用 <codeph>attachCamera()</codeph> 方法时，将出现一个对话框，提示用户允许或拒绝 Flash Player 访问该摄像头。但是，如果用户拒绝访问并选择了<codeph>“记住”</codeph>选项，则不会出现该对话框并且不会显示任何信息。要确保用户可以使用允许访问摄像头的选项，请使用 <codeph>system.Security.showSettings()</codeph> 方法来调用“Flash Player 设置”对话框。）</p>
 
 <p><codeph>setMotionLevel()</codeph> 方法在调用 activity 事件前将最动作的活动级别（运动量）设置为 5。摄像头停止检测运动时与调用 activity 事件时之间的时间设置为 1 秒（1000 毫秒）。在经过 1 秒没有活动的时间或活动级别达到 5 后，将分派 <codeph>ActivityEvent.ACTIVITY</codeph> 事件并调用 <codeph>activityHandler()</codeph> 方法。如果该事件由活动级别触发，则将 <codeph>activating</codeph> 属性设置为 <codeph>true</codeph> 并且启动 Timer 对象。每秒都会分派 Timer 对象的 timer 事件并调用 <codeph>timerHandler()</codeph> 方法，该方法会显示当前的活动级别。（尽管 5 级或更大的级别会触发计时器，但显示的当前活动级别可能是一个较小的数字。）</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.ActivityEvent;

    public class Camera_setMotionLevelExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);

        public function Camera_setMotionLevelExample() {
            myTextField = new TextField();
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";

            }else {
                myTextField.text = "Waiting to connect.";
                connectCamera(); 
            }

            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                cam.setMotionLevel(5, 1000);
                cam.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
        }

        private function activityHandler(e:ActivityEvent):void {
            if (e.activating == true) {
                t.start();    
            } else {
                myTextField.text = "Everything is quiet.";
                t.stop();
            }    
        }

        private function timerHandler(event:TimerEvent):void {
             myTextField.x = 10;
             myTextField.y = cam.height + 20;
             myTextField.text = "There is some activity. Level: " + cam.activityLevel;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/motionTimeout"><linktext>motionTimeout</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>Microphone.setSilenceLevel()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setQuality"><apiName>setQuality</apiName><shortdesc>
	 设置每秒的最大带宽或当前输出视频输入信号所需的画面质量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera.setQuality, setQuality
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bandwidth</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>指定当前输出视频输入信号可以使用的最大带宽，以每秒字节数为单位。要指定 Flash Player 视频可以使用所需数量的带宽来保持 <codeph>quality</codeph> 的值，请为 <codeph>bandwidth</codeph> 传递 0。默认值为 16384。	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个整数，指定所需的画面质量级别，该级别由应用于每一视频帧的压缩量确定。可接受的值的范围为 1（最低品质，最大压缩）到 100（最高品质，无压缩）。要指定画面质量可以根据需要进行变化以避免超出带宽，请将 0 传递给 <codeph>quality</codeph>。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 设置每秒的最大带宽或当前输出视频输入信号所需的画面质量。此方法通常只在使用 Flash Media Server 传输视频时适用。
	 
	 <p>使用此方法可以指定输出视频输入信号的哪一方面对于您的应用程序更重要：是带宽使用率还是图片品质。</p>
	 
	 <ul>
	   <li>要指示带宽使用率更为重要，请将一个值传递给 <codeph>bandwidth</codeph> 并将 0 传递给 <codeph>quality</codeph>。Flash Player 将在指定的带宽内以可能的最高品质传输视频。如有必要，Flash Player 将降低图片品质以避免超出指定的带宽。通常，随着运动的增加，质量将降低。</li>
	   <li>要指示品质更为重要，请将 0 传递给 <codeph>bandwidth</codeph> 并将一个数值传递给 <codeph>quality</codeph>。Flash Player 使用所需数量的带宽来保持指定的品质。如有必要，Flash Player 将降低帧速率以保持图片品质。通常，随着运动的增加，带宽的使用率也将增加。</li>
	   <li>要指定带宽和品质同等重要，请为这两个参数都传递数值。Flash Player 将传输达到指定品质并且不超过指定带宽的视频。如有必要，Flash Player 将降低帧速率以保持图片品质，而不会超出指定的带宽。</li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/quality"><linktext>quality</linktext></link></related-links></apiOperation><apiValue id="flash.media:Camera:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 摄像头正在检测的运动量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 摄像头正在检测的运动量。该数值的范围为 0（检测到没有运动）到 100（检测到大运动量）。该属性的值可帮助确定是否需要将设置传递到 <codeph>setMotionLevel()</codeph> 方法。
	 <p>如果摄像头可用，但由于未调用 <codeph>Video.attachCamera()</codeph> 方法而尚未被使用，则将此属性设置为 -1。</p>
	 <p>如果只对未压缩的本地视频进行流式处理，则只有在为事件处理函数分配函数后才能设置此属性。否则，它为未定义。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:bandwidth:get"><apiName>bandwidth</apiName><shortdesc>
	 当前输出视频输入信号可以使用的最大带宽，以字节为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.bandwidth, bandwidth
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 当前输出视频输入信号可以使用的最大带宽，以字节为单位。值为 0 表示输入信号可以使用所需数量的带宽来保持所需的帧品质。
	 <p>要设置此属性，请使用 <codeph>setQuality()</codeph> 方法。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:currentFPS:get"><apiName>currentFPS</apiName><shortdesc>	
	 摄像头捕获数据的速率，以每秒帧数为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.currentFPS, currentFPS
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>	
	 摄像头捕获数据的速率，以每秒帧数为单位。无法设置此属性；不过，可以使用 <codeph>setMode()</codeph> 方法来设置相关属性 <codeph>fps</codeph>，该属性指定摄像头捕获数据时希望使用的最大帧速率。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:fps:get"><apiName>fps</apiName><shortdesc>
	 摄像头捕获数据的最大速率，以每秒帧数为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.fps, fps
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 摄像头捕获数据的最大速率，以每秒帧数为单位。可能的最大速率取决于摄像头性能；有可能会达不到此帧速率。
	 <ul>
	   <li>要为该属性设置所需值，请使用 <codeph>setMode()</codeph> 方法。</li>
	   <li>要确定摄像头当前捕获数据的速率，请使用 <codeph>currentFPS</codeph> 属性。</li>
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/currentFPS"><linktext>currentFPS</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:height:get"><apiName>height</apiName><shortdesc>
	 当前捕获高度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.height, height
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 当前捕获高度，以像素为单位。要设置此属性的值，请使用 <codeph>setMode()</codeph> 方法。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:index:get"><apiName>index</apiName><shortdesc>
	 从零开始的整数，指定由 names 属性返回的数组中所反映的摄像头的索引。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.index, index
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 从零开始的整数，指定由 <codeph>names</codeph> 属性返回的数组中所反映的摄像头的索引。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:keyFrameInterval:get"><apiName>keyFrameInterval</apiName><shortdesc>
	 完整传输而没有使用视频压缩算法进行插值处理的视频帧（称为关键帧）数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 完整传输而没有使用视频压缩算法进行插值处理的视频帧（称为<i>关键帧</i>）数。默认值为 15，指每隔 14 个帧后的那一帧为关键帧。值为 1 表示每个帧都是关键帧。允许的值为 1 至 48。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setKeyFrameInterval()"><linktext>setKeyFrameInterval()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:loopback:get"><apiName>loopback</apiName><shortdesc>
	 指示在本地查看摄像头所捕获的图像时是进行压缩和解压缩 (true)，就像使用 Flash Media Server 进行实时传输一样，还是不进行压缩 (false)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 指示在本地查看摄像头所捕获的图像时是进行压缩和解压缩 (<codeph>true</codeph>)，就像使用 Flash Media Server 进行实时传输一样，还是不进行压缩 (<codeph>false</codeph>)。默认值为 <codeph>false</codeph>。 
	 
	 <p>
	 虽然压缩流在进行测试方面（如预览视频品质设置）非常有用，但会产生大量的处理开销。就像通过实时连接进行传输一样，将对本地查看的内容进行压缩和编辑以进行传输，然后再对其进行解压缩处理以便在本地进行查看。
	 </p>
	 
	 <p>要设置此值，请使用 <codeph>Camera.setLoopback()</codeph>。要设置此属性为 True 时使用的压缩量，请使用 <codeph>Camera.setQuality()</codeph>。</p>
	  
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setLoopback()"><linktext>setLoopback()</linktext></link><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionLevel:get"><apiName>motionLevel</apiName><shortdesc>
	 调用 activity 事件所需的运动量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionLevel, motionLevel
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 调用 <codeph>activity</codeph> 事件所需的运动量。可接受值的范围为 0 到 100。默认值为 50。
	 <p>不论 <codeph>motionLevel</codeph> 属性为何值都能显示视频。有关详细信息，请参阅 <codeph> setMotionLevel()</codeph>。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionTimeout:get"><apiName>motionTimeout</apiName><shortdesc>
	 摄像头停止检测运动的时间与调用 activity 事件的时间之间相差的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionTimeout, motionTimeout
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 摄像头停止检测运动的时刻和调用 <codeph>activity</codeph> 事件的时刻之间相差的毫秒数。默认值为 2000（2 秒）。 
	 <p>要设置此值，请使用 <codeph>setMotionLevel()</codeph>。 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:muted:get"><apiName>muted</apiName><shortdesc>
	 布尔值，指示用户在 Flash Player 的“隐私”对话框中是拒绝访问摄像头 (true) 还是允许访问 (false)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.muted, muted
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 布尔值，指示用户在 Flash Player 的“隐私”对话框中是拒绝访问摄像头 (<codeph>true</codeph>) 还是允许访问 (<codeph>false</codeph>)。当此值变化时，将分派 <codeph>status</codeph> 事件。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:name:get"><apiName>name</apiName><shortdesc>
	 由摄像头硬件返回的当前摄像头的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.name, name
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 由摄像头硬件返回的当前摄像头的名称。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:names:get"><apiName>names</apiName><shortdesc>
	 字符串数组，指示所有可用的摄像头名称，而不显示 Flash Player 的“隐私”对话框。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.names, names
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 字符串数组，指示所有可用的摄像头名称，而不显示 Flash Player 的“隐私”对话框。此数组的行为方式与其它任何 ActionScript 数组的行为方式相同，隐式提供每一摄像头从零开始的索引以及系统上摄像头的数目（通过 <codeph>names.length</codeph>）。有关详细信息，请参阅 <codeph>names</codeph> Array 类条目。
	 
	 <p>调用 <codeph>names</codeph> 属性要求全面检查硬件，并可能需要几秒钟时间才能生成数组。在大多数情况下，您只能使用默认的摄像头。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/name"><linktext>name</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:quality:get"><apiName>quality</apiName><shortdesc>
	 所需的图片品质级别，该级别是由应用于每个视频帧的压缩量决定的。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.quality, quality
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 所需的图片品质级别，该级别是由应用于每个视频帧的压缩量决定的。可接受的品质值范围为 1（最低品质，最大压缩）到 100（最高品质，无压缩）。默认值为 0，这意味着画面质量可以根据需要进行变化，以避免超出可用带宽。
	 
	 <p>要设置此属性，请使用 <codeph>setQuality()</codeph> 方法。</p>
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:width:get"><apiName>width</apiName><shortdesc>
	 当前捕获宽度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.width, width
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 当前捕获宽度，以像素为单位。要为该属性设置所需值，请使用 <codeph>setMode()</codeph> 方法。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
 SoundTransform 类包含音量和平移的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 SoundTransform 类包含音量和平移的属性。 
 
 </apiDesc><example conref="examples\SoundTransformExample.as"> 以下示例将加载并播放 MP3 文件。当播放 MP3 文件时，移动鼠标；将鼠标移到舞台上时，音量和平移会发生变化。要运行此示例，请将一个名为 MySound.mp3 的文件放在 SWF 文件所在的同一目录中。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundTransformExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundTransformExample() {
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;

            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.load(request);
            channel = soundFactory.play();
            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function setPan(pan:Number):void {
            trace("setPan: " + pan.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.pan = pan;
            channel.soundTransform = transform;
        }

        private function setVolume(volume:Number):void {
            trace("setVolume: " + volume.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.volume = volume;
            channel.soundTransform = transform;
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            var halfStage:uint = Math.floor(stage.stageWidth / 2);
            var xPos:uint = event.stageX;
            var yPos:uint = event.stageY;
            var value:Number;
            var pan:Number;

            if (xPos > halfStage) {
                value = xPos / halfStage;
                pan = value - 1;
            } else if (xPos &lt; halfStage) {
                value = (xPos - halfStage) / halfStage;
                pan = value;
            } else {
                pan = 0;
            }

            var volume:Number = 1 - (yPos / stage.stageHeight);

            setVolume(volume);
            setPan(pan);
            
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#SimpleButton/soundTransform"><linktext>flash.display.SimpleButton.soundTransform</linktext></link><link href="flash.display.xml#Sprite/soundTransform"><linktext>flash.display.Sprite.soundTransform</linktext></link><link href="flash.media.xml#Microphone/soundTransform"><linktext>flash.media.Microphone.soundTransform</linktext></link><link href="flash.media.xml#SoundChannel/soundTransform"><linktext>flash.media.SoundChannel.soundTransform</linktext></link><link href="flash.media.xml#SoundMixer/soundTransform"><linktext>flash.media.SoundMixer.soundTransform</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link></related-links><apiConstructor id="flash.media:SoundTransform:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
	 创建 SoundTransform 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vol</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>音量范围从 0（静音）至 1（最大音量）。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>panning</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>声音从左到右的平移，范围从 -1（左侧最大平移）至 1（右侧最大平移）。值 0 表示没有平移（居中）。 
	 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建 SoundTransform 对象。 
	 
	 </apiDesc><example conref="examples\SoundTransform_constructorExample.as"> 在下面的示例中，仅从右声道中播放声音，并将音量设置为 50%。
 
 <p>在构造函数中，加载了声音并将其分配给一个声道 (<codeph>channel</codeph>)。还会创建一个 SoundTranform 对象 (<codeph>transform</codeph>)。它的第一个参数将音量设置为 50%（范围从 0.0 到 1.0）。它的第二个参数设置平移。在本示例中，将平移设置为 1.0，这表示仅从右扬声器中播放声音。为了使这些设置生效，将 <codeph>transform</codeph> SoundTranform 对象分配给了声道的 <codeph>souundTransform</codeph> 属性。</p> 
<p> <b>注意：</b>仅为本示例编写了有限的错误处理代码。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.events.IOErrorEvent;

    public class SoundTransform_constructorExample extends Sprite
    {
        public function SoundTransform_constructorExample() {
            var mySound:Sound = new Sound();
            var url:URLRequest = new URLRequest("mySound.mp3");
            var channel:SoundChannel;
            var transform:SoundTransform = new SoundTransform(0.5, 1.0);

            mySound.load(url);    
            channel = mySound.play();
            channel.soundTransform = transform;

            mySound.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundTransform:leftToLeft:set"><apiName>leftToLeft</apiName><shortdesc>
	 从 0（无）至 1（全部）的值，指定了左输入在左扬声器里播放的量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 从 0（无）至 1（全部）的值，指定了左输入在左扬声器里播放的量。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:leftToRight:set"><apiName>leftToRight</apiName><shortdesc>
	 从 0（无）至 1（全部）的值，指定了左输入在右扬声器里播放的量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 从 0（无）至 1（全部）的值，指定了左输入在右扬声器里播放的量。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:pan:set"><apiName>pan</apiName><shortdesc>
	 声音从左到右的平移，范围从 -1（左侧最大平移）至 1（右侧最大平移）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 声音从左到右的平移，范围从 -1（左侧最大平移）至 1（右侧最大平移）。值 0 表示没有平移（在左侧和右侧之间平衡居中）。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToLeft:set"><apiName>rightToLeft</apiName><shortdesc>
	 从 0（无）至 1（全部）的值，指定了右输入在左扬声器里播放的量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 从 0（无）至 1（全部）的值，指定了右输入在左扬声器里播放的量。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToRight:set"><apiName>rightToRight</apiName><shortdesc>
	 从 0（无）至 1（全部）的值，指定了右输入在右扬声器里播放的量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 从 0（无）至 1（全部）的值，指定了右输入在右扬声器里播放的量。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:volume:set"><apiName>volume</apiName><shortdesc>
	 音量范围从 0（静音）至 1（最大音量）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 音量范围从 0（静音）至 1（最大音量）。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Sound"><apiName>Sound</apiName><shortdesc>
  Sound 类允许您在应用程序中使用声音。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
  </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  Sound 类允许您在应用程序中使用声音。使用 Sound 类可以创建 Sound 对象、将外部 MP3 文件加载到该对象并播放该文件、关闭声音流，以及访问有关声音的数据，如有关流中字节数和 ID3 元数据的信息。可通过以下项对声音执行更精细的控制：声音源（声音的 SoundChannel 或 Microphone 对象）和 SoundTransform 类中用于控制向计算机扬声器输出声音的属性。 
  
  <p>在 Flash Player 10 及更高版本和 AIR 1.5 及更高版本中，也可以使用此类来处理动态生成的声音。在这种情况下，Sound 对象将使用向 <codeph>sampleData</codeph> 事件处理函数分配的函数来轮询声音数据。从用声音数据填充的 ByteArray 对象检索声音的同时播放声音。可以使用 <codeph>Sound.extract()</codeph> 从 Sound 对象中提取声音数据，然后在将声音数据写回到流以进行播放之前可以对其进行操作。</p>
  
  <p>要控制嵌入到 SWF 文件的声音，请使用 SoundMixer 类中的属性。</p>
  
  <p platform="actionscript"><b>注意</b>：ActionScript 3.0 的 Sound API 与 ActionScript 2.0 不同。在 ActionScript 3.0 中，将无法采用声音对象并在层次结构中对其进行排列以控制其属性。</p>
  
  <p>在使用此类时，请考虑以下安全模型： </p>
  
  <ul>
  
      <li>如果执行调用的 文件在网络沙箱中，并且要加载的声音文件是本地文件，则不允许加载和播放声音。</li>
  
      <li>默认情况下，若执行调用的文件是本地文件并且试图加载和播放远程声音，则不允许加载和播放声音。用户必须授予明确许可才能允许此类访问。</li>
  
      <li>某些处理声音的操作受到限制。除非您实现了一个跨域策略文件，否则处于其它域的 文件无法访问已加载声音中的数据。受此限制约束的与声音相关的 API 为 <codeph>Sound.id3</codeph>、<codeph>SoundMixer.computeSpectrum()</codeph>、<codeph>SoundMixer.bufferTime</codeph> 和 <codeph>SoundTransform</codeph> 类。</li>
  
  </ul>
  
  <p>但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
  
  <p>有关安全性的详细信息，请参阅以下部分：</p>
  
  <ul>
  
  <li product="flex">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
  <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
  
    <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
  
  </ul>
  
  </apiDesc><example conref="examples\SoundExample.as"> 以下示例显示有关打开并播放 MP3 文件时发生的声音事件的信息。要运行此示例，请将一个名为 MySound.mp3 的文件放在 SWF 文件所在的同一目录中。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;

    public class SoundExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var song:SoundChannel;

        public function SoundExample() {
            var request:URLRequest = new URLRequest(url);
            var soundFactory:Sound = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);
            song = soundFactory.play();
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.media.xml#Microphone"><linktext>Microphone</linktext></link><link href="flash.media.xml#SoundChannel"><linktext>SoundChannel</linktext></link><link href="flash.media.xml#SoundMixer"><linktext>SoundMixer</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:Sound_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 在加载操作进行过程中接收到数据时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在加载操作进行过程中接收到数据时分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 在加载操作开始时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在加载操作开始时分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 在出现输入/输出错误并由此导致加载操作失败时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在出现输入/输出错误并由此导致加载操作失败时分派。 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.ID3_id3"><apiName>id3</apiName><shortdesc>
 在存在可用于 MP3 声音的 ID3 数据时由 Sound 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ID3</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在存在可用于 MP3 声音的 ID3 数据时由 Sound 对象分派。 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 成功加载数据后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 成功加载数据后分派。 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.SAMPLE_DATA_sampleData"><apiName>sampleData</apiName><shortdesc>
  当播放器请求新的音频数据时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SAMPLE_DATA</apiEventType><adobeApiEventClassifier>flash.events.SampleDataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  当播放器请求新的音频数据时分派。 
 
 </apiDesc><example conref="examples\Sound_SampleDataExample.as"> 下面的示例播放简单的正弦波。
 
<codeblock>
var mySound:Sound = new Sound();
function sineWaveGenerator(event:SampleDataEvent):void {
    for ( var c:int=0; c&lt;8192; c++ ) {
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
    }
}

mySound.addEventListener(Event.SAMPLE_DATA,sineWaveGenerator);
mySound.play();
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/extract()"><linktext>extract()</linktext></link><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.events.xml#SampleDataEvent"><linktext>flash.events.SampleDataEvent</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.media:Sound:Sound"><apiName>Sound</apiName><shortdesc>
     创建一个新的 Sound 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiData>null</apiData><apiDesc> 指向外部 MP3 文件的 URL。
     
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> 一个可选的 SoundLoader 上下文对象，可以定义缓冲时间（MP3 数据保留到 Sound 对象的缓冲区中所需的最小毫秒数）并且可以指定加载声音前应用程序是否应该检查跨域策略文件。
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建一个新的 Sound 对象。如果将有效的 URLRequest 对象传递到 Sound 构造函数，该构造函数将自动调用 Sound 对象的 <codeph>load()</codeph> 函数。如果未将有效的 URLRequest 对象传递到 Sound 构造函数，则必须自己调用 Sound 对象的 <codeph>load()</codeph> 函数，否则将不加载流。
     
     <p>一旦对某个 Sound 对象调用了 <codeph>load()</codeph>，就不能再将另一个声音文件加载到该 Sound 对象中。要加载另一个声音文件，请创建新的 Sound 对象。</p>
     
     在 Flash Player 10 及更高版本和 AIR 1.5 及更高版本中，可以使用 <codeph>sampleData</codeph> 事件处理函数将声音动态加载到 Sound 对象中，而不是使用 <codeph>load()</codeph>。
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Sound:close"><apiName>close</apiName><shortdesc>
     关闭该流，从而停止所有数据的下载。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>无法关闭该流，或者该流未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     关闭该流，从而停止所有数据的下载。调用 <codeph>close()</codeph> 方法之后，将无法从流中读取数据。
     
     </apiDesc><example conref="examples\Sound_closeExample.as"> 在下面的示例中，当用户单击 Stop 按钮时，将调用 <codeph>Sound.close()</codeph> 方法并停止声音流。
 
 <p>在构造函数中，为 Start 和 Stop 按钮创建了一个文本字段。当用户单击文本字段时，将调用 <codeph>clickHandler()</codeph> 方法。它处理声音文件的启动和停止操作。请注意，根据网络连接情况或用户单击 Stop 按钮的时间，可能已加载了大部分文件，并且可能需要经过一段时间后才能停止播放声音文件。<codeph>try...catch</codeph> 块用于捕获在关闭流时可能发生的任何 IO 错误。例如，如果从本地目录中加载声音而没有进行流式传输，则会捕获到错误 2029，指出“此 URLStream 对象没有打开的流”。</p> 
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;    
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.errors.IOError;
    import flash.events.IOErrorEvent;

    public class Sound_closeExample extends Sprite {
        private var snd:Sound = new Sound();
        private var button:TextField = new TextField();
        private var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
        
        public function Sound_closeExample() {
            button.x = 10;
            button.y = 10;
            button.text = "START";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.LEFT;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {

            if(button.text == "START") {

                snd.load(req);
                snd.play();        

                snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);

                button.text = "STOP";
            }
            else if(button.text == "STOP") {
                    
                try {
                    snd.close();
                    button.text = "Wait for loaded stream to finish.";
                }
                catch (error:IOError) {
                    button.text = "Couldn't close stream " + error.message;    
                }
            }
        }
        
        private function errorHandler(event:IOErrorEvent):void {
                button.text = "Couldn't load the file " + event.text;
        }
    }
}


</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:extract"><apiName>extract</apiName><shortdesc>
      从 Sound 对象提取原始声音数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Sound 对象中可用的样本数。
     
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>用于放置提取的声音样本的 ByteArray 对象。
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要提取的声音样本数。样本包含左声道和右声道，即 2 个 32 位浮点值。
          
     </apiDesc></apiParam><apiParam><apiItemName>startPosition</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>-1</apiData><apiDesc>开始提取处的样本。如果未指定值，则对 <codeph>Sound.extract()</codeph> 的第一个调用将在声音的开头启动；未指定 <codeph>startPosition</codeph> 值的后续调用将按顺序通过该文件。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
      从 Sound 对象提取原始声音数据。
     
      <p>当您通过将分配给 <codeph>sampleData</codeph> 事件的函数用于不同的 Sound 对象，从而使用动态生成的音频时，可以使用此方法。即，您可以使用此方法从 Sound 对象中提取声音数据。然后，可以将此数据写入另一 Sound 对象用于对动态音频进行流式处理的字节数组。</p>
     
      <p>将音频数据放在目标字节数组中（从该字节数组的当前位置开始）。音频数据始终公开为 44100 Hz 立体声。样本类型是一个 32 位浮点值，可以使用 <codeph>ByteArray.readFloat()</codeph> 将该值转换为一个数字。 </p>
     
     </apiDesc><example conref="examples\Sound_extractExample.as"> 下面的示例加载一个 mp3 文件并使用 Sound 类的 <codeph>extract()</codeph> 方法来访问音频数据。
 <p>此 mp3 数据将加载到 <codeph>sourceSnd</codeph> Sound 对象中。当应用程序加载 mp3 数据时，它将调用 <codeph>loaded()</codeph> 函数（<codeph>sourceSnd</codeph> 对象的 <codeph>complete</codeph> 事件的事件处理函数）。第二个 Sound 对象 <codeph>outputSound</codeph> 用于播放修改后的音频。<codeph>outputSound</codeph> 对象具有一个 <codeph>sampleData</codeph> 事件侦听器；这样，一旦您调用该对象的 <codeph>play()</codeph> 方法，该对象将分派定期的 <codeph>sampleData</codeph> 事件。<codeph>upOctave()</codeph> 方法将返回一个基于源音频数据的修改后的音频数据的字节数组。该方法通过间隔跳过源数据中的音频采样，返回高一个八度的音频。<codeph>sampleData</codeph> 事件的事件处理函数将返回的字节数组写入到 <codeph>outputSound</codeph> 对象的 <codeph>data</codeph> 属性中。将 <codeph>data</codeph> 字节数组追加到 <codeph>outputSound</codeph> 对象的输出音频数据中。</p>
 <p>要测试此示例，请将 test.mp3 文件添加到 SWF 文件所在的同一目录中。</p>
<codeblock>

var sourceSnd:Sound = new Sound();
var outputSnd:Sound = new Sound();
var urlReq:URLRequest = new URLRequest("test.mp3");

sourceSnd.load(urlReq);
sourceSnd.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void
{
    outputSnd.addEventListener(SampleDataEvent.SAMPLE_DATA, processSound);
    outputSnd.play();
}

function processSound(event:SampleDataEvent):void
{
    var bytes:ByteArray = new ByteArray();
    sourceSnd.extract(bytes, 4096);
    event.data.writeBytes(upOctave(bytes));
}

function upOctave(bytes:ByteArray):ByteArray
{
    var returnBytes:ByteArray = new ByteArray();
    bytes.position = 0;
    while(bytes.bytesAvailable > 0)
    {
        returnBytes.writeFloat(bytes.readFloat());
        returnBytes.writeFloat(bytes.readFloat());
        if (bytes.bytesAvailable > 0)
        {
            bytes.position += 8;
        }
    }
    return returnBytes;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.media.xml#Sound/event:sampleData"><linktext>sampleData</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Sound:load"><apiName>load</apiName><shortdesc>
     启动从指定 URL 加载外部 MP3 文件的过程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>网络错误导致加载失败。
	 
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>本地不受信任的 文件可能无法与 Internet 进行通信。可通过将此文件重新分类为<ph platform="actionscript">只能与远程内容交互或</ph>受信任来解决此问题。
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果尝试连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>stream</codeph> 对象的 <codeph>digest</codeph> 属性不是 <codeph>null</codeph>。如果在加载 SWZ 文件（一个 Adobe 平台组件）时调用 <codeph>URLLoader.load()</codeph> 方法，仅应设置 URLRequest 对象的 <codeph>digest</codeph> 属性。
     
      </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>如果尝试连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> 指向外部 MP3 文件的 URL。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> 一个可选的 SoundLoader 上下文对象，可以定义缓冲时间（MP3 数据保留到 Sound 对象的缓冲区中所需的最小毫秒数）并且可以指定加载声音前应用程序是否应该检查跨域策略文件。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     启动从指定 URL 加载外部 MP3 文件的过程。如果为 Sound 构造函数提供有效的 URLRequest 对象，该构造函数将为您调用 <codeph>Sound.load()</codeph>。只有在未将有效的 URLRequest 对象传递到 Sound 构造函数或传递了 <codeph>null</codeph> 值的情况下，才需要自己调用 <codeph>Sound.load()</codeph>。
     
     <p>一旦对某个 Sound 对象调用了 <codeph>load()</codeph>，就不能再将另一个声音文件加载到该 Sound 对象中。要加载另一个声音文件，请创建新的 Sound 对象。</p>
     
	 <p platform="actionscript">在使用此方法时，请考虑以下安全模型：</p>
     
     <ul platform="actionscript">
     
     <li>如果执行调用的 文件在只能与本地文件系统的内容交互的沙箱中，并且声音在网络沙箱中，则不允许调用 <codeph>Sound.load()</codeph>。</li>
     
     <li>从受信任的本地沙箱或只能与远程内容交互的沙箱进行访问需要通过 URL 策略文件获得网站的许可。</li>
     
      <li>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。 </li>
     
     <li>可以在包含 SWF 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数，从而防止 SWF 文件使用此方法。</li>
     
     </ul>
     
     <p platform="actionscript"> 在 Flash Player 10 和更高版本中，如果使用包含上载（由 POST 体内的“content-disposition”标头中的“filename”参数表示）的 multipart Content-Type（例如“multipart/form-data”），则 POST 操作会受应用于上载的安全规则的约束：</p>
	 <ul platform="actionscript">
	 <li>必须执行 POST 操作以响应用户启动的操作（如鼠标单击或按键）。</li>
	 <li>如果 POST 操作是跨域的（POST 目标与发送 POST 请求的 SWF 文件不在同一台服务器上），则目标服务器必须提供一个允许跨域访问的 URL 策略文件。</li>
	 </ul>
     <p platform="actionscript">另外，对于任何 multipart Content-Type，语法必须有效（根据 RFC2046 标准）。如果语法无效，则 POST 操作受应用于上载的安全规则约束。</p>
     <p platform="actionscript">在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
     
     <p platform="actionscript">有关与安全性相关的详细信息，请参阅以下部分：</p>
     
     <ul platform="actionscript">
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     <li><i>Developing AIR Applications</i>（《开发 AIR 应用程序》）一书的“Getting started with Adobe AIR”（Adobe AIR 入门）一章中的“Understanding AIR Security”（了解 AIR 安全性）一节。</li>
       <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
     </ul>
     
     </apiDesc><example conref="examples\Sound_loadExample.as"> 下面的示例显示了声音文件的加载进度。
 
 <p>在构造函数中，创建了一个 <codeph>URLRequest</codeph> 对象以确定声音文件（来自 Adobe 的播客）的位置。将在 <codeph>try...catch</codeph> 块中加载该文件，以便捕获在加载文件时可能发生的任何错误。如果发生 IO 错误，还会调用 <codeph>errorHandler()</codeph> 方法，并在用于显示进度报告的文本字段中写入错误消息。当加载操作正在进行时，将分派 <codeph>ProgressEvent.PROGRESS</codeph> 事件并调用 <codeph>progressHandler()</codeph> 方法。此处，使用 <codeph>ProgressEvent.PROGRESS</codeph> 事件作为计时器来计算加载进度。</p> 
  
 <p><codeph>progressHandler()</codeph> 方法将随 <codeph>ProgressEvent</codeph> 对象传递的 <codeph>bytesLoaded</codeph> 值除以 <codeph>bytesTotal</codeph> 值，以得出正在加载的声音数据的百分比。然后，它在文本字段中显示这些值。（请注意，如果文件很小、已缓存或位于本地目录中，则进度可能不太明显。）</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.ProgressEvent;
    import flash.events.IOErrorEvent;
    
    public class Sound_loadExample extends Sprite {
        private var snd:Sound = new Sound();
        private var statusTextField:TextField  = new TextField();

        public function Sound_loadExample(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
            snd.load(req);
            
            snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(ProgressEvent.PROGRESS, progressHandler);
                     
            this.addChild(statusTextField);
        }
    
        private function progressHandler(event:ProgressEvent):void {
            var loadTime:Number = event.bytesLoaded / event.bytesTotal;
            var LoadPercent:uint = Math.round(100 * loadTime);
              
            statusTextField.text = "Sound file's size in bytes: " + event.bytesTotal + "\n" 
                                 + "Bytes being loaded: " + event.bytesLoaded + "\n" 
                                 + "Percentage of sound file that is loaded " + LoadPercent + "%.\n";
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:play"><apiName>play</apiName><shortdesc>
     生成一个新的 SoundChannel 对象来回放该声音。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>SoundChannel 对象，用于控制声音。如果没有声卡或用完了可用的声道，此方法将返回 <codeph>null</codeph>。一次最多可以使用 32 个声道。
     
     </apiDesc><apiOperationClassifier>flash.media:SoundChannel</apiOperationClassifier></apiReturn><apiParam><apiItemName>startTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>应开始回放的初始位置（以毫秒为单位）。
     </apiDesc></apiParam><apiParam><apiItemName>loops</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>定义在声道停止回放之前，声音循环回 <codeph>startTime</codeph> 值的次数。 
     </apiDesc></apiParam><apiParam><apiItemName>sndTransform</apiItemName><apiOperationClassifier>flash.media:SoundTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>分配给该声道的初始 SoundTransform 对象。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     生成一个新的 SoundChannel 对象来回放该声音。此方法返回 SoundChannel 对象，访问该对象可停止声音并监控音量。（要控制音量、平移和平衡，请访问分配给声道的 SoundTransform 对象。）
     
     </apiDesc><example conref="examples\Sound_playExample1.as"> 在下面的示例中，加载文件后，使用图形栏的用户可以选择声音文件的起始位置（开始时间）。
 
 <p>构造函数调用 <codeph>Sound.load()</codeph> 方法以开始加载声音数据。接下来，它调用 <codeph>Sound.play()</codeph> 方法；在加载了足够多的数据后，此方法将立即开始播放声音。<codeph>Sound.play()</codeph> 方法返回 SoundChannel 对象，该对象可用于控制声音回放。文本字段中显示了相关说明。要确保已加载了用户希望从中开始播放声音的内容，请创建 <codeph>bar</codeph> Sprite 对象，在加载完文件后将显示该对象。成功加载文件后，将分派一个 <codeph>Event.COMPLETE</codeph> 事件，此事件触发 <codeph>completeHandler()</codeph> 方法。<codeph>completeHandler()</codeph> 方法随后创建图形栏，并将其添加到显示列表中。（使用 Sprite 对象来支持交互功能，而不是形状对象。）当用户单击图形栏时，将触发 <codeph>clickHandler()</codeph> 方法。</p> 
 
 <p>在 <codeph>clickHandler()</codeph> 方法中，使用用户单击的 x 坐标位置 <codeph>event.localX</codeph> 来确定用户希望从中开始播放文件的位置。由于图形栏为 100 个像素并且从 x 坐标 100 个像素处开始，因此很容易确定位置的百分比。另外，由于加载了文件，声音文件的 <codeph>length</codeph> 属性将具有完整文件的长度（以毫秒为单位）。通过使用声音文件的长度和行中的位置，可以确定声音文件的起始位置。停止播放声音后，声音文件将在选定的起始位置重新开始播放，此位置是作为 <codeph>play()</codeph> 方法的 <codeph>startTime</codeph> 参数传递的。</p>
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.MouseEvent;
    import flash.media.Sound;;
    import flash.net.URLRequest;
    import flash.media.SoundChannel;
    import flash.events.ProgressEvent;
    import flash.events.Event;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample1 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var infoTextField:TextField = new TextField();
    
        public function Sound_playExample1() {

            var req:URLRequest = new URLRequest("MySound.mp3");
            
            infoTextField.autoSize = TextFieldAutoSize.LEFT;
            infoTextField.text = "Please wait for the file to be loaded.\n" 
                                + "Then select from the bar to decide where the file should start.";
            
            snd.load(req);               
            channel = snd.play();

            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(Event.COMPLETE, completeHandler);


            this.addChild(infoTextField);
        }

        private function completeHandler(event:Event):void {                
            infoTextField.text = "File is ready.";

            var bar:Sprite = new Sprite();

            bar.graphics.lineStyle(5, 0xFF0000);
            bar.graphics.moveTo(100, 100);
            bar.graphics.lineTo(200, 100);

            bar.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(bar);
        }
    
        private function clickHandler(event:MouseEvent):void {
            
                var position:uint = event.localX;
                var percent:uint = Math.round(position) - 100;   
                var cue:uint = (percent / 100) * snd.length;

                channel.stop();
                channel = snd.play(cue);    
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            infoTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample2.as"> 在下面的示例中，根据用户是单击还是双击按钮，将播放一次或两次声音。
 
 <p>在构造函数中，加载了声音并创建了一个简单的矩形 <codeph>button</codeph> Sprite 对象。（使用 Sprite 对象来支持交互功能，而不是形状对象。）此处，假定声音文件位于与 SWF 文件相同的目录中。（没有为本示例编写错误处理代码。）</p>
 
 <p>设置了两个事件侦听器以响应鼠标单击和双击。如果用户单击一下，将调用 <codeph>clickHandler()</codeph> 方法以播放该声音。如果用户双击按钮，将调用 <codeph>doubleClickHandler()</codeph> 方法以播放两次声音文件。<codeph>play()</codeph> 方法的第二个参数设置为 <codeph>1</codeph>，表示声音将返回到声音开始时间一次并重新播放。开始时间（第一个参数）设置为 <codeph>0</codeph>，表示文件将从开始处播放。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.media.Sound;
    import flash.net.URLRequest;

    public class Sound_playExample2 extends Sprite {
        private var button:Sprite = new Sprite(); 
        private var snd:Sound = new Sound();
            
        public function Sound_playExample2() {

            var req:URLRequest = new URLRequest("click.mp3");
            snd.load(req);               
     
            button.graphics.beginFill(0x00FF00);
            button.graphics.drawRect(10, 10, 50, 30);
            button.graphics.endFill();
     
            button.addEventListener(MouseEvent.CLICK, clickHandler);
            button.addEventListener(MouseEvent.DOUBLE_CLICK, doubleClickHandler);
     
            this.addChild(button);
        }

        private function clickHandler(event:MouseEvent):void {
            snd.play();            
        }

        private function doubleClickHandler(event:MouseEvent):void {
            snd.play(0, 2);        
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample3.as"> 下面的示例显示了声音文件的加载和播放进度。
 
 <p>在构造函数中，在 <codeph>try...catch</codeph> 块中加载了该文件，以便捕获在加载文件时可能发生的任何错误。在声音对象中添加了一个侦听器，它通过调用 <codeph>errorHandler()</codeph> 方法来响应 <codeph>IOErrorEvent</codeph> 事件。还为主应用程序添加了一个侦听器以响应 <codeph>Event.ENTER_FRAME</codeph> 事件，它用作计时机制以显示回放进度。最后，为声道添加了第三个侦听器，它通过调用 <codeph>soundCompleteHandler()</codeph> 方法来响应 <codeph>Event.SOUND_COMPLETE</codeph> 事件（完成声音播放时）。<codeph>soundCompleteHandler()</codeph> 方法还删除了 <codeph>Event.ENTER_FRAME</codeph> 事件的事件侦听器。</p>
 
 <p><codeph>enterFrameHandler()</codeph> 方法将随 <codeph>ProgressEvent</codeph> 对象传递的 <codeph>bytesLoaded</codeph> 值除以 <codeph>bytesTotal</codeph> 值，以得出正在加载的声音数据的百分比。可通过将声道的 <codeph>position</codeph> 属性值除以声音数据长度，来确定正在播放的声音数据的百分比。但是，如果未完全加载声音数据，声音对象的 <codeph>length</codeph> 属性仅显示当前加载的声音数据的大小。估计的完整声音文件的最终大小是使用以下方法计算的：将当前声音对象的 <codeph>length</codeph> 值除以 <codeph>bytesLoaded</codeph> 属性值，再乘以 <codeph>bytesTotal</codeph> 属性值。</p>
 
 <p>请注意，如果文件很小、已缓存或位于本地目录中，则加载进度可能不太明显。另外，从声音数据开始加载到所加载的数据开始播放之间的延迟时间是由 <codeph>SoundLoaderContext.buffertime</codeph> 属性值确定的，此属性的默认值为 1000 毫秒，您可以对其进行重置。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample3 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel;
        private var statusTextField:TextField  = new TextField();

        public function Sound_playExample3(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;

           var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
                snd.load(req);
            
                channel = snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
                    
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            addEventListener(Event.ENTER_FRAME, enterFrameHandler);
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                    
            this.addChild(statusTextField);
        }
    
        private function enterFrameHandler(event:Event):void {    
            var loadTime:Number = snd.bytesLoaded / snd.bytesTotal;
            var loadPercent:uint = Math.round(100 * loadTime);
            var estimatedLength:int = Math.ceil(snd.length / (loadTime));
            var playbackPercent:uint = Math.round(100 * (channel.position / estimatedLength));
      
            statusTextField.text = "Sound file's size is " + snd.bytesTotal + " bytes.\n" 
                                   + "Bytes being loaded: " + snd.bytesLoaded + "\n" 
                                   + "Percentage of sound file that is loaded " + loadPercent + "%.\n"
                                   + "Sound playback is " + playbackPercent + "% complete.";     
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }

        private function soundCompleteHandler(event:Event):void {
            statusTextField.text = "The sound has finished playing.";
            removeEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundChannel/stop()"><linktext>SoundChannel.stop()</linktext></link><link href="flash.media.xml#SoundMixer/stopAll()"><linktext>SoundMixer.stopAll()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Sound:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
     返回此声音对象中当前可用的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     返回此声音对象中当前可用的字节数。此属性通常只对从外部加载的文件有用。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
     返回此声音对象中总的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     返回此声音对象中总的字节数。 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:id3:get"><apiName>id3</apiName><shortdesc>
     提供对作为 MP3 文件一部分的元数据的访问。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sound, Sound.id3, id3, mp3
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.media:ID3Info</apiValueClassifier></apiValueDef><apiDesc>
     提供对作为 MP3 文件一部分的元数据的访问。
     
     <p>MP3 声音文件可以包含 ID3 标签，ID3 标签提供有关该文件的元数据。如果使用 <codeph>Sound.load()</codeph> 方法加载的 MP3 声音包含 ID3 标签，则可以查询这些属性。只支持使用 UTF-8 字符集的 ID3 标签。</p>
     
	 <p><ph outputclass="actionscript">Flash Player 9 及更高版本和 AIR 运行时支持 </ph><ph platform="javascript">AIR 运行时支持 </ph>ID3 2.0 标签，特别是 2.3 和 2.4。以下各表列出了标准 ID3 2.0 标签以及这些标签所表示内容的类型。<codeph>Sound.id3</codeph> 属性通过 <codeph>my_sound.id3.COMM</codeph> 和 <codeph>my_sound.id3.TIME</codeph> 等格式提供对这些标记的访问权限。第一个表描述了可通过 ID3 2.0 属性名称或 ActionScript 属性名称进行访问的标签。第二个表描述了在 ActionScript 中受支持但不具有预定义属性的 ID3 标签。 </p>
     
     <adobetable class="innertable">
       
      
      
      
     
     
     
     
     <tgroup cols="2"><tbody><row>
         <entry><b>ID3 2.0 标签</b></entry>
	    <entry><b>相应的 Sound 类属性</b></entry>
      </row><row>
        <entry>COMM</entry>
        <entry>Sound.id3.comment</entry>
      </row><row>
        <entry>TALB</entry>
        <entry>Sound.id3.album </entry>
      </row><row>
     
       <entry>TCON</entry>
       <entry>Sound.id3.genre</entry>
      </row><row>
       <entry>TIT2</entry>
       <entry>Sound.id3.songName </entry>
     </row><row>
       <entry>TPE1</entry>
       <entry>Sound.id3.artist</entry>
     </row><row>
       <entry>TRCK</entry>
       <entry>Sound.id3.track </entry>
     </row><row>
       <entry>TYER</entry>
       <entry>Sound.id3.year </entry>
     </row></tbody></tgroup></adobetable>
     
     <p>下表描述了在 Sound 类中受支持但不具有预定义属性的 ID3 标签。通过调用 <codeph>mySound.id3.TFLT</codeph> 和 <codeph>mySound.id3.TIME</codeph> 等来访问它们。</p>  
      <adobetable class="innertable">
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      <tgroup cols="2"><tbody><row>
          <entry><b>属性</b></entry>
          <entry><b>描述</b></entry>
        </row><row>
          <entry>TFLT</entry>
          <entry>文件类型</entry>
        </row><row>
          <entry>TIME</entry>
          <entry>时间</entry>
        </row><row>
          <entry>TIT1</entry>
          <entry>内容组说明</entry>
        </row><row>
          <entry>TIT2</entry>
          <entry>标题/歌曲名称/内容说明</entry>
        </row><row>
          <entry>TIT3</entry>
          <entry>副标题/说明精选</entry>
        </row><row>
          <entry>TKEY</entry>
          <entry>初始密钥</entry>
        </row><row>
          <entry>TLAN</entry>
          <entry>语言</entry>
        </row><row>
          <entry>TLEN</entry>
          <entry>长度</entry>
        </row><row>
          <entry>TMED</entry>
          <entry>媒体类型</entry>
        </row><row>
          <entry>TOAL</entry>
          <entry>原始唱片/影片/演出标题</entry>
        </row><row>
          <entry>TOFN</entry>
          <entry>原始文件名</entry>
        </row><row>
          <entry>TOLY</entry>
          <entry>原词作者/乐谱作者</entry>
        </row><row>
          <entry>TOPE</entry>
          <entry>原始艺术家/表演者</entry>
        </row><row>
          <entry>TORY</entry>
          <entry>原始发行年份</entry>
        </row><row>
          <entry>TOWN</entry>
          <entry>文件所有者/获得授权者</entry>
        </row><row>
          <entry>TPE1</entry>
          <entry>主要表演者/独奏（独唱）</entry>
        </row><row>
          <entry>TPE2</entry>
          <entry>乐队/管弦乐队/伴奏</entry>
        </row><row>
          <entry>TPE3</entry>
          <entry>指挥/主要演奏者</entry>
        </row><row>
          <entry>TPE4</entry>
          <entry>翻译、混录员或以其它方式进行修改的人员</entry>
        </row><row>
          <entry>TPOS</entry>
          <entry>歌曲集部分</entry>
        </row><row>
          <entry>TPUB</entry>
          <entry>发行者</entry>
        </row><row>
          <entry>TRCK</entry>
          <entry>歌曲集中的曲目编号/位置</entry>
        </row><row>
          <entry>TRDA</entry>
          <entry>录制日期</entry>
        </row><row>
          <entry>TRSN</entry>
          <entry>Internet 无线电台名称</entry>
        </row><row>
          <entry>TRSO</entry>
          <entry>Internet 无线电台所有者</entry>
        </row><row>
          <entry>TSIZ</entry>
          <entry>大小</entry>
        </row><row>
          <entry>TSRC</entry>
          <entry>ISRC（国际标准音像制品编码）</entry>
        </row><row>
          <entry>TSSE</entry>
          <entry>用于编码的软件/硬件和设置</entry>
        </row><row>
          <entry>TYER</entry>
          <entry>年份</entry>
        </row><row>
          <entry>WXXX</entry>
          <entry>URL 链接帧</entry>
        </row></tbody></tgroup></adobetable>
     
     
     <p>使用此属性时，请考虑 Flash Player 安全模型：</p>
     
     <ul>
     
     <li>对于与声音文件位于同一安全沙箱的 SWF 文件，始终允许 Sound 对象的 <codeph>id3</codeph> 属性。对于其它沙箱中的文件，则需经过安全检查。</li>
     
     <li>使用 Sound 类的 <codeph>load()</codeph> 方法加载声音时，可指定 <codeph>context</codeph> 参数，该参数为一个 SoundLoaderContext 对象。如果将 SoundLoaderContext 对象的 <codeph>checkPolicyFile</codeph> 属性设为 <codeph>true</codeph>，则 Flash Player 将在从其中加载声音的服务器上查找 URL 策略文件。如果存在一个策略文件并且允许从执行加载的 SWF 文件的域进行访问，则允许该文件访问 Sound 对象的 <codeph>id3</codeph> 属性；否则将不允许。</li>
     
     </ul>
     
     <p>但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
     
     <p>有关安全性的详细信息，请参阅以下部分：</p>
     
     <ul>
     
     <li product="flex">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
       <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
     
     </ul>
     
     

     
     </apiDesc><example conref="examples\Sound_id3Example.as"> 下面的示例从声音文件中读取 ID3 信息，并在文本字段中显示该信息。
 
 <p>在构造函数中，加载了声音文件，但没有将其设置为播放。此处，假定该文件位于 SWF 目录中。系统必须具有权限，才能读取加载的声音文件的 ID3 标签。如果该文件中包含 ID3 信息并允许程序读取该信息，将触发一个 <codeph>Event.ID3</codeph> 事件，并填充声音文件的 <codeph>id3</codeph> 属性。<codeph>id3</codeph> 属性包含一个 <codeph>ID3Info</codeph> 对象，其中包含所有 ID3 信息。</p>
 
 <p>在 <codeph>id3Handler()</codeph> 方法中，将该文件的 ID3 标签存储在 ID3Info 类对象 <codeph>id3</codeph> 中。将实例化一个文本字段以显示 ID3 标签列表。for 循环将循环访问所有 ID3 2.0 标签，并将名称和值附加到文本字段的内容中。通过使用 ID3 信息 (<codeph>ID3Info</codeph>) 属性，还可以附加歌手、歌曲名称和专辑。ActionScript 3.0 和 Flash Player 9 及更高版本支持 ID3 2.0 标签，特别是 2.3 和 2.4。如果循环访问属性（像在 for 循环中一样），则仅显示 ID3 2.0 标签。但是，来自早期版本的数据也会存储在歌曲的 <codeph>id3</codeph> 属性中，可通过使用 ID3 信息类属性对其进行访问。ID3 1.0 的标签位于文件结尾；而 ID3 2.0 标签位于文件开头。（有时，文件可能在相同位置包含早期版本和较新版本的标签。）如果编码的文件开头和结尾分别包含 1.0 版和 2.0 版标签，将调用两次 <codeph>id3Handler()</codeph> 方法。它先读取 2.0 版标签，然后再读取 1.0 版标签。如果只有 ID3 1.0 标签可用，可通过 ID3 信息属性访问该信息，如 <codeph>id3.songname</codeph>。对于 ID3 2.0，<codeph>id3.TITS</codeph> 属性将使用新标签 (TITS) 来检索歌曲名称。</p>
 
 <p>请注意，没有为本示例编写错误处理代码，如果 ID3 内容很长，结果可能会超出可查看区域。</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.net.URLRequest;
    import flash.media.ID3Info;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;

    public class Sound_id3Example extends Sprite {
        private var snd:Sound = new Sound();       
        private var myTextField:TextField = new TextField();

        public function Sound_id3Example() {
            snd.addEventListener(Event.ID3, id3Handler);
            snd.load(new URLRequest("mySound.mp3"));
        }
    
        private function id3Handler(event:Event):void {
            var id3:ID3Info = snd.id3;

            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.border = true;

            myTextField.appendText("Received ID3 Info: \n");
              
            for (var propName:String in id3) {
                myTextField.appendText(propName + " = " + id3[propName] + "\n");
            }
 
            myTextField.appendText("\n" + "Artist: " + id3.artist + "\n");
            myTextField.appendText("Song name: " + id3.songName + "\n");
            myTextField.appendText("Album: " + id3.album + "\n\n"); 
 
            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiValue><apiValue id="flash.media:Sound:isBuffering:get"><apiName>isBuffering</apiName><shortdesc>
     返回外部 MP3 文件的缓冲状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     返回外部 MP3 文件的缓冲状态。如果值为 <codeph>true</codeph>，则在对象等待获取更多数据时，当前将会暂停任何回放。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:length:get"><apiName>length</apiName><shortdesc>
     当前声音的长度（以毫秒为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     当前声音的长度（以毫秒为单位）。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:url:get"><apiName>url</apiName><shortdesc>
     从中加载此声音的 URL。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     从中加载此声音的 URL。此属性只适用于使用 <codeph>Sound.load()</codeph> 方法加载的 Sound 对象。对于与 SWF 文件库中的声音资源关联的 Sound 对象，<codeph>url</codeph> 属性的值为 <codeph>null</codeph>。
     
     <p>首次调用 <codeph>Sound.load()</codeph> 时，<codeph>url</codeph> 属性最初具有 <codeph>null</codeph> 值，因为最终 URL 未知。只要从 Sound 对象中分派了 <codeph>open</codeph> 事件，<codeph>url</codeph> 属性就会具有非空值。</p>
     
     <p><codeph>url</codeph> 属性包含已从其中加载了声音的最终、绝对 URL。<codeph>url</codeph> 的值通常与传递给 <codeph>Sound.load()</codeph> 的 <codeph>stream</codeph> 参数的值相同。但是，如果已将一个相对 URL 传递给 <codeph>Sound.load()</codeph>，则 <codeph>url</codeph> 属性的值将表示绝对 URL。此外，如果 HTTP 服务器重定向原始 URL 请求，<codeph>url</codeph> 属性的值将反映从其中实际下载声音文件的最终 URL。这种报告绝对、最终 URL 的行为与 <codeph>LoaderInfo.url</codeph> 的行为等效。</p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
 SoundLoaderContext 类为加载声音的 文件提供安全检查。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 SoundLoaderContext 类为加载声音的 文件提供安全检查。SoundLoaderContext 对象以参数的形式传递到构造函数和 Sound 类的 <codeph>load()</codeph> 方法。
 
 <p>在使用此类时，请考虑以下安全模型： </p>
 
 <ul>
 <li>如果执行调用的 文件在网络沙箱中，并且要加载的声音文件是本地文件，则不允许加载和播放声音。</li>
 
 	<li>默认情况下，若执行调用的 是本地的，并且试图加载和播放远程声音，则不允许加载和播放声音。用户必须授予明确许可以允许该操作。</li>
 
 	<li>某些处理声音的操作受到限制。除非您实现一个 URL 策略文件，否则位于其它域中的文件无法访问已加载声音中的数据。受此限制约束的、与声音相关的 API 为 <codeph>Sound.id3</codeph> 属性以及 <codeph>SoundMixer.computeSpectrum()</codeph>、<codeph>SoundMixer.bufferTime</codeph> 和 <codeph>SoundTransform()</codeph> 方法。</li>
 
 </ul>
 
 <p>但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
 
 <p>有关安全性的详细信息，请参阅以下部分：</p>
 
 <ul>
 
 <li class="flexonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 
 <li><i>Developing AIR Applications</i>（《开发 AIR 应用程序》）一书的“Getting started with Adobe AIR”（Adobe AIR 入门）一章中的“Understanding AIR Security”（了解 AIR 安全性）一节。</li>
 
   <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/devnet/flashplayer/security.html" scope="external">安全性</xref></li>
 
 </ul>
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.media:SoundLoaderContext:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
     创建新的声音加载器上下文对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bufferTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1000</apiData><apiDesc>在开始传输声音流之前，将其预加载到缓冲区中所用的秒数。
     
     </apiDesc></apiParam><apiParam><apiItemName>checkPolicyFile</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指定在加载对象时是否应检查 URL 策略文件是否存在，如果是，则为 (<codeph>true</codeph>)。
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建新的声音加载器上下文对象。  
     
     </apiDesc><example conref="examples\SoundLoaderContextExample.as"> 在下面的示例中，将要加载的声音的缓冲时间设置为 3 秒。
 
 <p>可以使用 SoundLoaderContext 对象的第一个参数 (<codeph>context</codeph>) 将默认缓冲时间值从 1 秒增加到 3 秒。（该值以毫秒为单位。）如果将 SoundLoaderContext 对象的第二个参数设置为 <codeph>true</codeph>，Flash Player 将在加载对象后检查跨域策略文件。这里将其设置为默认值 <codeph>false</codeph>，所以将不会检查策略文件。声音对象的 <codeph>load()</codeph> 方法将使用 context 设置，以确保在开始传输声音流之前，花 3 秒钟的时间将流声音预加载到缓冲区中。<codeph>URLRequest</codeph> 对象确定文件（来自 Adobe 的播客）的位置。如果在加载声音文件的过程中发生 <codeph>IOErrorEvent.IO_ERROR</codeph> 错误，则会调用 <codeph>errorHandler()</codeph> 方法。</p> 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.events.IOErrorEvent;
    
    public class SoundLoaderContextExample extends Sprite {

        public function SoundLoaderContextExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            var context:SoundLoaderContext = new SoundLoaderContext(3000, false);

            snd.load(req, context);
            snd.play();      
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }

    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundLoaderContext:bufferTime"><apiName>bufferTime</apiName><shortdesc>
	 在开始传输声音流之前将其预加载到缓冲区中所用的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1000</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 在开始传输声音流之前将其预加载到缓冲区中所用的毫秒数。
	 
	 <p>请注意，无法通过设置全局 <codeph>SoundMixer.bufferTime</codeph> 属性来覆盖 <codeph>SoundLoaderContext.bufferTime</codeph> 的值。<ph platform="actionscript"><codeph>SoundMixer.bufferTime</codeph> 属性影响 SWF 文件中嵌入声音流的缓冲时间，该属性与动态创建的 Sound 对象（即在 ActionScript 中创建的 Sound 对象）无关。</ph></p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundLoaderContext:checkPolicyFile"><apiName>checkPolicyFile</apiName><shortdesc>
	 指定应用程序是否应在开始加载声音之前尝试从所加载声音的服务器下载 URL 策略文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>: please review at same time: checkPolicyFile property in LoaderContext, NetStream
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>false</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 指定应用程序是否应在开始加载声音之前尝试从所加载声音的服务器下载 URL 策略文件。此属性应用于使用 <codeph>Sound.load()</codeph> 方法从执行调用的文件自己的域外加载的声音。
	 
	 <p platform="javascript">此属性仅适用于在 AIR 应用程序沙箱之外运行的 SWF 内容。 </p>
	 
	 <p platform="actionscript">如果从执行调用的文件自己的域外加载声音，并且执行调用的文件中的代码需要对声音数据进行低级访问，请将此属性设置为 <codeph>true</codeph>。对声音数据进行低级访问的示例包括引用 <codeph>Sound.id3</codeph> 属性以获取 ID3Info 对象，或调用 <codeph>SoundMixer.computeSpectrum()</codeph> 方法以便从加载的声音中获取声音样本。如果在加载时没有将 <codeph>checkPolicyFile</codeph> 属性设置为 <codeph>true</codeph> 的情况下尝试访问声音数据，则可能会出现 SecurityError 异常，因为尚未下载所需的策略文件。</p>
	 
	 <p platform="actionscript">如果不需要对正在加载的声音数据进行低级访问，请避免将 <codeph>checkPolicyFile</codeph> 设置为 <codeph>true</codeph>。检查策略文件会占用网络带宽并且可能会延迟下载的开始时间，因此只应在必要时才执行此操作。</p>
	 
	 <p platform="actionscript">如果在将 <codeph>SoundLoaderContext.checkPolicyFile</codeph> 设置为 <codeph>true</codeph> 的情况下调用 <codeph>Sound.load()</codeph>，则 Flash Player 或 AIR 必须在开始下载指定的声音之前成功下载相关的 URL 策略文件，或确定不存在这样的策略文件。<ph platform="actionscript">Flash Player 或 </ph>AIR 将按此顺序执行下列操作，以验证策略文件是否存在：</p>
	 
	 <ul platform="actionscript">
	 
	 <li>Flash Player 或 AIR 考虑已经下载的策略文件。</li>
	 
	 <li>Flash Player 或 AIR 尝试下载在 <codeph>Security.loadPolicyFile()</codeph> 调用中指定的任何未处理的策略文件。</li>
	 
	 <li>Flash Player 或 AIR 尝试从与声音的 URL 相对应的默认位置（与 <codeph>URLRequest.url</codeph> 所在的同一服务器上的 <codeph>/crossdomain.xml</codeph>）下载策略文件。（声音的 URL 在传递给 <codeph>Sound.load()</codeph> 或 Sound() 构造函数的 URLRequest 对象的 <codeph>url</codeph> 属性中指定。）</li>
	 </ul>
	 
	 <p platform="actionscript">无论哪种情况，Flash Player 或 AIR 都要求声音服务器上存在一个正确的策略文件，该文件可以提供对 <codeph>URLRequest.url</codeph> 上的声音文件的访问（根据该策略文件的位置），并允许执行调用的文件所在的域通过一个或多个 <codeph>&lt;allow-access-from></codeph> 标签来访问该声音。
	 </p>
	 
	 <p platform="actionscript">如果将 <codeph>checkPolicyFile</codeph> 设置为 <codeph>true</codeph>，则 Flash Player 或 AIR 会等到策略文件验证完成后再加载声音。应该等到从 Sound 对象分派了 <codeph>progress</codeph> 和 <codeph>complete</codeph> 事件后再对声音数据执行任何低级操作，如调用 <codeph>Sound.id3</codeph> 或 <codeph>SoundMixer.computeSpectrum()</codeph>。
	 </p>
	 
	 <p platform="actionscript">如果将 <codeph>checkPolicyFile</codeph> 设置为 <codeph>true</codeph>，但未找到适当的策略文件，则将直到执行需要策略文件的操作时才会收到错误，然后，Flash Player 或 AIR 会引发 <codeph>SecurityError</codeph> 异常。收到 <codeph>complete</codeph> 事件后，通过在 <codeph>try</codeph> 块内获取 <codeph>Sound.id3</codeph> 的值，并查看是否会引发 <codeph>SecurityError</codeph>，您可以测试是否已找到相关策略文件。</p>
	 
	 
	 <p platform="actionscript">如果正在从使用服务器端 HTTP 重定向的 URL 中下载声音，请谨慎使用 <codeph>checkPolicyFile</codeph>。Flash Player 或 AIR 尝试检索与传递到 <codeph>Sound.load()</codeph> 的 URLRequest 对象的 <codeph>url</codeph> 属性相对应的策略文件。如果最终声音文件由于 HTTP 重定向而来自不同的 URL，那么，最初下载的策略文件可能不适用于声音的最终 URL，此 URL 与安全决策相关。</p>
	 
	 <p platform="actionscript">如果发生此情况，这里有一个可能的解决方案。收到 <codeph>progress</codeph> 或 <codeph>complete</codeph> 事件后，可以检查包含声音的最终 URL 的 <codeph>Sound.url</codeph> 属性值。然后用根据声音的最终 URL 计算的策略文件 URL 调用 <codeph>Security.loadPolicyFile()</codeph> 方法。最后，轮询 <codeph>Sound.id3</codeph> 的值，直到没有引发异常为止。</p>
	 
	 <p platform="actionscript">这一点不适用于 AIR 应用程序沙箱中的内容。应用程序沙箱中的内容始终可以通过编程方式访问声音内容，无论这些内容的来源是什么。</p>
	 
	 <p platform="actionscript">有关策略文件的详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“Flash Player 安全性”一章。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>flash.media.Sound.load()</linktext></link><link href="flash.media.xml#Sound/id3"><linktext>flash.media.Sound.id3</linktext></link><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>flash.media.SoundMixer.computeSpectrum()</linktext></link><link href="flash.media.xml#Sound/url"><linktext>flash.media.Sound.url</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundChannel"><apiName>SoundChannel</apiName><shortdesc>
 SoundChannel 类控制应用程序中的声音。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 SoundChannel 类控制应用程序中的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。SoundChannel 类包含 <codeph>stop()</codeph> 方法、用于监控声道幅度（音量）的属性以及用于对声道指定 SoundTransform 对象的属性。
 
 </apiDesc><example conref="examples\SoundChannelExample.as"> 以下示例加载一个 MP3 文件，进行播放，并显示在加载和播放该 MP3 文件时所发生的声音事件的相关信息。Timer 对象每 50 毫秒提供一次有关播放头位置的更新信息。要运行此示例，请将一个名为 MySound.mp3 的文件放在 SWF 文件所在的同一目录中。

<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundChannelExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundChannelExample() {
            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);

            channel = soundFactory.play();
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);

            positionTimer = new Timer(50);
            positionTimer.addEventListener(TimerEvent.TIMER, positionTimerHandler);
            positionTimer.start();
        }
        

        private function positionTimerHandler(event:TimerEvent):void {
            trace("positionTimerHandler: " + channel.position.toFixed(2));
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
            positionTimer.stop();       
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }

        private function soundCompleteHandler(event:Event):void {
            trace("soundCompleteHandler: " + event);
            positionTimer.stop();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:SoundChannel_flash.events.Event.SOUND_COMPLETE_soundComplete"><apiName>soundComplete</apiName><shortdesc>
 在声音完成播放后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SOUND_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在声音完成播放后分派。 
 </apiDesc><example conref="examples\SoundChannel_event_soundCompleteExample.as"> 在下面的示例中，用户从播放列表中选择一些歌曲，然后单击“Play”（播放）以按选定的顺序播放歌曲。
 
 <p>在构造函数中，定义了一个用于保存歌曲列表的文本字段和一个用于选择播放的行。（通常，使用按钮来表示歌曲列表的播放和列表框。）定义了一个文本格式对象，以便在选择歌曲行后将其格式更改为斜体。当用户单击该文本字段时，将调用 <codeph>clickHandler()</codeph> 方法。</p> 
 
<p>在 <codeph>clickHandler()</codeph> 方法中，文本字段对象的 <codeph>getLineIndexAtPoint()</codeph> 方法返回用户所单击的行的索引。通过使用行索引，<codeph>getLineText()</codeph> 方法可获取文本的内容。if 语句检查用户是否已选择播放歌曲或将歌曲添加到播放列表中。如果用户已选择播放并选择了歌曲，则会删除鼠标单击的事件侦听器，然后调用 <codeph>playNext()</codeph> 方法以开始播放歌曲。如果用户已选择歌曲名称，则会将该行的内容添加到 <codeph>songList</codeph> 数组中，并将行的格式设置为斜体。</p>
 
 <p><codeph>playNext()</codeph> 方法循环访问数组列表以加载并播放每首歌曲。还会将歌曲分配给声道。添加了一个声道事件侦听器，以便在播放完歌曲时做出响应，然后分派 <codeph>Event.SOUND_COMPLETE</codeph> 事件。<codeph>soundCompleteHandler()</codeph> 方法随后调用 <codeph>playNext()</codeph> 方法以播放下一首歌曲。此过程继续进行，直至播放完数组中列出的所有歌曲。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;

    public class SoundChannel_event_soundCompleteExample extends Sprite {
        private var channel:SoundChannel = new SoundChannel();
        private var songList:Array = new Array();
        private var listTextField:TextField = new TextField();
        private var songFormat:TextFormat = new TextFormat();
        private var arrayIndex:int = 0;
        private var songSelected:Boolean = false;
        
        public function SoundChannel_event_soundCompleteExample() {
            
            listTextField.autoSize = TextFieldAutoSize.LEFT;
            listTextField.border = true
            listTextField.background = true;
            listTextField.text = "Song1.mp3\n" + "Song2.mp3\n" 
                                + "Song3.mp3\n" + "Song4.mp3\n" + "PLAY";
        
            songFormat.italic = true;
 
            listTextField.addEventListener(MouseEvent.CLICK, clickHandler);
                        
            addChild(listTextField);
        }
        
        private function clickHandler(e:MouseEvent):void {
            var index:int = listTextField.getLineIndexAtPoint(e.localX, e.localY);
            var line:String = listTextField.getLineText(index);
            var firstIndex:uint = listTextField.getLineOffset(index);
            var playLine:uint = listTextField.numLines - 1;

                if((index == playLine) &amp;&amp; (songSelected == true)) {
                    listTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
                    playNext();       

                } else if (index != playLine) {
                     songList.push(line.substr(0, (line.length - 1)));
                     listTextField.setTextFormat(songFormat, firstIndex, 
                                (firstIndex + listTextField.getLineLength(index)));     
                    songSelected = true;
                 }
        }

        private function playNext():void {
 
             if(arrayIndex &lt; songList.length) {
                var snd:Sound = new Sound();
                snd.load(new URLRequest(songList[arrayIndex]));
                channel = snd.play();
                
                channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                arrayIndex++;
 
            } else {
                songSelected = false;
                    
                while(arrayIndex > 0) {
                    songList.pop();
                    arrayIndex--;
                }
            }
        }    

        private function soundCompleteHandler(e:Event):void {
            playNext();
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:SoundChannel:stop"><apiName>stop</apiName><shortdesc> 
	 停止在该声道中播放声音。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
	 停止在该声道中播放声音。
	 
	 </apiDesc><example conref="examples\SoundChannel_stopExample.as"> 在下面的示例中，用户可以单击按钮来暂停并重放声音文件。
 
 <p>在构造函数中，加载了该声音文件。（本示例假定该文件位于与 SWF 文件相同的目录中。）将一个文本字段用作按钮，供用户播放或暂停声音时使用。当用户单击 <codeph>button</codeph> 文本字段时，将调用 <codeph>clickHandler()</codeph> 方法。</p>
 
 <p>在 <codeph>clickHandler()</codeph> 方法中，当用户第一次单击该文本字段时，会将声音设置为播放并将声音分配给声道。然后，当用户再次单击该文本字段时，则会将声音设置为暂停，声音将停止播放。声道的 <codeph>position</codeph> 属性记录声音停止时的位置。此属性用于在用户单击该文本字段以重新开始播放后从该位置开始恢复播放声音。每次调用 <codeph>Sound.play()</codeph> 方法时，将创建一个新的 SoundChannel 对象并将其分配给 <codeph>channel</codeph> 变量。要使用声道的 <codeph>stop()</codeph> 方法暂停声音，必须将 Sound 对象分配给 SoundChannel 对象。</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
            
    public class SoundChannel_stopExample extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var button:TextField = new TextField();

        public function SoundChannel_stopExample() {
            var req:URLRequest = new URLRequest("MySound.mp3");
            snd.load(req);
            
            button.x = 10;
            button.y = 10;
            button.text = "PLAY";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.CENTER;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {
            var pausePosition:int = channel.position;

            if(button.text == "PLAY") {
                channel = snd.play(pausePosition);
                button.text = "PAUSE";
            } 
            else {
                channel.stop();
                button.text = "PLAY";
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundChannel:leftPeak:get"><apiName>leftPeak</apiName><shortdesc> 
	 左声道的当前幅度（音量），范围从 0（静音）至 1（最大幅度）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 左声道的当前幅度（音量），范围从 0（静音）至 1（最大幅度）。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:position:get"><apiName>position</apiName><shortdesc>
	 当播放声音时，position 属性指示声音文件中当前播放的位置（以毫秒为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 当播放声音时，<codeph>position</codeph> 属性指示声音文件中当前播放的位置（以毫秒为单位）。当停止或暂停播放声音时，<codeph>position</codeph> 属性指示声音文件中上次播放的位置。
	 
	 <p>一种常见使用情形是，在停止播放声音时保存 <codeph>position</codeph> 属性的值。以后，您可以从保存的位置重新开始以恢复播放声音。
	 </p>
	 
	 <p>如果循环播放声音，则在每次循环开始时，将 <codeph>position</codeph> 重置为 0。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:rightPeak:get"><apiName>rightPeak</apiName><shortdesc> 
	 右声道的当前幅度（音量），范围从 0（静音）至 1（最大幅度）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 右声道的当前幅度（音量），范围从 0（静音）至 1（最大幅度）。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 分配给该声道的 SoundTransform 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 分配给该声道的 SoundTransform 对象。SoundTransform 对象包含用于设置音量、平移、左扬声器指定和右扬声器指定的属性。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:Video"><apiName>Video</apiName><shortdesc>
 
 Video 类在应用程序中显示实时视频或录制视频，而无需在 SWF 文件中嵌入视频。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Video 类在应用程序中显示实时视频或录制视频，而无需在 SWF 文件中嵌入视频。此类在用于播放以下视频类型的 Adobe Flash 或 Adobe Flex 界面中创建一个 Video 对象：存储在服务器或本地的 FLV 录制文件，或者从用户计算机中捕获的实时视频。Video 对象是应用程序的显示列表中的一个显示对象，它表示在用户界面中运行视频的可见空间。
 
 <p>
 将 Video 对象用于 Flash Media Server 时，可通过该对象将实时视频从用户计算机发送到服务器，然后从服务器向其他用户广播此视频。通过使用这些功能，您可以开发媒体应用程序，例如，简单的视频播放器、具有在服务器间进行多点发布功能的视频播放器或者用于用户社区的视频共享应用程序。
 </p>
 
 <p>
 Flash Player 9 支持发布和回放使用 Sorenson Spark 或 On2 VP6 编解码器编码的 FLV 文件，并且还支持 Alpha 通道。与以前的技术相比，On2 VP6 视频编解码器使用的带宽较少，并且提供了额外的马赛克消除滤镜和色度去环滤镜。有关视频回放的详细信息，请参阅 flash.net.NetStream 类。</p>
 
 
 <p>
 Flash Player 9.0.115.0 及更高版本支持 mipmap 以优化运行时呈现品质和性能。对于视频回放，如果将 Video 对象的 <codeph>smoothing</codeph> 属性设置为 <codeph>true</codeph>，则 Flash Player 使用 mipmap 优化。 
 </p> 
 
 <p>
 与显示列表中的其它显示对象一样，您可以控制 Video 对象的各种属性。例如，可以通过使用 Video 对象的 <codeph>x</codeph> 和 <codeph>y</codeph> 属性在舞台上移动该对象，以及通过使用其 <codeph>height</codeph> 和 <codeph>width</codeph> 属性更改其大小，等等。 
 </p>
 
 <p>
 要播放视频流，请使用 <codeph>attachCamera()</codeph> 或 <codeph>attachNetStream()</codeph> 将视频附加到 Video 对象。然后，使用 <codeph>addChild()</codeph> 将 Video 对象添加到显示列表中。
 </p>
 
 <p product="flash">
 如果使用 Flash 创作工具，则还可以将 Video 对象放在舞台上，而不是使用 <codeph>addChild()</codeph> 进行添加，如下所示：
 </p>
 
 <ol product="flash">
   <li>如果看不到“库”面板，请选择“窗口”>“库”，让该面板显示出来。</li>
   <li>单击“库”面板标题栏右侧的“选项”菜单，然后选择“新建视频”，在库中添加一个嵌入式 Video 对象。</li>
   <li>在“视频属性”对话框中，命名嵌入的 Video 对象以便在库中使用，然后单击“确定”。</li>
   <li>将该 Video 对象拖放到舞台上，然后使用属性检查器为其指定一个唯一的实例名称，如 <codeph>my_video</codeph>。（不要将其命名为“Video”。）</li>
 </ol>
 
 <p><b>注意：</b>Video 类不是 InteractiveObject 类的子类，因此它无法分派鼠标事件。但是，您可以对包含 Video 对象的显示对象容器调用 <codeph>addEventListener()</codeph> 方法。
 </p>
 
 </apiDesc><example conref="examples\VideoExample.as"> 以下示例将 Video 对象与 NetConnection 和 NetStream 类一同使用，以加载和播放 FLV 文件。为了运行此示例，需要一个名称和位置与传递给 <codeph>videoURL</codeph> 的变量相匹配的 FLV 文件，在本例中，使用 SWF 文件所在目录下的一个名为 Video.flv 的 FLV 文件。
 <p>在本例中，创建 Video 和 NetStream 对象并调用 <codeph>Video.attachNetStream()</codeph> 和 <codeph>NetStream.play()</codeph> 的代码放入处理函数。仅在试图连接 NetConnection 对象成功时调用处理函数，即，当 <codeph>netStatus</codeph> 事件返回一个 info 对象，该对象带有一个表示成功的 <codeph>code</codeph> 属性时，才调用该处理函数。建议先等待连接成功，然后再调用 <codeph>NetStream.play()</codeph>。 </p>
 <codeblock>

 package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;

    public class VideoExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function VideoExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }

        private function connectStream():void {
            stream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }
    }
 }
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>attachCamera()</linktext></link><link href="flash.media.xml#Video/attachNetStream()"><linktext>attachNetStream()</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>flash.media.Camera.getCamera()</linktext></link><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#Stage/addChild()"><linktext>flash.display.Stage.addChild()</linktext></link></related-links><apiConstructor id="flash.media:Video:Video"><apiName>Video</apiName><shortdesc>
     创建新的 Video 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
     </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>320</apiData><apiDesc>视频的宽度（以像素为单位）。
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>240</apiData><apiDesc>视频的高度，以像素为单位。
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建新的 Video 实例。如果没有提供 <codeph>width</codeph> 和 <codeph>height</codeph> 参数的值，将使用默认值。在初始构建后，也可以使用 <codeph>Video.width</codeph> 和 <codeph>Video.height</codeph> 设置 Video 对象的宽度和高度属性。在创建新的 Video 对象时，不允许宽度和高度的值为零；如果传递零，则将应用默认值。
     
     <p>创建 Video 后，请调用 <codeph>DisplayObjectContainer.addChild()</codeph> 或 <codeph>DisplayObjectContainer.addChildAt()</codeph> 方法以便将 Video 对象添加到父级 DisplayObjectContainer 对象。</p>
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Video:attachCamera"><apiName>attachCamera</apiName><shortdesc>
     指定要在应用程序中 Video 对象的边界内显示的来自摄像头的视频流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.attachCamera, attachCamera()
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>camera</apiItemName><apiOperationClassifier>flash.media:Camera</apiOperationClassifier><apiDesc>正在捕获视频数据的 Camera 对象。要切断与该 Video 对象的连接，请传递 <codeph>null</codeph>。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     指定要在应用程序中 Video 对象的边界内显示的来自摄像头的视频流。
     
     <p>
     可以使用此方法将实时视频从用户计算机附加到 Video 对象。您可以在捕获实时视频的同一台计算机上本地播放该视频，也可以将其发送到 Flash Media Server，然后使用该服务器将视频流式传输到其它用户。
     </p>
     
     </apiDesc><example>有关如何使用此方法的说明，请参阅 <xref href="Camera.html#getCamera()">Camera.getCamera()</xref> 方法示例。 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachNetStream()"><linktext>Video.attachNetStream()</linktext></link><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:attachNetStream"><apiName>attachNetStream</apiName><shortdesc>
     指定要在应用程序中 Video 对象的边界内显示的视频流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, video, Video.attachNetStream, attachNetStream()
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>netStream</apiItemName><apiOperationClassifier>flash.net:NetStream</apiOperationClassifier><apiDesc>一个 NetStream 对象。要切断与该 Video 对象的连接，请传递 <codeph>null</codeph>。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     指定要在应用程序中 Video 对象的边界内显示的视频流。视频流是使用 <codeph>NetStream.play()</codeph> 播放的 FLV 文件（即 Camera 对象）或 <codeph>null</codeph>。如果使用 FLV 文件，则可以将其存储在本地文件系统或 Flash Media Server 中。如果 <codeph>netStream</codeph> 参数的值为 <codeph>null</codeph>，则不会再在 Video 对象中播放视频。
     
     <p>
     如果 FLV 文件只包含音频，则无需使用此方法；当调用 <codeph>NetStream.play()</codeph> 时，将自动播放 FLV 文件的音频部分。要控制与 FLV 文件相关联的音频，请使用用于播放 FLV 文件的 NetStream 对象的 <codeph>soundTransform</codeph> 属性。
     </p>
     
     </apiDesc><example>有关如何使用此方法的说明，请参阅此类末尾的示例。 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>flash.net.NetStream.play()</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:clear"><apiName>clear</apiName><shortdesc>
     清除 Video 对象（而非视频流）中当前显示的图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.clear, clear
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     清除 Video 对象（而非视频流）中当前显示的图像。此方法对于处理当前图像非常有用。例如，您可以清除最后一幅图像或显示待机信息，而无需隐藏 Video 对象。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Video:deblocking:get"><apiName>deblocking</apiName><shortdesc>
     指示作为后处理的一部分应用于已解码视频的滤镜的类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.deblocking, deblocking
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     指示作为后处理的一部分应用于已解码视频的滤镜的类型。默认值为 0，指示允许视频压缩程序根据需要应用消除马赛克的滤镜。
     
     <p>压缩视频可能会导致产生不希望有的伪像。可以使用 <codeph>deblocking</codeph> 属性设置用于减少马赛克（而对于使用 On2 编解码器压缩的视频，则用于降低扭曲边缘）的过滤器。</p>
     
     <p><i>马赛克</i>是指组成每个视频帧的块的边界之间的可见瑕疵。<i>扭曲边缘</i>是指视频图像内元素周围的扭曲边缘。</p>
     
     <p>有两种消除马赛克的滤镜：分别在 Sorenson 编解码器和 On2 VP6 编解码器中。此外，如果使用 On2 VP6 编解码器，则可以使用色度去环滤镜。要设置滤镜，请使用下列值之一：</p>
     
     <ul>
       <li>0 － 允许视频压缩程序根据需要应用消除马赛克的滤镜。</li>
       <li>1 － 不使用消除马赛克的滤镜。</li>
       <li>2 － 使用 Sorenson 消除马赛克的滤镜。</li>
       <li>3 －（只限 On2 视频）使用 On2 消除马赛克的滤镜，但不使用色度去环滤镜。</li>
       <li>4 －（只限 On2 视频）使用 On2 消除马赛克的滤镜和色度去环滤镜。</li>
       <li>5 － （只限 On2 视频）使用 On2 消除马赛克的滤镜和性能更高的 On2 色度去环滤镜。</li>
     </ul>
     
     <p>如果在使用 Sorenson 编解码器时为视频选择了大于 2 的值，则 Sorenson 解码器默认为 2。</p>
     
     <p>使用消除马赛克的滤镜会影响整体回放性能，而且对于高带宽视频通常没有必要。如果用户系统的功能不够强大，则用户在启用消除马赛克的滤镜的情况下回放视频可能会有困难。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:smoothing:get"><apiName>smoothing</apiName><shortdesc>
     指定在缩放视频时是否应进行平滑处理（插补数据）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.smoothing, smoothing
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指定在缩放视频时是否应进行平滑处理（插补数据）。播放器必须处于高品质模式，平滑处理才起作用。默认值是 <codeph>false</codeph>（不进行平滑处理）。
     <p>对于使用 Flash Player 9.0.115.0 及更高版本进行的视频回放，请将此属性设置为 <codeph>true</codeph> 以利用 mipmap 图像优化。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:videoHeight:get"><apiName>videoHeight</apiName><shortdesc>
      一个整数，以像素为单位指定视频流的高度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.height, height
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      一个整数，以像素为单位指定视频流的高度。对于实时流，此值与正在捕获该视频流的 Camera 对象的 <codeph>Camera.height</codeph> 属性相同。对于 FLV 文件，此值是以 FLV 形式导出的文件的高度。
     <p>例如，您可能需要使用此属性来确保用户以捕获时的相同大小观看视频，而无论 Video 对象在舞台上的实际大小是什么。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/height"><linktext>flash.media.Camera.height</linktext></link></related-links></apiValue><apiValue id="flash.media:Video:videoWidth:get"><apiName>videoWidth</apiName><shortdesc>
      一个整数，以像素为单位指定视频流的宽度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.width, width
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      一个整数，以像素为单位指定视频流的宽度。对于实时流，此值与正在捕获该视频流的 Camera 对象的 <codeph>Camera.width</codeph> 属性相同。对于 FLV 文件，此值是以 FLV 文件形式导出的文件的宽度。
     <p>例如，您可能需要使用此属性来确保用户以捕获时的相同大小观看视频，而无论 Video 对象在舞台上的实际大小是什么。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>flash.media.Camera.width</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundMixer"><apiName>SoundMixer</apiName><shortdesc>
SoundMixer 类包含用于在应用程序中进行全局声音控制的静态属性和方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
SoundMixer 类包含用于在应用程序中进行全局声音控制的静态属性和方法。SoundMixer 类在应用程序中控制嵌入的声音流。它不控制动态创建的声音（即响应分派 <codeph>sampleData</codeph> 事件的 Sound 对象而生成的声音）。

</apiDesc></apiClassifierDetail><apiOperation id="flash.media:SoundMixer:areSoundsInaccessible"><apiName>areSoundsInaccessible</apiName><shortdesc> 
     确定是否因安全限制而无法访问任何声音。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>布尔值的字符串表示形式。
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc> 
     确定是否因安全限制而无法访问任何声音。例如，如果声音所在的服务器没有用于授予对所在域的访问权限的 URL 策略文件，则无法访问从调用此方法的内容所在域之外的其它域加载的声音。仍然可以加载和播放声音，但无法对不可访问的声音执行低级操作，如获取声音的 ID3 元数据。
     
     <p>对于应用程序安全沙箱中的 AIR 应用程序内容，调用此方法始终返回 <codeph>false</codeph>。应用程序安全沙箱中的内容可以访问所有声音（包括从其它域加载的声音）。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>computeSpectrum()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:computeSpectrum"><apiName>computeSpectrum</apiName><shortdesc>
     获取当前声音波形的快照，并将其放在指定的 ByteArray 对象中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should confirm if the floating point numbers are single- or double-precision.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>outputArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>用于保存与声音关联的值的 ByteArray 对象。如果由于安全性限制 (<codeph>areSoundsInaccessible == true</codeph>) 而导致任何声音不可用，则 <codeph>outputArray</codeph> 对象将保持不变。如果停止了所有声音，则用零填充 <codeph>outputArray</codeph> 对象。
     
     </apiDesc></apiParam><apiParam><apiItemName>FFTMode</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>一个用于指示是否首先对声音数据执行 Fourier 转换的布尔值。将此参数设置为 <codeph>true</codeph> 会导致方法返回的是频谱而不是原始声音波形。在频谱中，左侧表示的是低频，右侧表示的是高频。
     
     </apiDesc></apiParam><apiParam><apiItemName>stretchFactor</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>声音采样的分辨率。如果将 <codeph>stretchFactor</codeph> 值设置为 0，则会按 44.1 KHz 对数据进行采样；如果值为 1，则按 22.05 KHz 对数据进行采样；如果值为 2，则按 11.025 KHz 对数据进行采样；依此类推。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     获取当前声音波形的快照，并将其放在指定的 ByteArray 对象中。这些值已设置为标准浮点值（范围为 -1.0 到 1.0）格式。新值覆盖了传递到 <codeph>outputArray</codeph> 参数的 ByteArray 对象。创建的 ByteArray 对象的大小固定为 512 个浮点值，其中前 256 个值表示左声道，后 256 个值表示右声道。
     
     <p><b>注意：</b>此方法受本地文件安全性限制和跨域加载限制的约束。如果正在使用本地文件或从服务器（该服务器与执行调用的内容在不同的域中）中加载的声音，则可能需要通过跨域策略文件来解决沙箱限制问题。有关详细信息，请参阅 Sound 类说明。此外，此方法无法用于从 RTMP 流中提取数据，即使与 RTMP 服务器位于相同域中的内容调用此方法时也是如此。</p>
     
     
     <p>在 Flash Player 9.0.115.0 及更高版本和 Adobe AIR 中，通过 RTMP 支持此方法。在 Flash Media Server 上，可以在服务器端脚本中控制对流的访问。有关详细信息，请参阅 <xref href="http://www.adobe.com/go/documentation" scope="external"><i> Server-Side ActionScript Language Reference for Adobe Flash Media Server</i></xref>（《Adobe Flash Media Server 服务器端 ActionScript 语言参考》）中的 <codeph>Client.audioSampleAccess</codeph> 和 <codeph>Client.videoSampleAccess</codeph> 属性。</p>
     
     </apiDesc><example conref="examples\SoundMixer_computeSpectrumExample.as"> 在下面的示例中，使用 <codeph>computeSpectrum()</codeph> 方法生成声音波形数据的图形表示形式。 
 
 <p>在构造函数中，加载了一个声音文件，并将其设置为播放。（此示例中没有任何错误处理代码，并假定该声音文件位于与 SWF 文件相同的目录中。）该示例在播放声音时侦听 <codeph>Event.ENTER_FRAME</codeph> 事件，从而反复触发 <codeph>onEnterFrame()</codeph> 方法以绘制声音数据值的图表。在播放完声音后，<codeph>onPlaybackComplete()</codeph> 方法可通过删除 <codeph>Event.ENTER_FRAME</codeph> 事件的侦听器以停止绘制过程。</p>
 
 <p>在 <codeph>onEnterFrame()</codeph> 方法中，<codeph>computeSpectrum()</codeph> 方法在 <codeph>bytes</codeph> 字节数组对象中存储原始声音。数据是按 44.1 KHz 进行采样的。包含 512 字节数据的字节数组，每个数组包含一个介于 -1 和 1 之间的浮点值。第一组 256 字节值表示左声道，而第二组 256 字节值表示右声道。第一个 for 循环读取第一组 256 字节数据值（表示左立体声道），然后使用 <codeph>Graphics.lineTo()</codeph> 方法绘制一条从每个点到下一个点的直线。（声音波形的矢量图形显示内容直接写入到类的 Sprite 对象中。）声音字节是作为 32 位浮点数从字节流中读取的，并乘以绘制高度以使其位于图表垂直范围内。宽度被设置为声道长度的两倍。第二个 for 循环读取下一批 256 字节值（右立体声道），并按相反的顺序绘制直线。<codeph>g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);</codeph> 和 <codeph>g.lineTo(0, PLOT_HEIGHT);</codeph> 方法绘制波形的基线。生成的波形图会产生镜像效果。</p>  

<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.net.URLRequest;
    import flash.utils.ByteArray;
    import flash.text.TextField;

    public class SoundMixer_computeSpectrumExample extends Sprite {

        public function SoundMixer_computeSpectrumExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("Song1.mp3");
            snd.load(req);
            
            var channel:SoundChannel;
            channel = snd.play();
            addEventListener(Event.ENTER_FRAME, onEnterFrame);
            channel.addEventListener(Event.SOUND_COMPLETE, onPlaybackComplete);
        }

        private function onEnterFrame(event:Event):void {
            var bytes:ByteArray = new ByteArray();
            const PLOT_HEIGHT:int = 200;
            const CHANNEL_LENGTH:int = 256;

            SoundMixer.computeSpectrum(bytes, false, 0);
            
            var g:Graphics = this.graphics;
            
            g.clear();
       
            g.lineStyle(0, 0x6600CC);
            g.beginFill(0x6600CC);
            g.moveTo(0, PLOT_HEIGHT);
            
            var n:Number = 0;
            
            for (var i:int = 0; i &lt; CHANNEL_LENGTH; i++) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }

            g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            g.endFill();
 
            g.lineStyle(0, 0xCC0066);
            g.beginFill(0xCC0066, 0.5);
            g.moveTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            
            for (i = CHANNEL_LENGTH; i > 0; i--) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }
  
            g.lineTo(0, PLOT_HEIGHT);
            g.endFill();
        }
        
        private function onPlaybackComplete(event:Event):void {
            removeEventListener(Event.ENTER_FRAME, onEnterFrame);
        }
    }
}

</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/areSoundsInaccessible()"><linktext>areSoundsInaccessible()</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.media.xml#Sound"><linktext>flash.media.Sound</linktext></link><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>flash.media.SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:stopAll"><apiName>stopAll</apiName><shortdesc>
     停止当前正在播放的所有声音。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     停止当前正在播放的所有声音。 
     
     <p product="flash">此方法不停止播放头。设置到流的声音在播放头移过它们所在的帧时将恢复播放。</p>
     
     <p platform="actionscript">在使用此属性时，请考虑以下安全模型：</p>
     
     <ul platform="actionscript">
     
     <li> 默认情况下，调用 <codeph>SoundMixer.stopAll()</codeph> 方法只会停止与调用此方法的对象在相同安全沙箱中的声音。任何声音回放如果不是从与调用对象相同的沙箱中启动的，则不会停止这样的声音。</li>
     
     <li>使用 Sound 类的 <codeph>load()</codeph> 方法加载声音时，可指定 <codeph>context</codeph> 参数，该参数为一个 SoundLoaderContext 对象。如果将 SoundLoaderContext 对象的 <codeph>checkPolicyFile</codeph> 属性设为 <codeph>true</codeph>，则 <ph platform="actionscript">Flash Player 或 </ph>Adobe AIR 将在从其中加载该声音的服务器上检查跨域策略文件是否存在。如果该服务器具有跨域策略文件，且该文件允许访问执行调用的内容域，则该文件可使用 <codeph>SoundMixer.stopAll()</codeph> 方法停止加载的声音；否则就不可以。</li>
     
     </ul>
     
     <p platform="actionscript">但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
     
     <p platform="actionscript">有关详细信息，请参阅以下部分：</p>
     
     <ul platform="actionscript">
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
     </ul>
     
     </apiDesc><example conref="examples\SoundMixer_stopAllExample.as"> 在下面的示例中，使用 <codeph>stopAll()</codeph> 方法将同时播放的两种声音静音。 
 
 <p>在构造函数中，加载了两个不同的声音文件，并将其设置为播放。第一种声音是本地加载的，并将其分配给一个声道。（假定该文件位于与 SWF 文件相同的目录中。）第二个文件是从 Adobe 站点加载并流式传输的。要使用 <codeph>SoundMixer.stopAll()</codeph> 方法，必须能够访问所有声音。（可以使用 SoundLoaderContext 对象来检查跨域策略文件。）每种声音还包含一个事件侦听器，如果在加载声音文件时发生 IO 错误，则会调用该事件侦听器。还创建了一个 <codeph>muteButton</codeph> 文本字段。它侦听鼠标单击，这将调用 <codeph>muteButtonClickHandler()</codeph> 方法。</p>
 
 <p>在 <codeph>muteButtonClickHandler()</codeph> 方法中，如果文本字段的内容为“MUTE”，<codeph>areSoundsInaccessible()</codeph> 方法将检查混音器是否具有文件的访问权限。如果可以访问文件，<codeph>stopAll()</codeph> 方法将停止播放声音。通过再次单击文本字段，将开始播放第一种声音，并再次将文本字段的内容更改为“MUTE”。此时，<codeph>stopAll()</codeph> 方法将正在播放的那种声音静音。请注意，也可以使用声道的 <codeph>stop()</codeph> 方法停止播放为声道分配的特定声音。（为了使用声道功能，每次调用 <codeph>play()</codeph> 方法时，都需要为声道重新分配声音。）</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.events.IOErrorEvent;

    public class SoundMixer_stopAllExample extends Sprite  {
        private var firstSound:Sound = new Sound();
        private var secondSound:Sound = new Sound();
        private var muteButton:TextField = new TextField();
        private var channel1:SoundChannel = new SoundChannel();
        
        public function SoundMixer_stopAllExample() {
            firstSound.load(new URLRequest("mySound.mp3"));
            secondSound.load(new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3"));

            firstSound.addEventListener(IOErrorEvent.IO_ERROR, firstSoundErrorHandler);
            secondSound.addEventListener(IOErrorEvent.IO_ERROR, secondSoundErrorHandler);
            
            channel1 = firstSound.play();
            secondSound.play();
            
            muteButton.autoSize = TextFieldAutoSize.LEFT;
            muteButton.border = true;
            muteButton.background = true;
            muteButton.text = "MUTE";
        
            muteButton.addEventListener(MouseEvent.CLICK, muteButtonClickHandler);         
        
            this.addChild(muteButton);
        }

        private function muteButtonClickHandler(event:MouseEvent):void {

            if(muteButton.text == "MUTE") {        
  
                if(SoundMixer.areSoundsInaccessible() == false) {
                    SoundMixer.stopAll();
                    muteButton.text = "click to play only one of sound.";
                }
                else {
                    muteButton.text = "The sounds are not accessible.";
                }
            }
           else {
                firstSound.play();        
                muteButton.text = "MUTE";
           }
        } 

        private function firstSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }

        private function secondSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundMixer:bufferTime:get"><apiName>bufferTime</apiName><shortdesc>
     在开始传输嵌入的声音流之前，将其预加载到缓冲区中所用的秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     在开始传输嵌入的声音流之前，将其预加载到缓冲区中所用的秒数。除非实现了一个跨域策略文件，否则已加载声音中的数据（包括其缓冲时间）无法被位于其它域的 SWF 文件访问。有关安全性和声音的详细信息，请参阅 Sound 类说明。to stream. <ph platform="actionscript">除非实现了一个跨域策略文件，否则位于其它域的文件中的代码将无法访问已加载声音中的数据（包括其缓冲时间）。但是，在 AIR 应用程序中应用程序安全沙箱中，代码可以访问来自任何源的声音文件中的数据。有关安全性和声音的详细信息，请参阅 Sound 类说明。</ph> 
     
     <p><codeph>SoundMixer.bufferTime</codeph> 属性只会影响 SWF 中嵌入声音流的缓冲时间，该属性与动态创建的 Sound 对象（即在 ActionScript 中创建的 Sound 对象）无关。<codeph>SoundMixer.bufferTime</codeph> 的值无法覆盖或设置传递到 <codeph>Sound.load()</codeph> 方法的 SoundLoaderContext 对象中指定的缓冲时间默认值。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link></related-links></apiValue><apiValue id="flash.media:SoundMixer:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
     控制全局声音属性的 SoundTransform 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
     控制全局声音属性的 SoundTransform 对象。SoundTransform 对象包含用于设置音量、平移、左扬声器指定和右扬声器指定的属性。在此属性中使用的 SoundTransform 对象提供最终声音设置，这些设置将在应用了任何个别声音设置之后应用于所有声音。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier></apiPackage>