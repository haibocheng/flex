<?xml version="1.0"?>
<apiPackage id="flash.net"><apiName>flash.net</apiName><apiDetail/><apiClassifier id="flash.net:XMLSocket"><apiName>XMLSocket</apiName><shortdesc>
 
 XMLSocket 类可实现客户端套接字，从而使 Flash Player 或 AIR 应用程序可以与由 IP 地址或域名标识的服务器计算机进行通信。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLsocket, XMLsocket object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 XMLSocket 类可实现客户端套接字，从而使 <ph platform="actionscript">Flash Player 或</ph> AIR 应用程序可以与由 IP 地址或域名标识的服务器计算机进行通信。对于要求滞后时间较短的客户端/服务器应用程序，如实时聊天系统，XMLSocket 类非常有用。传统的基于 HTTP 的聊天解决方案频繁轮询服务器，并使用 HTTP 请求来下载新的消息。与此相对照，XMLSocket 聊天解决方案保持与服务器的开放连接，这一连接允许服务器即时发送传入的消息，而无需客户端发出请求。要使用 XMLSocket 类，服务器计算机必须运行可识别 XMLSocket 类使用的协议的守护程序。下面的列表说明了该协议： 
 <ul>
   <li>XML 消息通过全双工 TCP/IP 流套接字连接发送。</li>
   <li>每个 XML 消息都是一个完整的 XML 文档，以一个零 (0) 字节结束。</li>
   <li>通过 XMLSocket 连接发送和接收的 XML 消息的数量没有限制。</li>
 </ul>
 
 <p>将服务器设置为与 XMLSocket 对象进行通信可能会遇到一些困难。如果您的应用程序不需要进行实时交互，请使用 URLLoader 类，而不要使用 XMLSocket 类。 </p>
 
 <p>要使用 XMLSocket 类的方法，请先使用构造函数 <codeph>new XMLSocket</codeph> 创建一个 XMLSocket 对象。</p>
 
 <p>只能与本地文件系统内容交互的沙箱中的 SWF 文件无法使用套接字。</p>
      
  <p> 目标主机上的<i>套接字策略文件</i> 指定 SWF 文件可从中建立套接字连接的主机，并指定可以建立这些连接的端口。在新近发布的几个版本的 Flash Player 中，有关套接字策略文件的安全要求变得更加严格。对于所有版本的 Flash Player，Adobe 建议使用套接字策略文件；在某些情况下，必须使用套接字策略文件。因此，如果使用的是 XMLSocket 对象，必要时请确保目标主机提供了套接字策略文件。 </p>
 
  <p>以下列表汇总了各个版本的 Flash Player 中针对套接字策略文件的要求：</p>
 
  <ul>
  
   <li> 在 Flash Player 9.0.124.0 及更高版本中，套接字策略文件对于任何 XMLSocket 连接都是必需的。也就是说，无论连接到哪一个端口（即使连接到提供 SWF 文件的同一主机上的端口），目标主机上都需要套接字策略文件。 </li>
 
   <li> 在 Flash Player 9.0.115.0 版及更低版本中，如果要连接到小于 1024 的端口号或连接到除提供 SWF 文件的主机之外的主机，则目标主机上必须具有套接字策略文件。 </li>
 
  <li> 在 Flash Player 9.0.115.0 中，尽管套接字策略文件不是必需的，但如果目标主机未提供套接字策略文件，那么当使用 Flash Debug Player 时，也会显示警告。 </li>
 
  </ul>
 
 <p>但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
 
 <p>有关安全性的详细信息，请参阅以下部分：</p>
 
 <ul>
 
 <li class="flexonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 
 <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
 </ul>
 
 </apiDesc><example conref="examples\XMLSocketExample.as"> 下例使用 XMLSocketExample 类来通过 XMLSocket 发送数据并输出 XMLSocket 事件过程中的信息。这是使用以下步骤完成的：
 <ol>
  <li>XMLSocketExample 构造函数创建名为 <codeph>socket</codeph> 的 XMLSocket 实例，并将 <codeph>socket</codeph> 传递给 <codeph>ConfigureListeners()</codeph>（如下所述），然后调用 XMLSocket 的 <codeph>connect()</codeph> 方法，使用主机名“localhost”和端口号 <codeph>8080</codeph>。</li>
  <li>随后调用 <codeph>configureListeners()</codeph> 方法，该方法为每个受支持的 XMLSocket 事件添加侦听器：
  <ul>
      <li><codeph>closeHandler()</codeph>：侦听 <codeph>close</codeph> 事件，在网络连接关闭后分派该事件。</li>
      <li><codeph>connectHandler()</codeph>：侦听 <codeph>connect</codeph> 事件，在建立网络连接后分派该事件。</li>
      <li><codeph>dataHandler()</codeph>：侦听 <codeph>data</codeph> 事件，在 XMLSocket 每次接收新数据时分派该事件。</li>
      <li><codeph>progressHandler()</codeph>：侦听 <codeph>progress</codeph> 事件，已调用 <codeph>send()</codeph> 并且发送正在进行时分派该事件。</li>
      <li><codeph>securityErrorHandler()</codeph>：侦听 <codeph>securityError</codeph> 事件，如果试图使用错误的本地回放安全性设置或端口号低于 1024 的端口访问 XMLSocket，则分派该事件。</li>  
      <li><codeph>ioErrorHandler()</codeph>：侦听 <codeph>ioError</codeph> 事件，仅当发送或接收数据的操作失败时，才会发生该事件。</li>  
  </ul></li>
 </ol>
 <p><b>注意：</b>
 <ul>
  <li>您需要编译 SWF 文件并将“本地回放安全性”设置为“只访问网络”。</li>
  <li>为了让本示例正常工作，需要一个在域上运行并使用 8080 端口的服务器。</li>
  <li>如果运行的是 Flash Player 9.0.124.0 或更高版本，则需要在服务器上放置一个套接字策略文件，以允许建立从域到端口 8080 的套接字连接。有关提供套接字策略文件的信息，请参阅 Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html" scope="external">设置套接字策略文件服务器</xref>。</li>
  </ul>
 </p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.XMLSocket;

    public class XMLSocketExample extends Sprite {
        private var hostName:String = "localhost";
        private var port:uint = 8080;
        private var socket:XMLSocket;

        public function XMLSocketExample() {
            socket = new XMLSocket();
            configureListeners(socket);
            if (hostName &amp;&amp; port) {
                socket.connect(hostName, port);
            }
        }

        public function send(data:Object):void {
            socket.send(data);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CLOSE, closeHandler);
            dispatcher.addEventListener(Event.CONNECT, connectHandler);
            dispatcher.addEventListener(DataEvent.DATA, dataHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        }

        private function closeHandler(event:Event):void {
            trace("closeHandler: " + event);
        }

        private function connectHandler(event:Event):void {
            trace("connectHandler: " + event);
        }

        private function dataHandler(event:DataEvent):void {
            trace("dataHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>flash.net.URLLoader.load()</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><adobeApiEvent id="flash.net:XMLSocket_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 若对 XMLSocket.connect() 方法的调用尝试连接到调用方安全沙箱外部的服务器或低于 1024 的端口，则进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 若对 <codeph>XMLSocket.connect()</codeph> 方法的调用尝试连接到调用方安全沙箱外部的服务器或低于 1024 的端口，则进行分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>XMLSocket.connect()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 在出现输入/输出错误并导致发送或接收操作失败时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在出现输入/输出错误并导致发送或接收操作失败时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.DataEvent.DATA_data"><apiName>data</apiName><shortdesc>
 在发送或接收原始数据后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DataEvent.DATA</apiEventType><adobeApiEventClassifier>flash.events.DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在发送或接收原始数据后分派。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.Event.CONNECT_connect"><apiName>connect</apiName><shortdesc>
 在成功调用 XMLSocket.connect() 方法后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CONNECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在成功调用 <codeph>XMLSocket.connect()</codeph> 方法后分派。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 在服务器关闭套接字连接时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在服务器关闭套接字连接时分派。仅在服务器关闭连接时分派 <codeph>close</codeph> 事件；在调用 <codeph>XMLSocket.close()</codeph> 方法时不分派该事件。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:XMLSocket:XMLSocket"><apiName>XMLSocket</apiName><shortdesc>
    创建一个新的 XMLSocket 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>一个完全限定的 DNS 域名，或 <i>.222.333.444</i> 形式的 IP 地址。在 Flash Player 9.0.115.0 以及 AIR 1.0 和更高版本中，可以指定 IPv6 地址，如 rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]。也可指定 <codeph>null</codeph> 以连接到 SWF 文件所在的主机服务器。如果发出此调用的 SWF 文件正在 Web 浏览器中运行，则 <codeph>host</codeph> 必须与 SWF 文件位于同一个域中。
    
    </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>用于建立连接的目标主机上的 TCP 端口号。在 Flash Player 9.0.124.0 及更高版本中，目标主机必须提供套接字策略文件，以指定允许建立从提供 SWF 文件的主机到指定端口的套接字连接。在早期版本的 Flash Player 中，仅在要连接到小于 1024 的端口号或连接到除提供 SWF 文件的主机之外的主机时，才需要使用套接字策略文件。
    
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    创建一个新的 XMLSocket 对象。若未指定参数，将创建一个最初处于断开状态的套接字。若指定了参数，则尝试连接到指定的主机和端口。
    
    <p><b>注意：</b>强烈建议使用<b>不带参数</b>的构造函数形式，并添加任意事件侦听器，然后使用 <codeph>host</codeph> 和 <codeph>port</codeph> 参数调用 <codeph>connect</codeph> 方法。此序列将确保所有事件侦听器工作正常。</p>
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:XMLSocket:close"><apiName>close</apiName><shortdesc>
     关闭由 XMLSocket 对象指定的连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.close, close
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     关闭由 XMLSocket 对象指定的连接。仅在服务器关闭连接时分派 <codeph>close</codeph> 事件；在调用 <codeph>close()</codeph> 方法时不分派该事件。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:XMLSocket:connect"><apiName>connect</apiName><shortdesc>
     使用指定的 TCP 端口建立到指定 Internet 主机的连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.connect, connect
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>本地不受信任的 文件可能无法与 Internet 进行通信。可以通过将此文件重新分类为只能与远程内容交互的文件或受信任的文件来突破此限制。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>您不能指定高于 65535 的套接字端口。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>一个完全限定的 DNS 域名，或 <i>111.222.333.444</i> 形式的 IP 地址。也可指定 <codeph>null</codeph> 以连接到 SWF 文件所在的主机服务器。如果进行调用的文件是正在 Web 浏览器中运行的 SWF 文件，则 <codeph>host</codeph> 必须与该文件位于同一个域中。
     
     </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>用于建立连接的目标主机上的 TCP 端口号。在 Flash Player 9.0.124.0 及更高版本中，目标主机必须提供套接字策略文件，以指定允许建立从提供 SWF 文件的主机到指定端口的套接字连接。在早期版本的 Flash Player 中，仅在要连接到小于 1024 的端口号或连接到除提供 SWF 文件的主机之外的主机时，才需要使用套接字策略文件。
     
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     使用指定的 TCP 端口建立到指定 Internet 主机的连接。
     
     <p>如果指定 <codeph>null</codeph> 为 <codeph>host</codeph> 参数，则与调用 <codeph>XMLSocket.connect()</codeph> 的文件所在的主机连接。例如，如果进行调用的文件是从 www.adobe.com 下载的，则将 host 参数指定为 <codeph>null</codeph> 表示您将连接到 www.adobe.com。</p>
     
     
     <p platform="actionscript">可以在包含 内容的 HTML 页中设置<codeph>allowNetworking</codeph>参数，针对 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签，防止 SWF 文件使用此方法。</p>
     
     <p>有关详细信息，请参阅以下部分：</p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/CONNECT"><linktext>flash.events.Event.CONNECT</linktext></link></related-links><adobeApiEvent id="flash.net:XMLSocket:connect_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>连接操作试图连接到调用方的安全沙箱外部的主机，或试图连接到需要套接字策略文件的端口。可以通过在目标主机上使用套接字策略文件来解决上述任何一个问题。
     </apiDesc></adobeApiEventDetail><shortdesc>连接操作试图连接到调用方的安全沙箱外部的主机，或试图连接到需要套接字策略文件的端口。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket:connect_data"><apiName>data</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在收到原始数据时分派。
     </apiDesc></adobeApiEventDetail><shortdesc>在收到原始数据时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket:connect_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在建立网络连接后分派。 
     </apiDesc></adobeApiEventDetail><shortdesc>在建立网络连接后分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:XMLSocket:send"><apiName>send</apiName><shortdesc>
     将 object 参数中指定的 XML 对象或数据转换成字符串，并将其传输到服务器，后面跟有一个零 (0) 字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.send, send
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>XMLSocket 对象未与服务器连接。
     
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>一个要传输到服务器的 XML 对象或其它数据。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将 <codeph>object</codeph> 参数中指定的 XML 对象或数据转换成字符串，并将其传输到服务器，后面跟有一个零 (0) 字节。如果 <codeph>object</codeph> 是一个 XML 对象，则该字符串是此 XML 对象的 XML 文本表示形式。发送操作是异步的；它将立即返回，但数据可能会以后传输。<codeph>XMLSocket.send()</codeph> 方法不返回指示数据是否成功传输的值。
     
     <p>如果不是使用 <codeph>XMLSocket.connect()</codeph> 将 XMLSocket 对象连接到服务器，则 <codeph>XMLSocket.send()</codeph> 操作失败。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiOperation><apiValue id="flash.net:XMLSocket:connected:get"><apiName>connected</apiName><shortdesc>
     指示此 XMLSocket 对象目前是否已连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指示此 XMLSocket 对象目前是否已连接。还可以通过为 <codeph>connect</codeph> 事件和 <codeph>ioError</codeph> 事件注册来检查连接是否成功。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#XMLSocket/event:connect"><linktext>connect</linktext></link><link href="flash.net.xml#XMLSocket/event:ioError"><linktext>ioError</linktext></link></related-links></apiValue><apiValue id="flash.net:XMLSocket:timeout:set"><apiName>timeout</apiName><shortdesc>
     指示建立连接时需等待的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     指示建立连接时需等待的毫秒数。
     
     <p>如果在指定时间内未成功建立连接，则连接失败。默认值是 20,000（20 秒）。</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:ObjectEncoding"><apiName>ObjectEncoding</apiName><shortdesc>
 ObjectEncoding 类用于在对对象进行序列化的类（例如，FileStream、NetStream、NetConnection、SharedObject 和 ByteArray）中定义序列化设置，以便与 ActionScript 的以前版本一起使用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>ObjectEncoding, ObjectEncoding object, built-in class, AMF, Action Message Format
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 ObjectEncoding 类用于在对对象进行序列化的类（例如，FileStream、NetStream、NetConnection、SharedObject 和 ByteArray）中定义序列化设置，以便与 ActionScript 的以前版本一起使用。 
 
 <p>对象编码用于控制如何以 Action Message Format (AMF) 表示对象。Flash Player 使用 AMF 来启用应用程序和远程服务器之间的高效通信。AMF 将远程过程调用编码为一种紧凑的二进制表示形式，这种表示形式可以通过 HTTP/HTTPS 协议或 Flash Media Server 使用的 RTMP/RTMPS 协议进行传输。对象和数据值将被序列化为这种二进制格式，这种格式通常比其它表示形式（例如 XML）紧凑。</p>
 
 <p>Adobe AIR 和 Flash Player 9 提供两种不同的序列化格式：AMF3 和 AMF0。AMF3 是为 ActionScript 3.0 开发的默认序列化格式，与用于 ActionScript 1.0 和 2.0 的 AMF0 相比，AMF3 具有多种优点。AMF3 通过网络发送数据比 AMF0 更高效。<ph platform="actionscript">AMF3 支持将 <codeph>int</codeph> 和 <codeph>uint</codeph> 对象作为整型发送出去，并支持只可在 ActionScript 3.0 中使用的数据类型，例如 ByteArray、XML 和 IExternalizable。AMF3 只能在 ActionScript 3.0 和使用 AMF3 编码的服务器（例如 Flex 2）中使用。</ph></p>
 
 <p>ByteArray、FileStream、NetConnection、NetStream、<ph platform="actionscript">SharedObject、</ph>Socket 和 URLStream 类均包含一个 <codeph>objectEncoding</codeph> 属性，为该属性分配的常量来自 ObjectEncoding 类。<codeph>objectEncoding</codeph> 属性的行为因对象而异；每个类的 <codeph>objectEncoding</codeph> 属性描述更加全面地说明了其行为。</p>
 
 
 </apiDesc></apiClassifierDetail><apiValue id="flash.net:ObjectEncoding:AMF0"><apiName>AMF0</apiName><shortdesc>
	 指定使用 ActionScript 1.0 和 2.0 的 Action Message Format 来序列化对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 指定使用 ActionScript 1.0 和 2.0 的 Action Message Format 来序列化对象。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:AMF3"><apiName>AMF3</apiName><shortdesc>
	 指定使用 ActionScript 3.0 的 Action Message Format 来序列化对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 指定使用 ActionScript 3.0 的 Action Message Format 来序列化对象。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 指定当前运行时的默认（最新）格式（Flash&amp;#xAE; Player 或 Adobe&amp;#xAE; AIR&amp;#xAE;）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 为当前运行时（Flash<sup>®</sup> Player 或 Adobe<sup>®</sup> AIR<sup>®</sup>）指定默认格式（最新格式）。由于对象编码控件仅在 Flash Player 9 和更高版本以及 Adobe AIR 中提供，因而使用的最早格式是用于 ActionScript 3.0 的 Action Message Format。
	 
	 <p>例如，如果某个对象的 <codeph>objectEncoding</codeph> 属性设置为 <codeph>ObjectEncoding.DEFAULT</codeph>，则将使用 AMF3 编码。以后，如果更高版本的 Flash Player 或 Adobe AIR 引入了新版 AMF，并且您重新发布了内容，则应用程序将使用此新版 AMF。仅当您毫不担心新版与旧版之间的互操作性时才能使用此常数。</p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:dynamicPropertyWriter:get"><apiName>dynamicPropertyWriter</apiName><shortdesc>
	 允许对动态对象的动态属性的序列化进行更大程度的控制。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.net:IDynamicPropertyWriter</apiValueClassifier></apiValueDef><apiDesc>
	 允许对动态对象的动态属性的序列化进行更大程度的控制。当将此属性设为默认值 <codeph>null</codeph> 时，将使用本机代码序列化动态属性，这将写入除值为函数以外的所有动态属性。
     <p>仅对动态对象（在动态类中声明的对象）或使用 <codeph>new</codeph> 运算符声明的对象的属性调用该值。</p>
	 
	 <p platform="actionscript">可以使用此属性将动态对象的属性排除在序列化之外，将值写入动态对象的属性中或为动态对象创建新属性。为此，请将此属性设置为实现 IDynamicPropertyWriter 接口的对象。有关详细信息，请参阅 IDynamicPropertyWriter 接口。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:Socket"><apiName>Socket</apiName><shortdesc>
 Socket 类使 代码可以建立套接字连接并读取和写入原始二进制数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Socket 类使 代码可以建立套接字连接并读取和写入原始二进制数据。它与 XMLSocket 类似，但没有指定接收或传输的数据格式。
 
 <p>Socket 类与使用二进制协议的服务器一起使用时非常有用。</p>
 
 <p>要使用 Socket 类的方法，请先使用构造函数 <codeph>new Socket</codeph> 创建一个 Socket 对象。</p>
 
 <p>只能与本地文件系统内容交互的沙箱中的 SWF 文件无法使用套接字。</p>
      
  <p> 目标主机上的<i>套接字策略文件</i> 指定 SWF 文件可从中建立套接字连接的主机，并指定可以建立这些连接的端口。在新近发布的几个版本的 Flash Player 中，有关套接字策略文件的安全要求变得更加严格。对于所有版本的 Flash Player，Adobe 建议使用套接字策略文件；在某些情况下，必须使用套接字策略文件。因此，如果使用的是 XMLSocket 对象，必要时请确保目标主机提供了套接字策略文件。 </p>
 
  <p>以下列表汇总了各个版本的 Flash Player 中针对套接字策略文件的要求：</p>
 
  <ul>
  
   <li> 在 Flash Player 9.0.124.0 及更高版本中，套接字策略文件对于任何 Socket 连接都是必需的。也就是说，无论连接到哪一个端口（即使连接到提供 SWF 文件的同一主机上的端口），目标主机上都需要套接字策略文件。 </li>
 
   <li> 在 Flash Player 9.0.115.0 版及更低版本中，如果要连接到小于 1024 的端口号或连接到除提供 SWF 文件的主机之外的主机，则目标主机上必须具有套接字策略文件。 </li>
 
  <li> 在 Flash Player 9.0.115.0 中，尽管套接字策略文件不是必需的，但如果目标主机未提供套接字策略文件，那么当使用 Flash Debug Player 时，也会显示警告。 </li>
 
  </ul>
 
 <p>但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
  
 <p>有关安全性的详细信息，请参阅以下部分：</p>
 
 <ul>
 
 <li class="flexonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 
 <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
 </ul>
 
 </apiDesc><example conref="examples\SocketExample.as"> 下例对套接字执行读写操作，并输出在套接字事件期间传输的信息。该示例的要点遵循：
 <ol>
    <li>该构造函数创建 <codeph>CustomSocket</codeph> 实例，名为 <codeph>socket</codeph>，并将主机名 <codeph>localhost</codeph> 和端口 80 作为参数传递。由于 <codeph>CustomSocket</codeph> 扩展了 Socket，因此在调用 <codeph>super()</codeph> 时将调用 Socket 的构造函数。</li>
    <li>然后，该示例调用了 <codeph>configureListeners()</codeph> 方法，该方法可为 Socket 事件添加侦听器。</li>
      <li>最后，调用套接字 <codeph>connect()</codeph> 方法，其中使用 <codeph>localhost</codeph> 作为主机名并使用 80 作为端口号。</li>
 </ol>
 
 <p> <b>注意：</b>为了运行该示例，您需要一台与 SWF 位于同一个域（在本例中为 <codeph>localhost</codeph>）服务器并侦听端口 80。</p>
<codeblock>

package {
    import flash.display.Sprite;

    public class SocketExample extends Sprite {

        public function SocketExample() {
            var socket:CustomSocket = new CustomSocket("localhost", 80);
        }
    }
}

import flash.errors.*;
import flash.events.*;
import flash.net.Socket;

class CustomSocket extends Socket {
    private var response:String;

    public function CustomSocket(host:String = null, port:uint = 0) {
        super();
        configureListeners();
        if (host &amp;&amp; port)  {
            super.connect(host, port);
        }
    }

    private function configureListeners():void {
        addEventListener(Event.CLOSE, closeHandler);
        addEventListener(Event.CONNECT, connectHandler);
        addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        addEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler);
    }

    private function writeln(str:String):void {
        str += "\n";
        try {
            writeUTFBytes(str);
        }
        catch(e:IOError) {
            trace(e);
        }
    }

    private function sendRequest():void {
        trace("sendRequest");
        response = "";
        writeln("GET /");
        flush();
    }

    private function readResponse():void {
        var str:String = readUTFBytes(bytesAvailable);
        response += str;
    }

    private function closeHandler(event:Event):void {
        trace("closeHandler: " + event);
        trace(response.toString());
    }

    private function connectHandler(event:Event):void {
        trace("connectHandler: " + event);
        sendRequest();
    }

    private function ioErrorHandler(event:IOErrorEvent):void {
        trace("ioErrorHandler: " + event);
    }

    private function securityErrorHandler(event:SecurityErrorEvent):void {
        trace("securityErrorHandler: " + event);
    }

    private function socketDataHandler(event:ProgressEvent):void {
        trace("socketDataHandler: " + event);
        readResponse();
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.net:Socket_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 若对 Socket.connect() 的调用尝试连接到调用方安全沙箱外部的服务器或端口号低于 1024 的端口，则进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS check this info
 </internal></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 若对 <codeph>Socket.connect()</codeph> 的调用尝试连接到调用方安全沙箱外部的服务器或端口号低于 1024 端口，则进行分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#Socket/connect()"><linktext>Socket.connect()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.ProgressEvent.SOCKET_DATA_socketData"><apiName>socketData</apiName><shortdesc>
 在套接字接收到数据后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.SOCKET_DATA</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在套接字接收到数据后分派。<codeph>socketData</codeph> 类型的事件不使用 <codeph>ProgressEvent.bytesTotal</codeph> 属性。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 在出现输入/输出错误并导致发送或加载操作失败时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在出现输入/输出错误并导致发送或加载操作失败时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.Event.CONNECT_connect"><apiName>connect</apiName><shortdesc>
 在建立网络连接后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CONNECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在建立网络连接后分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 在服务器关闭套接字连接时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在服务器关闭套接字连接时分派。仅在服务器关闭连接时分派 <codeph>close</codeph> 事件；在调用 <codeph>Socket.close()</codeph> 方法时不分派该事件。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:Socket:Socket"><apiName>Socket</apiName><shortdesc>
    创建新的 Socket 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS determine if all above events are accurate, and which ones also apply
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>此错误出现在 SWF 内容中<ph platform="javascript">。</ph> <ph platform="actionscript">原因如下：</ph>
	 
     <ul platform="actionscript">
       <li>与本地文件系统内容交互的文件无法与 Internet 进行通信。您可以通过将此 SWF 文件重新分类为只能与远程内容交互或受信任来解决此问题。此限制不是为应用程序安全沙箱中的 AIR 应用程序内容设置的。</li>
	 
      <li>您不能指定高于 65535 的套接字端口。</li>
    </ul>
	 
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>一个完全限定的 DNS 域名，或 <i>111.222.333.444</i> 形式的 IP 地址。在 Flash Player 9.0.115.0 以及 AIR 1.0 和更高版本中，可以指定 IPv6 地址，如 rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]。也可指定 <codeph>null</codeph> 以连接到 SWF 文件所在的主机服务器。如果发出此调用的 SWF 文件正在 Web 浏览器中运行，则 <codeph>host</codeph> 必须与 SWF 文件位于同一个域中。
    
    </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>用于建立连接的目标主机上的 TCP 端口号。在 Flash Player 9.0.124.0 及更高版本中，目标主机必须提供套接字策略文件，以指定允许建立从提供 SWF 文件的主机到指定端口的套接字连接。在早期版本的 Flash Player 中，仅在要连接到小于 1024 的端口号或连接到除提供 SWF 文件的主机之外的主机时，才需要使用套接字策略文件。
    
    
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
    创建新的 Socket 对象。若未指定参数，将创建一个最初处于断开状态的套接字。若指定了参数，则尝试连接到指定的主机和端口。
    
    <p><b>注意：</b>强烈建议使用<b>不带参数</b>的构造函数形式，并添加任意事件侦听器，然后使用 <codeph>host</codeph> 和 <codeph>port</codeph> 参数调用 <codeph>connect</codeph> 方法。此序列将确保所有事件侦听器工作正常。</p>
    
    </apiDesc></apiConstructorDetail><adobeApiEvent id="flash.net:Socket:Socket_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在建立网络连接后分派。
    </apiDesc></adobeApiEventDetail><shortdesc>在建立网络连接后分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:Socket_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在出现输入/输出错误并由此导致连接失败时分派。
	 </apiDesc></adobeApiEventDetail><shortdesc>在出现输入/输出错误并由此导致连接失败时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:Socket_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc><ph platform="javascript">此错误出现在 SWF 内容中。</ph><ph platform="actionscript">如果对 <codeph>Socket.connect()</codeph> 的调用试图与未提供套接字策略文件的服务器进行连接，或者试图与其策略文件未授予执行调用的主机对指定端口的访问权的服务器进行连接，则分派此事件。有关套接字策略文件的详细信息，请参阅《ActionScript 3.0 编程》中的“Flash Player 安全性”一章。<i/></ph>
	 
    </apiDesc></adobeApiEventDetail><shortdesc>此错误出现在 SWF 内容中。如果对 Socket.connect() 的调用试图与未提供套接字策略文件的服务器进行连接，或者试图与其策略文件未授予执行调用的主机对指定端口的访问权的服务器进行连接，则分派此事件。</shortdesc></adobeApiEvent></apiConstructor><apiOperation id="flash.net:Socket:close"><apiName>close</apiName><shortdesc>
     关闭套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>无法关闭套接字，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     关闭套接字。在调用 <codeph>close()</codeph> 方法之后，将无法读取或写入任何数据。
     
     <p>仅在服务器关闭连接时分派 <codeph>close</codeph> 事件；在调用 <codeph>close()</codeph> 方法时不分派该事件。</p>
     
     <p>可通过再次对 Socket 对象调用 <codeph>connect()</codeph> 方法来重复使用该对象。</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:connect"><apiName>connect</apiName><shortdesc>
     将套接字连接到指定的主机和端口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS compare this entire description with XMLSocket.connect() and make consistent
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>未指定任何主机，而且连接失败。
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>此错误出现在 SWF 内容中<ph platform="javascript">。</ph> <ph platform="actionscript">原因如下：</ph>
	 
          <ul platform="actionscript">
              <li>本地不受信任的 SWF 文件可能无法与 Internet 进行通信。可以通过将此文件重新分类为只能与远程内容交互的文件或受信任的文件来突破此限制。</li>
               <li>您不能指定高于 65535 的套接字端口。</li>
           <li>在包含 SWF 内容的 HTML 页中，<codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数设置为 <codeph>"none"</codeph>。</li>
	 
          </ul>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要连接到的主机的名称或 IP 地址。如果未指定主机，则要连接的主机为执行调用的 文件所在的主机。如果不指定主机，请使用事件侦听器来确定连接是否成功。
     </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要连接的端口号。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将套接字连接到指定的主机和端口。如果连接立即失败，则分派一个事件或引发一个异常。如果指定了主机，则分派一个错误事件；如果未指定主机，则引发异常。另外，连接的状态由事件来报告。如果已连接上套接字，则现有的连接将首先关闭。
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.net:Socket:connect_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在建立网络连接后分派。
     </apiDesc></adobeApiEventDetail><shortdesc>在建立网络连接后分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:connect_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在指定了主机但出现输入/输出错误并由此导致连接失败时分派。
     </apiDesc></adobeApiEventDetail><shortdesc>在指定了主机但出现输入/输出错误并由此导致连接失败时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:connect_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>如果对 <codeph>Socket.connect() </codeph>的调用试图与未提供套接字策略文件的服务器进行连接，或者试图与其策略文件未授予执行调用的主机对指定端口的访问权的服务器进行连接，则分派此事件。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“Flash Player 安全性”一章。
     </apiDesc></adobeApiEventDetail><shortdesc>如果对 Socket.connect() 的调用试图与未提供套接字策略文件的服务器进行连接，或者试图与其策略文件未授予执行调用的主机对指定端口的访问权的服务器进行连接，则分派此事件。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:Socket:flush"><apiName>flush</apiName><shortdesc>
     对套接字输出缓冲区中积累的所有数据进行刷新。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。       
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     对套接字输出缓冲区中积累的所有数据进行刷新。<codeph>write</codeph> 方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readBoolean"><apiName>readBoolean</apiName><shortdesc>
     从套接字读取一个布尔值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果所读取的字节不为零，则值为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个布尔值。在读取一个字节之后，如果该字节不为零，则该方法返回 <codeph>true</codeph>，否则返回 <codeph>false</codeph>。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readByte"><apiName>readByte</apiName><shortdesc>
     从套接字读取一个带符号字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>从 -128 至 127 的值。
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个带符号字节。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readBytes"><apiName>readBytes</apiName><shortdesc>
     从套接字读取 length 参数所指定的数据的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>要将数据读入的 ByteArray 对象。
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>数据读取的偏移量应从该字节数组中开始。
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>要读取的字节数。默认值 0 导致读取所有可用的数据。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     从套接字读取 <codeph>length</codeph> 参数所指定的数据的字节数。从 <codeph>offset</codeph> 所指示的位置开始，将这些字节读入指定的字节数组。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readDouble"><apiName>readDouble</apiName><shortdesc>
     从套接字读取一个 IEEE 754 双精度浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个 IEEE 754 双精度浮点数。
     
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个 IEEE 754 双精度浮点数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readFloat"><apiName>readFloat</apiName><shortdesc>
     从套接字读取一个 IEEE 754 单精度浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个 IEEE 754 单精度浮点数。
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个 IEEE 754 单精度浮点数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readInt"><apiName>readInt</apiName><shortdesc>
     从套接字读取一个带符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>从 -2147483648 至 2147483647 的值。
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个带符号的 32 位整数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
     使用指定的字符集，从该字节流读取一个多字节字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Socket, Socket.readMultiByte, readMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>UTF-8 编码的字符串。
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要从字节流中读取的字节数。
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>表示用于解释字节的字符集的字符串。可能的字符集字符串包括 <codeph>"shift_jis"</codeph>、<codeph>"CN-GB"</codeph> 和 <codeph>"iso-8859-1"</codeph>。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character </xref>。
     
     <p><b>注意：</b>如果当前系统无法识别 <codeph>charSet</codeph> 参数的值，则应用程序将使用系统的默认代码页作为字符集。例如，<codeph>charSet</codeph> 参数的值（如在使用 <codeph>01</codeph> 而不是 <codeph>1</codeph> 的 <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> 中）可能在您的开发计算机上起作用，但在其它计算机上可能不起作用。在其它计算机上，应用程序将使用系统的默认代码页。</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     使用指定的字符集，从该字节流读取一个多字节字符串。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readObject"><apiName>readObject</apiName><shortdesc>
     从以 AMF 序列化格式编码的套接字读取一个对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>反序列化的对象
     
     </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
     从以 AMF 序列化格式编码的套接字读取一个对象。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:readShort"><apiName>readShort</apiName><shortdesc>
     从套接字读取一个带符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>从 -32768 至 32767 的值。
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个带符号的 16 位整数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUTF"><apiName>readUTF</apiName><shortdesc>
     从套接字读取一个 UTF-8 字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>UTF-8 字符串。
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个 UTF-8 字符串。假定该字符串的前缀是指示字符串长度（以字节为单位）的无符号短整数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
     从套接字读取 length 参数所指定的 UTF-8 数据的字节数，并返回一个字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>UTF-8 字符串。
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要读取的字节数。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     从套接字读取 <codeph>length</codeph> 参数所指定的 UTF-8 数据的字节数，并返回一个字符串。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
     从套接字读取一个无符号字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>从 0 至 255 的值。
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个无符号字节。  
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
     从套接字读取一个无符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>从 0 至 4294967295 的值。
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个无符号的 32 位整数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
     从套接字读取一个无符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>从 0 至 65535 的值。
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从套接字读取一个无符号的 16 位整数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
     将一个布尔值写入套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>要写入套接字的值：1 (<codeph>true</codeph> ) 或 0 ( <codeph>false</codeph>)。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个布尔值写入套接字。此方法写入了一个字节，其值为 1 (<codeph>true</codeph> ) 或 0 ( <codeph>false</codeph>)。
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeByte"><apiName>writeByte</apiName><shortdesc>
     将一个字节写入套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要写入套接字的值。使用了该值的低 8 位；忽略了高 24 位。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个字节写入套接字。
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeBytes"><apiName>writeBytes</apiName><shortdesc>
     从指定的字节数组写入一系列字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>要从中读取数据的 ByteArray 对象。
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc><codeph>bytes</codeph> ByteArray 对象中从零开始的偏移量，应由此开始执行数据写入。
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>要写入的字节数。默认值 0 导致从 <codeph>offset</codeph> 参数指定的值开始写入整个缓冲区。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     从指定的字节数组写入一系列字节。写入操作从 <codeph>offset</codeph> 指定的位置开始。
     
     <p>如果省略了 <codeph>length</codeph> 参数，则默认长度 0 将导致该方法从 <codeph>offset</codeph> 开始写入整个缓冲区。</p>
     
     <p>如果还省略了 <codeph>offset</codeph> 参数，则写入整个缓冲区。</p> 
      
     <p>如果 <codeph>offset</codeph> 或 <codeph>length</codeph> 超出了范围，则调整它们以匹配 <codeph>bytes</codeph> 数组的开头和结尾。</p>
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeDouble"><apiName>writeDouble</apiName><shortdesc>
     将一个 IEEE 754 双精度浮点数写入套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要写入套接字的值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个 IEEE 754 双精度浮点数写入套接字。
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeFloat"><apiName>writeFloat</apiName><shortdesc>
     将一个 IEEE 754 单精度浮点数写入套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要写入套接字的值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个 IEEE 754 单精度浮点数写入套接字。
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeInt"><apiName>writeInt</apiName><shortdesc>
     将一个带符号的 32 位整数写入套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要写入套接字的值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个带符号的 32 位整数写入套接字。
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
     使用指定的字符集，从该字节流写入一个多字节字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Socket, Socket.writeMultiByte, writeMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>表示用于解释字节的字符集的字符串。可能的字符集字符串包括 <codeph>"shift_jis"</codeph>、<codeph>"CN-GB"</codeph> 和 <codeph>"iso-8859-1"</codeph>。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character </xref>。 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     使用指定的字符集，从该字节流写入一个多字节字符串。
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeObject"><apiName>writeObject</apiName><shortdesc>
     以 AMF 序列化格式将一个对象写入套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>要进行序列化处理的对象。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     以 AMF 序列化格式将一个对象写入套接字。
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeShort"><apiName>writeShort</apiName><shortdesc>
     将一个 16 位整数写入套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要写入套接字的值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个 16 位整数写入套接字。写入的字节如下：
     
     <pre><codeph>(v >> 8) &amp; 0xff v &amp; 0xff</codeph></pre>
     
     <p>使用了该参数的低 16 位；忽略了高 16 位。</p>
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUTF"><apiName>writeUTF</apiName><shortdesc>
     将以下数据写入套接字：一个无符号 16 位整数，它指示了指定 UTF-8 字符串的长度（以字节为单位），后面跟随字符串本身。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>长度大于 65535。
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入套接字的字符串。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将以下数据写入套接字：一个无符号 16 位整数，它指示了指定 UTF-8 字符串的长度（以字节为单位），后面跟随字符串本身。
     
     <p>写入字符串之前，该方法会计算表示该字符串的所有字符所需的字节数。</p>
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
     将一个 UTF-8 字符串写入套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入套接字的字符串。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个 UTF-8 字符串写入套接字。 
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
     将一个无符号的 32 位整数写入套接字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>套接字上发生 I/O 错误，或者套接字未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要写入套接字的值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个无符号的 32 位整数写入套接字。
     
     <p><b>注意：</b>此方法写入的数据不会被立即传送；这些数据在调用 <codeph>flush()</codeph> 方法之前一直被保存在队列中。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiValue id="flash.net:Socket:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
     输入缓冲区中可读取的数据的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     输入缓冲区中可读取的数据的字节数。
     
     <p>代码必须访问 <codeph>bytesAvailable</codeph> 以确保在尝试使用其中一种 <codeph>read</codeph> 方法读取数据之前，有足够的数据可用。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:Socket:connected:get"><apiName>connected</apiName><shortdesc>
     指示此 Socket 对象目前是否已连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指示此 Socket 对象目前是否已连接。如果该套接字当前已连接，则对此属性的调用将返回值 <codeph>true</codeph>，否则将返回 <codeph>false</codeph>。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:Socket:endian:get"><apiName>endian</apiName><shortdesc>
     指示数据的字节顺序；可能的值为来自 flash.utils.Endian 类的常量、Endian.BIG_ENDIAN 或 Endian.LITTLE_ENDIAN。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>Endian.BIG_ENDIAN
     </apiDefaultValue></apiValueDef><apiDesc>
     指示数据的字节顺序；可能的值为来自 flash.utils.Endian 类的常量，<codeph>Endian.BIG_ENDIAN</codeph> 或 <codeph>Endian.LITTLE_ENDIAN</codeph>。
     </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>flash.utils.Endian</linktext></link></related-links></apiValue><apiValue id="flash.net:Socket:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     在写入或读取对象时，控制所使用的 AMF 的版本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     在写入或读取对象时，控制所使用的 AMF 的版本。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding 类</linktext></link><link href="flash.net.xml#Socket/readObject()"><linktext>readObject()</linktext></link><link href="flash.net.xml#Socket/writeObject()"><linktext>writeObject()</linktext></link></related-links></apiValue><apiValue id="flash.net:Socket:timeout:set"><apiName>timeout</apiName><shortdesc>
     指示建立连接时需等待的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     指示建立连接时需等待的毫秒数。
     
     <p>如果在指定时间内未成功建立连接，则连接失败。默认值是 20,000（20 秒）。</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLLoader"><apiName>URLLoader</apiName><shortdesc>
 URLLoader 类以文本、二进制数据或 URL 编码变量的形式从 URL 下载数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 URLLoader 类以文本、二进制数据或 URL 编码变量的形式从 URL 下载数据。在下载文本文件、XML 或其它用于动态数据驱动应用程序的信息时，它很有用。
 
 <p>URLLoader 对象会先从 URL 中下载所有数据，然后才将数据用于应用程序中的代码。它会发出有关下载进度的通知，通过 <codeph>bytesLoaded</codeph> 和 <codeph>bytesTotal</codeph> 属性以及已分派的事件，可以监视下载进度。</p>
 
 <p>在加载非常大的视频文件（如 FLV 的视频文件）时，可能会出现内存不足错误。
 </p>
 
 
 
 <p>当在应用程序安全沙箱以外的安全沙箱中的 <ph platform="actionscript">Flash Player</ph> 和 AIR 应用程序内容中使用此类时，请考虑以下安全模型：</p>
 
 <ul>
 <li>只能与本地文件系统内容交互的沙箱中的 SWF 文件无法加载网络沙箱中的资源所包含的数据，也无法为该资源提供数据。 </li>
 
 <li> 默认情况下，执行调用的 SWF 文件和加载的 URL 必须在同一域中。例如，位于 www.adobe.com 的 SWF 文件只能从同样位于 www.adobe.com 的源中加载数据。要从不同的域中加载数据，请在承载数据的服务器上放置一个 URL 策略文件。</li>
 </ul>
  
 <p>有关安全性的详细信息，请参阅以下部分：</p>
 
 <ul>
 
 <li product="flex">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 
   <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
 
 </ul>
 
 
 </apiDesc><example conref="examples\URLLoaderExample.as"> 下例加载并显示在本地文本文件中找到的数据。它还会跟踪事件处理信息。
 
 <p><b>注意：</b>要运行此示例，请将名为 urlLoaderExample.txt 的文件与 SWF 文件放在同一目录下。该文件应仅包含以下文本行：<codeph>answer=42&amp;question=unknown</codeph>
 </p>
 <p>该示例代码执行以下操作：</p>
 <ol>
    <li>该构造函数创建名为 <codeph>loader</codeph> 的 URLLoader 实例和名为 <codeph>request</codeph> URLRequest 的实例，后者包含要加载的文件的位置和名称。</li>
    <li><codeph>loader</codeph> 对象被传递给 <codeph>configureListeners()</codeph> 方法，该方法可为每个受支持的 URLLoader 事件添加侦听器。</li>
    <li>然后，<codeph>request</codeph> 对象被传递给 <codeph>loader.load()</codeph>，该方法可加载文本文件。</li>
      <li>当 URLLoader 完成文本文件的加载时，将引发 <codeph>Event.COMPLETE event</codeph>，同时触发 <codeph>completeHandler()</codeph> 方法。<codeph>completeHandler()</codeph> 方法通过从该文件中加载的文本创建 URLVariables 对象。URLVariables 对象将 URL 编码的名称/值对转换成 ActionScript 属性，从而更便于处理加载的数据。</li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLLoaderExample extends Sprite {
        public function URLLoaderExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("urlLoaderExample.txt");
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
    
            var vars:URLVariables = new URLVariables(loader.data);
            trace("The answer is " + vars.answer);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream</linktext></link></related-links><adobeApiEvent id="flash.net:URLLoader_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
 在 load() 方法调用尝试通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 <codeph>load()</codeph> 方法调用尝试通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 在 URLLoader.load() 方法调用尝试通过 HTTP 访问数据时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 <codeph>URLLoader.load()</codeph> 方法调用尝试通过 HTTP 访问数据时分派。<ph platform="actionscript">对于在 Flash Player 中运行的内容，只有当前 Flash Player 环境能够检测并返回请求的状态代码时，才能分派此事件。（有些浏览器环境可能无法提供此信息。）</ph>请注意：在发送任何 <codeph>complete</codeph> 或 <codeph>error</codeph> 事件之前还将发送 <codeph>httpStatus</codeph> 事件（如果有）。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 若对 URLLoader.load() 的调用尝试从安全沙箱外部的服务器加载数据，则进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 若对 <codeph>URLLoader.load()</codeph> 的调用尝试从安全沙箱外部的服务器加载数据，则进行分派。在对 <codeph>URLLoader.load()</codeph> 的调用尝试加载 SWZ 文件而证书无效或摘要字符串与组件不匹配时也会分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 若对 URLLoader.load() 的调用导致致命错误并因此终止了下载，则进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 若对 <codeph>URLLoader.load()</codeph> 的调用导致致命错误并因此终止了下载，则进行分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 在下载操作过程中收到数据时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在下载操作过程中收到数据时分派。
 
 <p>请注意，对于 URLLoader 对象，在完全接收数据前无法访问该数据。因此，该 progress 事件仅用作有关下载进展的通知。要在完整下载前访问该数据，请使用 URLStream 对象。 </p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 在对所有已接收数据进行解码并将其放在 URLLoader 对象的 data 属性中以后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在对所有已接收数据进行解码并将其放在 URLLoader 对象的 <codeph>data</codeph> 属性中以后分派。分派该事件后，可以访问已接收的数据。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 在调用 URLLoader.load() 方法之后开始下载操作时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在调用 <codeph>URLLoader.load()</codeph> 方法和开始下载操作时分派。 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:URLLoader:URLLoader"><apiName>URLLoader</apiName><shortdesc>
	 创建 URLLoader 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 URLRequest 对象，指定要下载的 URL。如果省略该参数，则不开始加载操作。如果已指定参数，则立即开始加载操作（有关详细信息，请参阅 <codeph>load</codeph> 条目）。
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建 URLLoader 对象。
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:URLLoader:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	
	使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>事件的类型。
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>处理事件的侦听器函数。此函数必须接受 Event 对象作为其唯一的参数，并且不能返回任何结果<ph platform="actionscript">，如下面的示例所示：</ph> <ph platform="javascript">。</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>函数可以有任何名称。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">此参数适用于 SWF 内容所使用的 ActionScript 3.0 显示列表体系结构中的显示对象。</ph><ph platform="actionscript">确定侦听器是运行于捕获阶段还是目标阶段和冒泡阶段。如果将 <codeph>useCapture</codeph> 设置为 <codeph>true</codeph>，则侦听器只在捕获阶段处理事件，而不在目标或冒泡阶段处理事件。如果 <codeph>useCapture</codeph> 为 <codeph>false</codeph>，则侦听器只在目标或冒泡阶段处理事件。要在所有三个阶段都侦听事件，请调用 <codeph>addEventListener</codeph> 两次：一次将 <codeph>useCapture</codeph> 设置为 <codeph>true</codeph>，一次将 <codeph>useCapture</codeph> 设置为 <codeph>false</codeph>。</ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 <i>n</i> 的所有侦听器会在优先级为 <i>n</i> -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>确定对侦听器的引用是强引用，还是弱引用。强引用（默认值）可防止您的侦听器被当作垃圾回收。弱引用则没有此作用。 <p>类级别成员函数不属于垃圾回收的对象，因此可以对类级别成员函数将 <codeph>useWeakReference</codeph> 设置为 <codeph>true</codeph> 而不会使它们受垃圾回收的影响。如果对作为嵌套内部函数的侦听器将 <codeph>useWeakReference</codeph> 设置为 <codeph>true</codeph>，则该函数将作为垃圾回收并且不再是永久函数。如果创建对该内部函数的引用（将该函数保存到另一个变量中），则该函数将不作为垃圾回收并仍将保持永久。</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	
	使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知。<ph platform="actionscript">可以为特定类型的事件、阶段和优先级在显示列表中的所有节点上注册事件侦听器。</ph>
	
	<p platform="javascript">AIR 运行时中的 JavaScript 代码使用此方法注册 AIR API 定义的事件的事件侦听器。对于其它 JavaScript 事件（如 DOM <codeph>body</codeph> 对象的 <codeph>onload</codeph> 事件），您可以像对浏览器中运行的内容一样使用标准事件处理技术。</p>
	
	<p>成功注册一个事件侦听器后，无法通过额外调用 <codeph>addEventListener()</codeph> 来更改其优先级。要更改侦听器的优先级，必须首先调用 <codeph>removeListener()</codeph>。然后，可以使用新的优先级再次注册该侦听器。 </p>
	
	<p>请记住，注册该侦听器后，如果继续调用具有不同 <codeph>type</codeph> 或 <codeph>useCapture</codeph> 值的 <codeph>addEventListener()</codeph>，则会创建单独的侦听器注册。<ph platform="actionscript">例如，如果首先注册 <codeph>useCapture</codeph> 设置为 <codeph>true</codeph> 的侦听器，则该侦听器只在捕获阶段进行侦听。如果使用同一个侦听器对象再次调用 <codeph>addEventListener()</codeph>，并将 <codeph>useCapture</codeph> 设置为 <codeph>false</codeph>，那么便会拥有两个单独的侦听器：一个在捕获阶段进行侦听，另一个在目标和冒泡阶段进行侦听。</ph>
	</p>
	
	<p platform="actionscript">不能只为目标阶段或冒泡阶段注册事件侦听器。这些阶段在注册期间是成对出现的，因为冒泡阶段只适用于目标节点的始祖。</p>
	
	<p>如果不再需要某个事件侦听器，可调用 <codeph>removeEventListener()</codeph> 删除它，否则会产生内存问题。事件侦听器不会自动从内存中删除，因为只要调度对象存在，垃圾回收器就不会删除侦听器（除非 <codeph>useWeakReference</codeph> 参数设置为 <codeph>true</codeph>）。</p>
		
	<p>复制 EventDispatcher 实例时并不复制其中附加的事件侦听器。（如果新近创建的节点需要一个事件侦听器，必须在创建该节点后附加该侦听器。）但是，如果移动 EventDispatcher 实例，则其中附加的事件侦听器也会随之移动。</p>
	
	
	<p platform="actionscript">如果在正在处理事件的节点上注册事件侦听器，则不会在当前阶段触发事件侦听器，但会在事件流的稍后阶段触发，如冒泡阶段。</p>
	
	<p platform="actionscript">如果从正在处理事件的节点中删除事件侦听器，则该事件侦听器仍由当前操作触发。删除事件侦听器后，决不会再次调用该事件侦听器（除非再次注册以备将来处理）。 </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLLoader:close"><apiName>close</apiName><shortdesc>
	 关闭进行中的加载操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 关闭进行中的加载操作。任何正在进行中的加载操作将立即终止。如果当前未对 URL 进行流式处理，将引发无效流错误。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLLoader:load"><apiName>load</apiName><shortdesc>
	 从指定的 URL 发送和加载数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>URLRequest.requestHeader</codeph> 对象不能包含某些被禁用的 HTTP 请求标头。有关详细信息，请参阅 URLRequestHeader 类的描述。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>发生此错误的原因有：1) <ph platform="actionscript">Flash Player 或</ph> AIR 无法将 <codeph>URLRequest.data</codeph> 参数从 UTF8 转换为 MBCS。若传递给 <codeph>load()</codeph> 的 URLRequest 对象设置为执行 <codeph>GET</codeph> 操作并且 <codeph>System.useCodePage</codeph> 设置为 <codeph>true</codeph>，就会发生该错误。2) <ph platform="actionscript">Flash Player 或</ph> AIR 无法为 <codeph>POST</codeph> 数据分配内存。如果传递给 <codeph>load</codeph> 的 URLRequest 对象设置为执行 <codeph>POST</codeph> 操作，将发生该错误。
	 
	 </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>本地不受信任的 文件可能无法与 Internet 进行通信。可通过将此 文件重新分类为只能与远程内容交互或受信任来解决此问题。
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果尝试连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。
     
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>所传递的请求参数值或 URLRequest 对象的 <codeph>URLRequest.url</codeph> 属性为 <codeph>null</codeph>。
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>一个 URLRequest 对象，指定要下载的 URL。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从指定的 URL 发送和加载数据。可以以文本、原始二进制数据或 URL 编码变量格式接收数据，这取决于为 <codeph>dataFormat</codeph> 属性所设置的值。请注意 <codeph>dataFormat</codeph> 属性的默认值为文本。如果想将数据发送至指定的 URL，则可以在 URLRequest 对象中设置 <codeph>data</codeph> 属性。
	 
	 <p><b>注意：</b>如果要加载的文件包含非 ASCII 字符（在许多非英语的语言中出现），则建议使用 UTF-8 或 UTF-16 编码（而不是 ASCII 等非 Unicode 格式）来保存文件。</p>
	 
	 <p> 只能与本地文件系统内容交互的沙箱中的 SWF 文件无法加载网络沙箱中的资源所包含的数据，也无法为该资源提供数据。</p> 
	  
	 <p> 默认情况下，执行调用的 SWF 文件和加载的 URL 必须在同一域中。例如，位于 www.adobe.com 的 SWF 文件只能从同样位于 www.adobe.com 的源中加载数据。要从不同的域中加载数据，请在承载数据的服务器上放置一个 URL 策略文件。</p>
	 
      <p>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_cn" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_cn" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。</p>
     
     <p> 在 Flash Player 10 和更高版本中，如果使用包含上载（由 POST 体内的“content-disposition”标头中的“filename”参数表示）的 multipart Content-Type（例如“multipart/form-data”），则 POST 操作会受应用于上载的安全规则的约束：</p>
	 <ul>
	 <li>必须执行 POST 操作以响应用户启动的操作（如鼠标单击或按键）。</li>
	 <li>如果 POST 操作是跨域的（POST 目标与发送 POST 请求的 SWF 文件不在同一台服务器上），则目标服务器必须提供一个允许跨域访问的 URL 策略文件。</li>
	 </ul>
     <p>另外，对于任何 multipart Content-Type，语法必须有效（根据 RFC2046 标准）。如果语法无效，则 POST 操作受应用于上载的安全规则约束。</p>
     
	 <p>有关安全性的详细信息，请参阅以下部分：</p>
	 
     <ul>
     
     
	 <li><i>Developing AIR Applications</i>（《开发 AIR 应用程序》）一书的“Getting started with Adobe AIR”（Adobe AIR 入门）一章中的“Understanding AIR Security”（了解 AIR 安全性）一节。</li>
	 
	 <li><xref href="http://www.adobe.com/go/fp9_0_security_cn" scope="external">Flash Player 9 Security 安全性</xref></li>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_cn" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
       <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
     
     </ul>
	 
	 </apiDesc><example conref="examples\URLLoader_loadExample.as"> 在下面的示例中，加载了一个 XML 文件，并在文本字段中显示其元素的第一个参数的内容。
 
 <p>将创建一个用于指定 XML 文件位置的 <codeph>URLRequest</codeph> 对象，就本示例而言，该文件与 SWF 文件位于同一个目录中。将在 <codeph>try...catch</codeph> 块中加载该文件，以便捕获可能发生的任何错误。（此处，我们捕获了 <codeph>SecurityError</codeph> 错误。） 如果发生 <codeph>IO_ERROR</codeph> 事件，则会调用 <codeph>errorHandler()</codeph> 方法，它在 <codeph>xmlTextField</codeph> 文本字段中写入一条错误消息。在收到 XML 文件数据并将其放在 <codeph>loader</codeph> URLLoader 对象的 data 属性中后，将分派 <codeph>Event.COMPLETE</codeph> 事件并调用 <codeph>loaderCompleteHandler()</codeph> 方法。</p>
 
 <p>在 <codeph>loaderCompleteHandler()</codeph> 方法中，使用 <codeph>try...catch</codeph> 块来捕获将从文件中加载的数据转换为 XML 对象时可能发生的任何分析错误。<codeph>readNodes()</codeph> 方法随后以递归方式查看 XML 文档节点中的所有元素，并在 <codeph>xmlTextField</codeph> 文本字段中附加所有元素的第一个属性的列表。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.xml.*;
    import flash.events.IOErrorEvent;
  
    public class URLLoader_loadExample extends Sprite {
        private var xmlTextField:TextField = new TextField();
        private var externalXML:XML;    
        private var loader:URLLoader;

        public function URLLoader_loadExample() {
            var request:URLRequest = new URLRequest("xmlFile.xml");

            loader = new URLLoader();
            
            try {
                loader.load(request);
            }
            catch (error:SecurityError)
            {
                trace("A SecurityError has occurred.");
            }

             loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);

            xmlTextField.x = 10;
            xmlTextField.y = 10;
            xmlTextField.background = true;
            xmlTextField.autoSize = TextFieldAutoSize.LEFT;

            addChild(xmlTextField);
        }

        private function loaderCompleteHandler(event:Event):void {

                try {
                    externalXML = new XML(loader.data);
                    readNodes(externalXML);    
                } catch (e:TypeError) {
                    trace("Could not parse the XML file.");
                }
        }

        private function readNodes(node:XML):void {

                for each (var element:XML in node.elements()) {
                    xmlTextField.appendText(element.attributes()[0] + "\n");

                    readNodes(element);
                }    
        }

        private function errorHandler(e:IOErrorEvent):void {
            xmlTextField.text = "Had problem loading the XML File.";
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link><link href="flash.net.xml#URLRequest/requestHeaders"><linktext>URLRequest.requestHeaders</linktext></link><link href="flash.net.xml#URLRequest/data"><linktext>URLRequest.data</linktext></link><link href="flash.net.xml#URLRequest/digest"><linktext>URLRequest.digest</linktext></link></related-links><adobeApiEvent id="flash.net:URLLoader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在成功加载数据后分派。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在成功加载数据后分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>如果通过 HTTP 进行访问，并且当前 Flash Player 环境支持获得状态代码，则除了 <codeph>complete </codeph>或 <codeph>error </codeph>事件，还可以接收到这些事件。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>如果通过 HTTP 进行访问，并且当前 Flash Player 环境支持获得状态代码，则除了 complete 或 error 事件，还可以接收到这些事件。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法完成加载操作。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>无法完成加载操作。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在下载操作过程中收到数据时分派。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在下载操作过程中收到数据时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>加载操作尝试从调用方安全沙箱外部的服务器检索数据。可以通过在服务器上使用策略文件来解决此问题。
	 </apiDesc></adobeApiEventDetail><shortdesc>加载操作尝试从调用方安全沙箱外部的服务器检索数据。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>加载操作尝试加载 SWZ 文件（一个 Adobe 平台组件），但是证书无效或摘要与组件不匹配。
	 </apiDesc></adobeApiEventDetail><shortdesc>加载操作尝试加载 SWZ 文件（一个 Adobe 平台组件），但是证书无效或摘要与组件不匹配。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在加载操作开始时分派。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在加载操作开始时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在对 <codeph>load()</codeph> 方法的调用试图通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在对 load() 方法的调用试图通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:URLLoader:bytesLoaded"><apiName>bytesLoaded</apiName><shortdesc>
	 指示加载操作期间到目前为止加载的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 指示加载操作期间到目前为止加载的字节数。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoader:bytesTotal"><apiName>bytesTotal</apiName><shortdesc>
	 指示所下载数据中的字节总数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 指示所下载数据中的字节总数。正在进行加载操作时该属性包含 0，完成操作时会填充该属性。另外，丢失的 Content-Length 标题将会导致 bytesTotal 不确定。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoader:data"><apiName>data</apiName><shortdesc>
	 从加载操作接收的数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value=""/></apiValueDef><apiDesc>
	 从加载操作接收的数据。只有完成加载操作时，才会填充该属性。该数据的格式取决于 <codeph>dataFormat</codeph> 属性的设置：
	 
	 <p>如果 <codeph>dataFormat</codeph> 属性是 <codeph>URLLoaderDataFormat.TEXT</codeph>，则所接收的数据是一个包含已加载文件文本的字符串。</p>
	 
	 <p>如果 <codeph>dataFormat</codeph> 属性是 <codeph>URLLoaderDataFormat.BINARY</codeph>，则所接收的数据是一个包含原始二进制数据的 ByteArray 对象。</p>
	 
	 <p>如果 <codeph>dataFormat</codeph> 属性是 <codeph>URLLoaderDataFormat.VARIABLES</codeph>，则所接收的数据是一个包含 URL 编码变量的 URLVariables 对象。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLLoaderDataFormat"><linktext>URLLoaderDataFormat</linktext></link><link href="flash.net.xml#URLLoader/dataFormat"><linktext>URLLoader.dataFormat</linktext></link></related-links></apiValue><apiValue id="flash.net:URLLoader:dataFormat"><apiName>dataFormat</apiName><shortdesc>
	 控制是以文本 (URLLoaderDataFormat.TEXT)、原始二进制数据 (URLLoaderDataFormat.BINARY) 还是 URL 编码变量 (URLLoaderDataFormat.VARIABLES) 形式接收下载的数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>text</apiData><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>URLLoaderDataFormat.TEXT
	 
	 </apiDefaultValue></apiValueDef><apiDesc>
	 控制是以文本 (<codeph>URLLoaderDataFormat.TEXT</codeph>)、原始二进制数据 (<codeph>URLLoaderDataFormat.BINARY</codeph>) 还是 URL 编码变量 (<codeph>URLLoaderDataFormat.VARIABLES</codeph>) 接收下载的数据。
	 
	 <p>如果 <codeph>dataFormat</codeph> 属性的值是 <codeph>URLLoaderDataFormat.TEXT</codeph>，则所接收的数据是一个包含已加载文件文本的字符串。</p>
	 
	 <p>如果 <codeph>dataFormat</codeph> 属性的值是 <codeph>URLLoaderDataFormat.BINARY</codeph>，则所接收的数据是一个包含原始二进制数据的 ByteArray 对象。</p>
	 
	 <p>如果 <codeph>dataFormat</codeph> 属性的值是 <codeph>URLLoaderDataFormat.VARIABLES</codeph>，则所接收的数据是一个包含 URL 编码变量的 URLVariables 对象。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLLoaderDataFormat"><linktext>URLLoaderDataFormat</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamPlayOptions"><apiName>NetStreamPlayOptions</apiName><shortdesc>
 
 NetStreamPlayOptions 类指定可以传递给 NetStream.play2() 方法的各个选项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>NetStreamPlayOptions 类指定可以传递给 NetStream.play2() 方法的各个选项。 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 NetStreamPlayOptions 类指定可以传递给 <codeph>NetStream.play2()</codeph> 方法的各个选项。将 NetStreamPlayOptions 对象传递给 <codeph>play2()</codeph> 后，该类的属性会指定各个选项。此类的主要用途是动态实现流之间的过渡，以便切换具有不同比特率和大小的流或交换到播放列表中的不同内容。
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:NetStreamPlayOptions:NetStreamPlayOptions"><apiName>NetStreamPlayOptions</apiName><shortdesc>
     
     创建一个 NetStreamPlayOptions 对象以指定要传递给 NetStream.play2() 方法的选项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     
     创建一个 NetStreamPlayOptions 对象以指定要传递给 <codeph>NetStream.play2()</codeph> 方法的选项。 
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiConstructor><apiValue id="flash.net:NetStreamPlayOptions:len"><apiName>len</apiName><shortdesc>
    streamName 中指定的流的持续播放时间（以秒为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>streamName 中指定的流的持续播放时间（以秒为单位）。
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    <codeph>streamName</codeph> 中指定的流的持续播放时间（以秒为单位）。默认值为 -1，这意味着 Flash Player 会播放实时流直到此流不再可用，或播放录制流直至结尾。如果传递给 <codeph>len</codeph> 的值为 0，则 Flash Player 将播放录制流开始后的 <codeph>start</codeph> 秒处的单个帧（假设 <codeph>start</codeph> 值大于或等于 0）。
    <p>如果传递给 <codeph>len</codeph> 的值为正数，则 Flash Player 会在实时流可用后将其播放 <codeph>len</codeph> 秒，或将录制流播放 <codeph>len</codeph> 秒。（如果流在 <codeph>len</codeph> 秒之前结束，则播放会随流的结束而结束。）</p> 
    <p>如果传递给 <codeph>len</codeph> 的值为 -1 之外的负数，则 Flash Player 会将该值视为 -1 进行解释。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions/start"><linktext>start</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:oldStreamName"><apiName>oldStreamName</apiName><shortdesc>
    旧的流或要从其过渡的流的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    旧的流或要从其过渡的流的名称。当使用 <codeph>NetStream.play2()</codeph> 简单地播放流（而不执行过渡）时，此属性的值应为 null 或未定义。否则，请指定要从其过渡的流。   
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions/streamName"><linktext>streamName</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:start"><apiName>start</apiName><shortdesc>
    streamName 的开始时间（以秒为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>streamName 的开始时间（以秒为单位）。
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    <codeph>streamName</codeph> 的开始时间（以秒为单位）。有效值为 -2、-1 和 0。
    
    <p><codeph>start</codeph> 的默认值为 -2，这意味着 Flash Player 将首先尝试播放 <codeph>streamName</codeph> 中指定的实时流。如果未找到具有该名称的实时流，Flash Player 将播放 <codeph>streamName</codeph> 中指定的录制流。如果实时流和录制流均未找到，Flash Player 将打开名为 <codeph>streamName</codeph> 的实时流（即使无人在此实时流上进行发布）。当有人开始在此实时流上进行发布时，Flash Player 将开始播放此流。</p>
    
    <p>如果传递给 <codeph>start</codeph> 的值为 -1，则 Flash Player 仅播放 <codeph>streamName</codeph> 中指定的实时流。在未找到任何实时流的情况下，如果 <codeph>len</codeph> 设置为 -1，则 Flash Player 会无限期地等待实时流；如果 <codeph>len</codeph> 设置为其它值，则 Flash Player 会在等待 <codeph>len</codeph> 值指定的秒数之后，开始播放播放列表中的下一项。</p>
    
    <p> 如果传递给 <codeph>start</codeph> 的值为 0 或一个正数，则 Flash Player 仅播放名为 <codeph>streamName</codeph> 的录制流，并从该流开始后的 <codeph>start</codeph> 秒处开始播放。如果未找到任何录制流，则 Flash Player 将立即开始播放播放列表中的下一项。</p>
    
    <p>如果传递给 <codeph>start</codeph> 的值为 -1 或 -2 之外的负数，则 Flash Player 会将该值视为 -2 进行解释。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions/len"><linktext>len</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:streamName"><apiName>streamName</apiName><shortdesc>
    要过渡到或播放的新流的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    要过渡到或播放的新流的名称。如果 <codeph>oldStreamName</codeph> 为 null 或未定义，则只需调用 <codeph>NetStream.play2()</codeph> 即可开始播放 <codeph>streamName</codeph>。如果指定了 <codeph>oldStreamName</codeph>，则当调用 <codeph>NetStream.play2()</codeph> 时，将使用 <codeph>transition</codeph> 属性中指定的过渡模式将 <codeph>oldStreamName</codeph> 过渡到 <codeph>streamName</codeph>。 
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions/oldStreamName"><linktext>oldStreamName</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:transition"><apiName>transition</apiName><shortdesc>
    播放或过渡到 streamName 所使用的模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>播放或过渡到 streamName 所使用的模式。
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    播放或过渡到 <codeph>streamName</codeph> 所使用的模式。可能的值是 NetStreamPlayTransitions 类中的常量。根据是否调用 <codeph>Netstream.play2()</codeph> 来播放或过渡某个流，过渡模式会导致不同的行为。有关过渡模式的详细信息，请参阅 NetStreamPlayTransitions 类。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayTransitions"><linktext>NetStreamPlayTransitions</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:IDynamicPropertyOutput"><apiName>IDynamicPropertyOutput</apiName><shortdesc>
	 此接口控制动态对象的动态属性的序列化。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 此接口控制动态对象的动态属性的序列化。将该接口与 IDynamicPropertyWriter 接口和 <codeph>ObjectEncoding.dynamicPropertyWriter</codeph> 属性一起使用。
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links><apiOperation id="flash.net:IDynamicPropertyOutput:flash.net:IDynamicPropertyOutput:writeDynamicProperty"><apiName>writeDynamicProperty</apiName><shortdesc>
		 将动态属性添加到已序列化对象的二进制输出。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>该属性的名称。可以使用该参数来指定动态对象现有属性的名称，也可以创建一个新属性。  
		 
		 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>要写入指定属性值。
		 
         </apiDesc></apiParam></apiOperationDef><apiDesc>
		 将动态属性添加到已序列化对象的二进制输出。随后读取该对象时（使用 <codeph>readObject</codeph> 等方法），该对象会包含新的属性。可以使用该方法从序列化中排除动态对象的属性，将值写入动态对象的属性中，或为动态对象创建新属性。
		 
         </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.net:URLVariables"><apiName>URLVariables</apiName><shortdesc>
 
 使用 URLVariables 类可以在应用程序和服务器之间传输变量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, constructor
</keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 使用 URLVariables 类可以在应用程序和服务器之间传输变量。将 URLVariables 对象与 URLLoader 类的方法、URLRequest 类的 <codeph>data</codeph> 属性和 flash.net 包函数一起使用。
 
 </apiDesc><example conref="examples\URLVariablesExample.as"> 下例在一个新的浏览器窗口中打开位于 http://www.[yourDomain].com/application.jsp 上的远程应用程序，并将 URLVariables 对象中捕获的有关用户会话的数据传递给该应用程序。 
  
 <p>该示例的要点遵循：</p>
 <ol>
    <li>构造函数会创建名为 <codeph>request</codeph> 的 URLRequest 实例，同时将远程应用程序的 URL 作为参数。</li>
    <li>创建了一个 URLVariables 对象，并对它的两个属性进行了赋值。</li>
    <li>URLVariables 对象被赋给了 URLRequest 对象的 <codeph>data</codeph> 属性。</li>
    <li>该示例调用 <codeph>navigateToURL</codeph>，在一个新的浏览器窗口中打开远程应用程序的 URL。</li>
 </ol>
 <p> <b>注意：</b>要运行该示例，必须将该示例中的远程应用程序 URL 替换为工作 URL。此外，需要用服务器代码处理 Flash Player 在 URLVariables 对象中捕获的信息。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class URLVariablesExample extends Sprite {

        public function URLVariablesExample() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLVariables:URLVariables"><apiName>URLVariables</apiName><shortdesc>
	 创建一个新的 URLVariables 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>包含名称/值对的 URL 编码的字符串。
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 URLVariables 对象。将 URLVariables 对象传递给 URLRequest 对象的 <codeph>data</codeph> 属性。
	 
	 <p>如果使用字符串来调用 URLVariables 构造函数，将自动调用 <codeph>decode()</codeph> 方法，以将该字符串转换成 URLVariables 对象的属性。</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.net:URLVariables:decode"><apiName>decode</apiName><shortdesc>
	 将变量字符串转换为指定 URLVariables 对象的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, URLVariables.decode, decode
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>源参数必须是包含名称/值对的 URL 编码的查询字符串。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>包含名称/值对的 URL 编码的查询字符串。	 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将变量字符串转换为指定 URLVariables 对象的属性。
	 <p>该方法供 URLVariables 事件内部使用。绝大多数用户无需直接调用此方法。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLVariables:toString"><apiName>toString</apiName><shortdesc>
	 以 MIME 内容编码格式 application/x-www-form-urlencoded 返回包含所有可枚举变量的字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, URLVariables.toString, toString
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>包含名称/值对的 URL 编码的字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 以 MIME 内容编码格式 <i>application/x-www-form-urlencoded</i> 返回包含所有可枚举变量的字符串。
	 
	 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.net:IDynamicPropertyWriter"><apiName>IDynamicPropertyWriter</apiName><shortdesc>
     此接口与 IDynamicPropertyOutput 接口一起用于控制动态对象的动态属性的序列化。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
     此接口与 IDynamicPropertyOutput 接口一起用于控制动态对象的动态属性的序列化。为了使用此接口，则应将实现了 IDynamicPropertyWriter 接口的对象赋给 <codeph>ObjectEncoding.dynamicPropertyWriter</codeph> 属性。
      
     </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#IDynamicPropertyOutput"><linktext>IDynamicPropertyOutput</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links><apiOperation id="flash.net:IDynamicPropertyWriter:flash.net:IDynamicPropertyWriter:writeDynamicProperties"><apiName>writeDynamicProperties</apiName><shortdesc>
         将 IDynamicPropertyOutput 对象的名称和值写入带有动态属性的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要写入的对象。
		 </apiDesc></apiParam><apiParam><apiItemName>output</apiItemName><apiOperationClassifier>flash.net:IDynamicPropertyOutput</apiOperationClassifier><apiDesc>包含要动态写入对象的名称和值的 IDynamicPropertyOutput 对象。
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
         将 IDynamicPropertyOutput 对象的名称和值写入带有动态属性的对象。如果设置了 <codeph>ObjectEncoding.dynamicPropertyWriter</codeph>，则可为带有动态属性的每个对象调用此方法。 
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#IDynamicPropertyOutput"><linktext>IDynamicPropertyOutput</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.net:URLRequestDefaults"><apiName>URLRequestDefaults</apiName><shortdesc>
 URLRequestDefaults 类包含一些静态属性，可以设置这些属性以便为 URLRequest 类的属性定义默认值。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 URLRequestDefaults 类包含一些静态属性，可以设置这些属性以便为 URLRequest 类的属性定义默认值。该类还包括一个静态方法 <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph>，使用该方法可以定义请求的默认身份验证凭据。URLRequest 类定义要在 HTTP 请求中使用的信息。 
 
 <p>URLRequest 对象中设置的任何属性都会覆盖为 URLRequestDefaults 类设置的那些静态属性。</p>
 
 <p>URLRequestDefault 设置仅适用于调用方应用程序域中的内容，但有一个例外：通过调用 <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph> 进行的设置适用于当前正在运行的应用程序中的所有应用程序域。</p>
 
 <p>只有在应用程序安全沙箱中运行的 Adobe<sup>®</sup> AIR<sup>®</sup> 内容才能使用 URLRequestDefaults 类。访问此类的成员或属性时，其它内容会导致引发 SecurityError。</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link></related-links><apiOperation id="flash.net:URLRequestDefaults:setLoginCredentialsForHost"><apiName>setLoginCredentialsForHost</apiName><shortdesc>
	为选定的主机设置默认用户和密码凭据。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>hostname</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>应用用户名和密码的主机名称。此名称可以是域，如 <codeph>"www.example.com"</codeph>；也可以是域和端口号，如 <codeph>"www.example.com:80"</codeph>。请注意，<codeph>"example.com"</codeph>、<codeph>"www.example.com"</codeph> 和 <codeph>"sales.example.com"</codeph>均视为唯一的主机。 
	
	</apiDesc></apiParam><apiParam><apiItemName>user</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要在针对指定主机进行的请求身份验证中使用的默认用户名。
	
	</apiDesc></apiParam><apiParam><apiItemName>password</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要在针对指定主机进行的请求身份验证中使用的默认密码。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	为选定的主机设置默认用户和密码凭据。这些设置适用于应用程序的所有应用程序域中的 URLRequest 对象，而不仅仅适用于调用此方法的对象的应用程序域中的 URLRequest 对象（但 URLRequest 类的静态属性只适用于调用方的应用程序域）。当应用程序的另一部分登录时，这可以让整个应用程序的内容登录（不管该内容位于哪个应用程序域）。
	
	<p><i>注意在 Mac OS 中运行的应用程序：</i>在 Mac OS 中调用此方法时，应用程序将对指定主机使用这些凭据，直到应用程序关闭为止，即使随后对同一主机调用 <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph> 也是如此。但如果服务器拒绝此方法指定的凭据，则将识别随后对 <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph> 方法（对于同一主机）的调用。</p>
	
	<p><i>注意：</i>此方法不适用于文件上载或 RTMP 请求中使用的 URLRequest 对象。</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:URLRequestDefaults:authenticate:get"><apiName>authenticate</apiName><shortdesc>
	URLRequest 对象的 authenticate 属性的默认设置。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	URLRequest 对象的 <codeph>authenticate</codeph> 属性的默认设置。在 URLRequest 对象中设置 <codeph>authenticate</codeph> 属性将覆盖此默认设置。
	
	<p><i>注意：</i>此设置不适用于文件上载或 RTMP 请求中使用的 URLRequest 对象。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/authenticate"><linktext>URLRequest.authenticate</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:cacheResponse:get"><apiName>cacheResponse</apiName><shortdesc>
	URLRequest 对象的 cacheResponse 属性的默认设置。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	URLRequest 对象的 <codeph>cacheResponse</codeph> 属性的默认设置。在 URLRequest 对象中设置 <codeph>cacheResponse</codeph> 属性将覆盖此默认设置。设置为 <codeph>true</codeph> 时，AIR 应用程序的默认行为是使用操作系统的 HTTP 缓存。此设置不适用于文件上载或 RTMP 请求中使用的 URLRequest 对象。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/cacheResponse"><linktext>URLRequest.cacheResponse</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:followRedirects:get"><apiName>followRedirects</apiName><shortdesc>
	URLRequest 对象的 followRedirects 属性的默认设置。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	URLRequest 对象的 <codeph>followRedirects</codeph> 属性的默认设置。在 URLRequest 对象中设置 <codeph>followRedirects</codeph> 属性将覆盖此默认设置。此设置不适用于文件上载或 RTMP 请求中使用的 URLRequest 对象。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/followRedirects"><linktext>URLRequest.followRedirects</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:manageCookies:get"><apiName>manageCookies</apiName><shortdesc>
	URLRequest 对象的 manageCookies 属性的默认设置。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	URLRequest 对象的 <codeph>manageCookies</codeph> 属性的默认设置。在 URLRequest 对象中设置 <codeph>manageCookies</codeph> 属性将覆盖此默认设置。
	
	<p><i>注意：</i>此设置不适用于文件上载或 RTMP 请求中使用的 URLRequest 对象。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/manageCookies"><linktext>URLRequest.manageCookies</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:useCache:get"><apiName>useCache</apiName><shortdesc>
	URLRequest 对象的 useCache 属性的默认设置。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	URLRequest 对象的 <codeph>useCache</codeph> 属性的默认设置。在 URLRequest 对象中设置 <codeph>useCache</codeph> 属性将覆盖此默认设置。此设置不适用于文件上载或 RTMP 请求中使用的 URLRequest 对象。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/useCache"><linktext>URLRequest.useCache</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:userAgent:get"><apiName>userAgent</apiName><shortdesc>
	URLRequest 对象的 userAgent 属性的默认设置。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	URLRequest 对象的 <codeph>userAgent</codeph> 属性的默认设置。在 URLRequest 对象中设置 <codeph>userAgent</codeph> 属性将覆盖此默认设置。
	
	<p>这也是用于所有 HTMLLoader 对象（调用 HTMLLoader 对象的 <codeph>load()</codeph> 方法时使用）的默认用户代理字符串。设置 HTMLLoader 对象的 <codeph>userAgent</codeph> 属性将覆盖 <codeph>URLRequestDefaults.userAgent</codeph> 设置。</p>
	
	<p>此默认值随着运行时操作系统（如 Mac OS、Linux 或 Windows）、运行时语言和运行时版本而变化，如下面的示例所示：</p>
	
	<ul>
	
		<li><codeph>"Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/526.9+ (KHTML, like Gecko) AdobeAIR/1.5"</codeph></li>
		<li><codeph>"Mozilla/5.0 (Windows; U; en) AppleWebKit/526.9+ (KHTML, like Gecko) AdobeAIR/1.5"</codeph></li>
     <li><codeph>"Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/526.9+ (KHTML, like Gecko) AdobeAIR/1.5"</codeph></li>
	
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/userAgent"><linktext>flash.net.URLRequest.userAgent</linktext></link><link href="../../flash/html/HTMLLoader.html#userAgent"><linktext>flash.html.HTMLLoader.userAgent</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:flash.net:getClassByAlias"><apiName>getClassByAlias</apiName><shortdesc>
     查找一个类，这个类先前具有一个通过调用 registerClassAlias() 方法进行注册的别名。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>includeExample examples\GetClassByAliasExample.as -noswf
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>未注册别名。
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiReturn><apiDesc>与给定别名相关联的类。如果未找到，将引发异常。
     
     </apiDesc><apiOperationClassifier>Class</apiOperationClassifier></apiReturn><apiParam><apiItemName>aliasName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要查找的别名。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     查找一个类，这个类先前具有一个通过调用 <codeph>registerClassAlias()</codeph> 方法进行注册的别名。
     <p>此方法不与 <codeph>flash.utils.getDefinitionByName()</codeph> 方法进行交互。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#/registerClassAlias()"><linktext>registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:navigateToURL"><apiName>navigateToURL</apiName><shortdesc>
     在包含 Flash Player 容器的应用程序（通常是一个浏览器）中，打开或替换一个窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError The "digest" and "importToSandbox" properties of URLRequest
     are not supported by URLLoader.navigate.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>request</codeph> 对象的 <codeph>digest</codeph> 属性不是 <codeph>null</codeph>。如果在加载 SWZ 文件（一个 Adobe 平台组件）时调用 <codeph>URLLoader.load()</codeph> 方法，仅应设置 URLRequest 对象的 <codeph>digest</codeph> 属性。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>在 Flash Player（和 Adobe AIR 中的非应用程序沙箱内容）中，以下情况将引发此错误：
     <ul>
       <li>本地不受信任的 SWF 文件可能无法与 Internet 进行通信。要避免这种情况，可将此 SWF 文件重新分类为只能与远程内容交互或受信任。</li>
     
       <li>导航操作试图评估伪 URL 的脚本编写，但包含文档（通常是浏览器中的一个 HTML 文档）来自您不具有访问权限的沙箱。要避免这种情况，可以在包含文档中指定 <codeph>allowScriptAccess="always"</codeph>。</li>
     
       <li>如果 SWF 文件包含在已将 <codeph>allowScriptAccess</codeph> 设置为 <codeph>"none"</codeph> 或 <codeph>"sameDomain"</codeph> 的 HTML 页中，而此 HTML 文件与 SWF 文件的域不匹配，将无法导航特殊窗口 <codeph>"_self"</codeph>、<codeph>"_top"</codeph> 或 <codeph>"_parent"</codeph>。</li>
     
       <li>不能导航具有非默认名称的窗口，非默认名称来自位于 local-with-filesystem 沙箱中的 SWF 文件。</li>
     
      <li>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。 </li>
     
     </ul>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>为了响应用户动作（如鼠标事件或按键事件），将不会调用此方法。此要求仅适用于 Flash Player 中的内容和 Adobe AIR 中的非应用程序沙箱内容。
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>URLRequest 对象，指定要导航到哪个 URL。
     
     <p><ph platform="actionscript">对于在 Adobe AIR 中运行的内容，</ph><ph platform="javascript">当</ph>使用 <codeph>navigateToURL()</codeph> 函数时，运行时将使用 POST 方法的 URLRequest（其 <codeph>method</codeph> 属性设置为 <codeph>URLRequestMethod.POST</codeph>）视为使用 GET 方法。</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>浏览器窗口或 HTML 帧，其中显示 <codeph>request</codeph> 参数指示的文档。可以输入某个特定窗口的名称，或使用以下值之一：
     <ul>
     <li><codeph>"_self"</codeph> 指定当前窗口中的当前帧。</li>
     <li><codeph>"_blank"</codeph> 指定一个新窗口。</li>
     <li><codeph>"_parent"</codeph> 指定当前帧的父级。</li>
     <li><codeph>"_top"</codeph> 指定当前窗口中的顶级帧。</li>
     </ul>
     <p>如果没有为此参数指定值，将创建一个新的空窗口。在独立播放器中，可以指定新的 (<codeph>"_blank"</codeph>) 窗口，也可以指定已命名的窗口。其它值不适用。</p>
     
     <p platform="actionscript"><b>注意：</b>如果在只能与本地文件系统内容交互的沙箱中运行的 SWF 文件中的代码调用 <codeph>navigateToURL()</codeph> 函数，并为 <codeph>window</codeph> 参数指定一个自定义窗口名称，该窗口名称将转换为一个随机名称。该名称的格式为 <codeph>"_flashXXXXXXXX"</codeph>，其中每个 X 均代表一个随机的十六进制数字。在同一会话中（直到您关闭包含浏览器窗口），如果您再次调用该函数并为 <codeph>window</codeph> 参数指定同一名称，将使用同一个随机字符串。</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     <ph platform="actionscript">在包含 Flash Player 容器的应用程序（通常是一个浏览器）中，打开或替换一个窗口。在 Adobe AIR 中，该函数可在默认的系统 Web 浏览器中打开 URL。</ph><ph platform="javascript">在默认的系统 Web 浏览器中打开 URL。</ph>
     
	 	<p>  <b><i>重要安全提示 </i></b> </p>
     	<p>开发人员通常将获取自 FlashVars 等外部来源的 URL 值传递给 <codeph>navigateToURL()</codeph> 函数。攻击者可能会尝试操纵这些外部来源，以进行跨站脚本等攻击。因此，开发人员应该验证所有 URL，然后才能将其传递给此函数。 </p>
     	
     <p>良好的 URL 数据验证蕴含着许多不同的技术，具体取决于 URL 在整个应用程序中的用法。最常用的数据验证技术包括了验证 URL 的方案是否适当。例如，无意中允许 javascript: URL 可能会导致跨站脚本攻击。验证 URL 位于您的域内可以确保进行仿冒攻击的人无法使用 SWF 文件作为 open 请求的重定向器。如要增强安全性，还可以验证 URL 的路径，并验证 URL 符合 RFC 指导原则</p>
     
     <p platform="actionscript">例如，以下代码展示了一个执行数据验证的简单示例，其中拒绝不以 http:// 或 https:// 开头的任何 URL，并验证 URL 在您的域名范围内。此例可能并不适用于所有 Web 应用程序，因此您应该考虑是否需要针对 URL 进行其它检查。 </p>
	 
     	<codeblock platform="actionscript">
     // AS3 Regular expression pattern match for URLs that start with http:// and https:// plus your domain name.
     function checkProtocol (flashVarURL:String):Boolean {
        // Get the domain name for the SWF if it is not known at compile time.
        // If the domain is known at compile time, then the following two lines can be replaced with a hard coded string.
        var my_lc:LocalConnection = new LocalConnection();
        var domainName:String = my_lc.domain;
        // Build the RegEx to test the URL.
        // This RegEx assumes that there is at least one "/" after the
        // domain. http://www.mysite.com will not match.
        var pattern:RegExp = new RegExp("^http[s]?\:\\/\\/([^\\/]+)\\/");
        var result:Object = pattern.exec(flashVarURL);
        if (result == null || result[1] != domainName || flashVarURL.length >= 4096) {
          return (false);
        }
        return (true);
     }  
     
     	</codeblock>
	 <p platform="actionscript">对于在浏览器中运行的<i>本地</i> 内容，只有在 SWF 文件和包含该文件的 Web 页（如果有）位于受信任的本地安全沙箱时，才允许调用指定 <codeph>"javascript:"</codeph> 伪协议（通过作为第一个参数传递的 <codeph>URLRequest</codeph> 对象）的 <codeph>navigateToURL()</codeph> 方法。一些浏览器不支持通过 <codeph>navigateToURL()</codeph> 方法使用 javascript 协议。而应考虑使用 <codeph>ExternalInterface</codeph> API 的 <codeph>call()</codeph> 方法在包含该内容的 HTML 页中调用 JavaScript 方法。</p>
     
      <p platform="actionscript">在 Flash Player 和 Adobe AIR 中的非应用程序沙箱中，您无法连接常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。</p>
     
     <p platform="actionscript">在浏览器中运行的 Flash Player 10 和更高版本中，以编程方式使用此方法打开弹出窗口可能不会成功。不同的浏览器（和浏览器配置）可能会随时阻止弹出窗口；不能保证可以显示任何弹出窗口。不过，为了尽可能成功，请仅在作为用户操作的直接结果执行的代码中使用此方法打开弹出窗口，例如，在鼠标单击或按键事件的事件处理函数中。</p>
     
     <p platform="actionscript"> 在 Flash Player 10 和更高版本中，如果使用包含上载（由 POST 体内的“content-disposition”标头中的“filename”参数表示）的 multipart Content-Type（例如“multipart/form-data”），则 POST 操作会受应用于上载的安全规则的约束：</p>
	 <ul platform="actionscript">
	 <li>必须执行 POST 操作以响应用户启动的操作（如鼠标单击或按键）。</li>
	 <li>如果 POST 操作是跨域的（POST 目标与发送 POST 请求的 SWF 文件不在同一台服务器上），则目标服务器必须提供一个允许跨域访问的 URL 策略文件。</li>
	 </ul>
     <p platform="actionscript">另外，对于任何 multipart Content-Type，语法必须有效（根据 RFC2046 标准）。如果语法无效，则 POST 操作受应用于上载的安全规则约束。</p>
     
     <p platform="actionscript">有关安全性的详细信息，请参阅以下部分：</p>
     
     <ul platform="actionscript">
     
     <li product="flex">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     <li product="flash">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
       <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
     
     </ul>
     
     </apiDesc><example conref="examples\NavigateToURLExample.as"> 下例在一个新的浏览器窗口中打开 URL http://www.adobe.com，并将在 URLVariables 对象中所捕获的用户会话数据传递给 Web 服务器。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class NavigateToURLExample extends Sprite {

        public function NavigateToURLExample() {
            var url:String = "http://www.adobe.com";
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "Your Name";
            var request:URLRequest = new URLRequest(url);
            request.data = variables;
            try {            
                navigateToURL(request);
            }
            catch (e:Error) {
                // handle error here
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.external.xml#ExternalInterface/call()"><linktext>flash.external.ExternalInterface.call()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:registerClassAlias"><apiName>registerClassAlias</apiName><shortdesc>
     当以 Action Message Format (AMF) 对一个对象进行编码时，保留该对象的类（类型）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果任一个参数为 <codeph>null</codeph>。
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>aliasName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要使用的别名。
     </apiDesc></apiParam><apiParam><apiItemName>classObject</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiDesc>与给定别名相关联的类。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     当以 Action Message Format (AMF) 对一个对象进行编码时，保留该对象的类（类型）。将对象编码为 AMF 时，该函数将保存该对象的类的别名，以便在解码对象时可以恢复该类。如果编码上下文没有为对象的类注册别名，该对象将被编码为一个匿名对象。同样，如果解码上下文注册了不同的别名，将为解码后的数据创建一个匿名对象。
     
     <p>LocalConnection、ByteArray、SharedObject、NetConnection 及 NetStream 均为将对象编码为 AMF 的类的示例。</p>
     
     <p>编码和解码上下文不必对别名使用相同的类。它们可以主动地改变类，条件是目标类包含源类序列化的所有成员。</p>
     
     </apiDesc><example conref="examples\RegisterClassAliasExample.as"> 此示例使用 <codeph>registerClassAlias()</codeph> 函数为 ExampleClass 注册一个别名 ( <codeph>com.example.eg</codeph> )。由于为类注册了别名，因此可以将对象作为 ExampleClass 的实例反序列化，且代码将输出 <codeph>true</codeph>。如果删除 <codeph>registerClassAlias()</codeph> 调用，则代码将输出 <codeph>false</codeph>。 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.registerClassAlias;
    import flash.utils.ByteArray;

    public class RegisterClassAliasExample extends Sprite {
        public function RegisterClassAliasExample() {
            registerClassAlias("com.example.eg", ExampleClass);
            var eg1:ExampleClass = new ExampleClass();
            var ba:ByteArray = new ByteArray();
            ba.writeObject(eg1);
            ba.position = 0;
            var eg2:* = ba.readObject();
            trace(eg2 is ExampleClass); // true
        }
    }
}

class ExampleClass {}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding 类</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:sendToURL"><apiName>sendToURL</apiName><shortdesc>
     向服务器发送一个 URL 请求，但忽略任何响应。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError The "digest" and "importToSandbox" properties of URLRequest
         are not supported by URLLoader.send.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>本地不受信任的 SWF 文件无法与 Internet 通信。要避免这种情况，可将此 SWF 文件重新分类为只能与远程内容交互或受信任。
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>URLRequest 对象，指定要将数据发送到哪个 URL。
         </apiDesc></apiParam></apiOperationDef><apiDesc>
     向服务器发送一个 URL 请求，但忽略任何响应。
     <p>要检查服务器响应，请改为使用 <codeph>URLLoader.load()</codeph> 方法。</p>
     
      <p>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。</p>
     
     <p>可以在包含 SWF 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数，防止 SWF 文件使用此方法。</p>
	 
     <p> 在 Flash Player 10 和更高版本中，如果使用包含上载（由 POST 体内的“content-disposition”标头中的“filename”参数表示）的 multipart Content-Type（例如“multipart/form-data”），则 POST 操作会受应用于上载的安全规则的约束：</p>
	 <ul>
	 <li>必须执行 POST 操作以响应用户启动的操作（如鼠标单击或按键）。</li>
	 <li>如果 POST 操作是跨域的（POST 目标与发送 POST 请求的 SWF 文件不在同一台服务器上），则目标服务器必须提供一个允许跨域访问的 URL 策略文件。</li>
	 </ul>
     <p>另外，对于任何 multipart Content-Type，语法必须有效（根据 RFC2046 标准）。如果语法无效，则 POST 操作受应用于上载的安全规则约束。</p>
     
     <p>有关安全性的详细信息，请参阅以下部分：</p>
     
     <ul>
     
     <li product="flex">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     <li product="flash">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
       <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
     
     </ul>
         
         </apiDesc><example conref="examples\SendToURLExample.as"> 下面的示例将在 URLVariables 对象中捕获的用户会话数据传递到位于 http://www.yourDomain.com/application.jsp 的应用程序。
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.net.URLVariables;
    import flash.net.sendToURL;

    public class SendToURLExample extends Sprite {

        public function SendToURLExample() {
            var url:String = "http://www.yourDomain.com/application.jsp";
            var variables:URLVariables = new URLVariables();
            variables.sessionId = new Date().getTime();
            variables.userLabel = "Your Name";

            var request:URLRequest = new URLRequest(url);
            request.data = variables;
            trace("sendToURL: " + request.url + "?" + request.data);
            try {
                sendToURL(request);
            }
            catch (e:Error) {
                // handle error here
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiClassifier id="flash.net:Responder"><apiName>Responder</apiName><shortdesc>
 Responder 类提供了一个对象，该对象在 NetConnection.call() 中使用以处理来自与特定操作成功或失败相关的服务器的返回值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Responder 类提供了一个对象，该对象在 <codeph>NetConnection.call()</codeph> 中使用以处理来自与特定操作成功或失败相关的服务器的返回值。在使用 <codeph>NetConnection.call()</codeph> 时，您可能会遇到特定于当前操作的网络操作错误或与当前连接状态有关的错误。操作错误以 Responder 对象（而不是 NetConnection 对象）为目标，便于进行错误处理。
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#NetConnection/call()"><linktext>NetConnection.call()</linktext></link></related-links><apiConstructor id="flash.net:Responder:Responder"><apiName>Responder</apiName><shortdesc>
	 创建一个新的 Responder 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>result</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>如果对服务器的调用成功并返回结果，则此函数被调用。
	 </apiDesc></apiParam><apiParam><apiItemName>status</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiData>null</apiData><apiDesc>如果服务器返回一个错误，则此函数被调用。
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 Responder 对象。可以将 Responder 对象传递给 <codeph>NetConnection.call()</codeph>，以处理来自服务器的返回值。可以为两个参数之一或两个参数都传递 <codeph>null</codeph>。
	 
	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="flash.net:URLRequestHeader"><apiName>URLRequestHeader</apiName><shortdesc>
 URLRequestHeader 对象封装了一个 HTTP 请求标头并由一个名称/值对组成。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 URLRequestHeader 对象封装了一个 HTTP 请求标头并由一个名称/值对组成。URLRequestHeader 对象在 URLRequest 类的 <codeph>requestHeaders</codeph> 属性中使用。
 
 <p>在 Adobe<sup>®</sup> AIR 中，应用程序安全沙箱中的内容（如使用 AIR 应用程序安装的内容）可以使用任何请求标头而不会出错。不过，对于在 Adobe AIR 中运行的不同安全沙箱中的内容，<ph outputclass="actionscript">或对于在 Flash<sup>®</sup> Player 中运行的内容，</ph>使用以下请求标头将会引发运行时错误，且限制的术语不区分大小写（例如，<codeph>Get</codeph>、<codeph>get</codeph> 和 <codeph>GET</codeph> 均不得使用）： </p>
 
 <p>在应用程序安全沙箱以外的 Flash Player 和 Adobe AIR 内容中，不能使用以下请求标头，且限制的术语不区分大小写（例如，<codeph>Get</codeph>、<codeph>get</codeph> 和 <codeph>GET</codeph> 均不得使用）。另外，如果使用下划线字符，这也适用于带连字符的词（例如，不允许使用 <codeph>Content-Length</codeph> 和 <codeph>Content_Length</codeph>）： </p>
 
 <p><codeph>Accept-Charset</codeph>、<codeph>Accept-Encoding</codeph>、<codeph>Accept-Ranges</codeph>、<codeph>Age</codeph>、<codeph>Allow</codeph>、<codeph>Allowed</codeph>、<codeph>Authorization</codeph>、<codeph>Charge-To</codeph>、<codeph>Connect</codeph>、<codeph>Connection</codeph>、<codeph>Content-Length</codeph>、<codeph>Content-Location</codeph>、<codeph>Content-Range</codeph>、<codeph>Cookie</codeph>、<codeph>Date</codeph>、<codeph>Delete</codeph>、<codeph>ETag</codeph>、<codeph>Expect</codeph>、<codeph>Get</codeph>、<codeph>Head</codeph>、<codeph>Host</codeph>、<codeph>Keep-Alive</codeph>、<codeph>Last-Modified</codeph>、<codeph>Location</codeph>、<codeph>Max-Forwards</codeph>、<codeph>Options</codeph>、<codeph>Origin</codeph>、<codeph>Post</codeph>、<codeph>Proxy-Authenticate</codeph>、<codeph>Proxy-Authorization</codeph>、<codeph>Proxy-Connection</codeph>、<codeph>Public</codeph>、<codeph>Put</codeph>、<codeph>Range</codeph>、<codeph>Referer</codeph>、<codeph>Request-Range</codeph>、<codeph>Retry-After</codeph>、<codeph>Server</codeph>、<codeph>TE</codeph>、<codeph>Trace</codeph>、<codeph>Trailer</codeph>、<codeph>Transfer-Encoding</codeph>、<codeph>Upgrade</codeph>、<codeph>URI</codeph>、<codeph>User-Agent</codeph>、<codeph>Vary</codeph>、<codeph>Via</codeph>、<codeph>Warning</codeph>、<codeph>WWW-Authenticate</codeph> 和 <codeph>x-flash-version</codeph>。</p>
 
 <p>URLRequestHeader 对象的长度是受限制的。如果 URLRequestHeader 对象的累计长度（<codeph>name</codeph> 属性的长度加 <codeph>value</codeph> 属性的长度）或 <codeph>URLRequest.requestHeaders</codeph> 属性中使用的 URLRequestHeader 对象数组超过可接受的长度，则应用程序将引发异常。</p>
 
 <p>除非为 URLRequest 类的 <codeph>requestHeaders</codeph> 属性中的 <codeph>ACCEPT</codeph> 标头指定设置，否则，在 Adobe AIR 中运行的内容会将 <codeph>ACCEPT</codeph> 标头设置为以下值：</p>
 
 <codeph>text/xml, application/xml, application/xhtml+xml, text/html;q=0.9, text/plain;q=0.8, image/png, application/x-shockwave-flash, video/mp4;q=0.9, flv-application/octet-stream;q=0.8, video/x-flv;q=0.7, audio/mp4, ~~/~~;q=0.5</codeph>
 <p>并非所有接受 URLRequest 参数的方法都支持 <codeph>requestHeaders</codeph> 属性，请参阅有关调用的方法的文档。例如，<codeph>FileReference.upload()</codeph> 和 <codeph>FileReference.download()</codeph> 方法不支持 <codeph>URLRequest.requestHeaders</codeph> 属性。</p>
 <p>由于存在浏览器限制，因此仅对 <codeph>POST</codeph> 请求支持自定义 HTTP 请求标头，而对 <codeph>GET</codeph> 请求不提供相应支持。</p>  
 
 </apiDesc><example conref="examples\URLRequestHeaderExample.as"> 下例将 HTTP 请求标头 <codeph>header</codeph> 添加到 <codeph>requestHeaders</codeph> 属性的数组中。该标头指出，即使应用程序具有所请求内容的缓存副本，也应当将请求转发给原始服务器。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.net.URLRequestHeader;
    import flash.net.URLRequestMethod;
    import flash.net.URLVariables;

    public class URLRequestHeaderExample extends Sprite {
        public function URLRequestHeaderExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var header:URLRequestHeader = new URLRequestHeader("pragma", "no-cache");
            var request:URLRequest = new URLRequest("http://www.[yourdomain].com/greeting.cfm");
            request.data = new URLVariables("name=John+Doe");
            request.method = URLRequestMethod.POST;
            request.requestHeaders.push(header);
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLRequestHeader:URLRequestHeader"><apiName>URLRequestHeader</apiName><shortdesc>
	 创建一个封装单个 HTTP 请求标头的新 URLRequestHeader 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>HTTP 请求标头名称（如 <codeph>Content-Type</codeph> 或 <codeph>SOAPAction</codeph>）。
	 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>与 <codeph>name</codeph> 属性相关联的值（如 <codeph>text/plain</codeph>）。
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个封装单个 HTTP 请求标头的新 URLRequestHeader 对象。URLRequestHeader 对象在 URLRequest 类的 <codeph>requestHeaders</codeph> 属性中使用。
     
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.net:URLRequestHeader:name"><apiName>name</apiName><shortdesc>
	 HTTP 请求标头名称（例如 Content-Type 或 SOAPAction）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 HTTP 请求标头名称（如 <codeph>Content-Type</codeph> 或 <codeph>SOAPAction</codeph>）。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestHeader:value"><apiName>value</apiName><shortdesc>
	 与 name 属性相关联的值（如 text/plain）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 与 <codeph>name</codeph> 属性相关联的值（如 <codeph>text/plain</codeph>）。
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLRequestMethod"><apiName>URLRequestMethod</apiName><shortdesc>
 URLRequestMethod 类提供了一些值，这些值可指定在将数据发送到服务器时，URLRequest 对象应使用 POST 方法还是 GET 方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 URLRequestMethod 类提供了一些值，这些值可指定在将数据发送到服务器时，URLRequest 对象应使用 <codeph>POST</codeph> 方法还是 <codeph>GET</codeph> 方法。
 
 </apiDesc><example conref="examples\URLRequestMethodExample.as"> 下例加载并显示在本地文本文件中找到的数据。它还会跟踪事件处理信息。
 
 <p><b>注意：</b>要运行此示例，请将名为 example.txt 的文件与 SWF 文件放在同一目录下。该文件应当是一个包含几个词或几行文字的简单文本文件。
 </p>
 <p>该示例代码执行以下操作：</p>
 <ol>
    <li>构造函数创建了一个名为 <codeph>loader</codeph>。</li>
    <li><codeph>loader</codeph> 对象被传递给 <codeph>configureListeners()</codeph> 方法，该方法可为每个受支持的 URLLoader 事件添加侦听器。</li>
  <li>创建了一个名为 <codeph>request</codeph> 的 URLRequest 实例，这指定了要加载文件的名称。</li>
  <li>请求的 <codeph>method</codeph> 属性设置为 <codeph>URLRequestMethod.POST</codeph>。</li>
    <li>然后，<codeph>request</codeph> 对象被传递给 <codeph>loader.load()</codeph>，该方法可加载文本文件。</li>
  <li>当 URLLoader 完成文本文件的加载时，将引发 <codeph>Event.COMPLETE</codeph> 事件，同时触发 <codeph>completeHandler()</codeph> 方法。<codeph>completeHandler()</codeph> 方法只跟踪 <codeph>data</codeph> 属性，即文本文件的内容。</li>
 </ol>
<codeblock>


package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLRequestMethodExample extends Sprite {

        public function URLRequestMethodExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("example.txt");
            
            request.method = URLRequestMethod.POST;
            loader.load(request);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link></related-links><apiValue id="flash.net:URLRequestMethod:DELETE"><apiName>DELETE</apiName><shortdesc>
	 指定 URLRequest 对象为 DELETE。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>DELETE</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指定 URLRequest 对象为 <codeph>DELETE</codeph>。
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:GET"><apiName>GET</apiName><shortdesc>
	 指定 URLRequest 对象为 GET。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>GET</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指示 URLRequest 对象是一个 <codeph>GET</codeph>。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:HEAD"><apiName>HEAD</apiName><shortdesc>
	 指定 URLRequest 对象为 HEAD。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>HEAD</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指定 URLRequest 对象为 <codeph>HEAD</codeph>。
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:OPTIONS"><apiName>OPTIONS</apiName><shortdesc>
	 指定 URLRequest 对象为 OPTIONS。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>OPTIONS</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指定 URLRequest 对象为 <codeph>OPTIONS</codeph>。
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:POST"><apiName>POST</apiName><shortdesc>
	 指定 URLRequest 对象为 POST。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>POST</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指示 URLRequest 对象是一个 <codeph>POST</codeph>。
	 
	 <p><i>注意：</i><ph platform="actionscript">对于在 Adobe AIR 中运行的内容，</ph><ph platform="javascript">当</ph>使用 <codeph>navigateToURL()</codeph> 函数时，运行时将使用 POST 方法的 URLRequest（其 <codeph>method</codeph> 属性设置为 <codeph>URLRequestMethod.POST</codeph>）视为使用 GET 方法。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:PUT"><apiName>PUT</apiName><shortdesc>
	 指定 URLRequest 对象为 PUT。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>PUT</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指定 URLRequest 对象为 <codeph>PUT</codeph>。
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:FileReferenceList"><apiName>FileReferenceList</apiName><shortdesc>
 FileReferenceList 类提供了让用户选择一个或多个要上载的文件的方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>FileReferenceList
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>提供上载一个或多个文件的方法。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 FileReferenceList 类提供了让用户选择一个或多个要上载的文件的方法。FileReferenceList 对象将用户磁盘上的一组本地文件（一个或多个文件）表示为 FileReference 对象的数组。有关详细信息以及有关 FileReference 对象和 FileReference 类（可与 FileReferenceList 一起使用）的重要注意事项，请参阅 FileReference 类。
 
 <p>使用 FileReferenceList 类：</p>
 <ul>
 <li>将该类实例化：<codeph>var myFileRef = new FileReferenceList();</codeph></li>
 <li>调用 <codeph>FileReferenceList.browse()</codeph> 方法，该方法将打开一个对话框，让用户选择一个或多个要上载的文件：<codeph>myFileRef.browse();</codeph></li>
 <li>在成功调用 <codeph>browse()</codeph> 方法之后，使用 FileReference 对象数组来填充 FileReferenceList 对象的 <codeph>fileList</codeph> 属性。</li>
 <li>对 <codeph>fileList</codeph> 数组中的每个元素调用 <codeph>FileReference.upload()</codeph>。</li>
 </ul>
 
 <p>FileReferenceList 类包括 <codeph>browse()</codeph> 方法以及用于处理多个文件的 <codeph>fileList</codeph> 属性。调用 <codeph>FileReferenceList.browse()</codeph> 的过程中，对于 Linux 和 Mac OS X 10.1 及早期版本，将暂停 Flash Player 的独立和外部版本中以及 AIR 中的 SWF 文件播放。</p>
 
 </apiDesc><example conref="examples\FileReferenceListExample.as"> 下例说明如何使用事件来管理多个文件的上载。CustomFileReferenceList 类扩展了 FileReferenceList，它包含一个 <codeph>complete</codeph> 事件，在上载 FileReferenceList 对象中的各个文件时将分派该事件。FileReferenceList 对象中的所有文件上载完毕后，将分派 FileReferenceListExample 类中的 <codeph>LIST_COMPLETE</codeph> 事件。
 
 <p>要运行该示例，请插入一个编写好以接受 http://www.[yourDomain].com/yourUploadHandlerScript.cfm 处的文件上载的脚本。根据 SWF 文件的位置及文件的上载位置，您可能还需要编译 SWF 文件，将“本地回放安全性”设置为“只访问网络”，或更新 Flash <sup>®</sup> Player 的安全设置，以允许此文件网络访问。如果上载服务器为远程服务器，并且要从桌面计算机运行此示例，则服务器必须具有 crossdomain.xml 文件。</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.FileReferenceList;
 
    public class FileReferenceListExample extends Sprite {
        public static var LIST_COMPLETE:String = "listComplete";
        public function FileReferenceListExample() {
            initiateFileUpload();
        }

        private function initiateFileUpload():void {
            var fileRef:CustomFileReferenceList = new CustomFileReferenceList();
            fileRef.addEventListener(FileReferenceListExample.LIST_COMPLETE, listCompleteHandler);
            fileRef.browse(fileRef.getTypes());
        }

        private function listCompleteHandler(event:Event):void {
            trace("listCompleteHandler");
        }
    }
}
 
import flash.events.*;
import flash.net.FileReference;
import flash.net.FileReferenceList;
import flash.net.FileFilter;
import flash.net.URLRequest;
 
class CustomFileReferenceList extends FileReferenceList {
    private var uploadURL:URLRequest;
    private var pendingFiles:Array;

    public function CustomFileReferenceList() {
        uploadURL = new URLRequest();
        uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
        initializeListListeners();
    }

    private function initializeListListeners():void {
        addEventListener(Event.SELECT, selectHandler);
        addEventListener(Event.CANCEL, cancelHandler);
    }

    public function getTypes():Array {
        var allTypes:Array = new Array();
        allTypes.push(getImageTypeFilter());
        allTypes.push(getTextTypeFilter());
        return allTypes;
    }
 
    private function getImageTypeFilter():FileFilter {
        return new FileFilter("Images (*.jpg, *.jpeg, *.gif, *.png)", "*.jpg;*.jpeg;*.gif;*.png");
    }
 
    private function getTextTypeFilter():FileFilter {
        return new FileFilter("Text Files (*.txt, *.rtf)", "*.txt;*.rtf");
    }
 
    private function doOnComplete():void {
        var event:Event = new Event(FileReferenceListExample.LIST_COMPLETE);
        dispatchEvent(event);
    }
 
    private function addPendingFile(file:FileReference):void {
        trace("addPendingFile: name=" + file.name);
        pendingFiles.push(file);
        file.addEventListener(Event.OPEN, openHandler);
        file.addEventListener(Event.COMPLETE, completeHandler);
        file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
        file.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        file.upload(uploadURL);
    }
 
    private function removePendingFile(file:FileReference):void {
        for (var i:uint; i &lt; pendingFiles.length; i++) {
            if (pendingFiles[i].name == file.name) {
                pendingFiles.splice(i, 1);
                if (pendingFiles.length == 0) {
                    doOnComplete();
                }
                return;
            }
        }
    }
 
    private function selectHandler(event:Event):void {
        trace("selectHandler: " + fileList.length + " files");
        pendingFiles = new Array();
        var file:FileReference;
        for (var i:uint = 0; i &lt; fileList.length; i++) {
            file = FileReference(fileList[i]);
            addPendingFile(file);
        }
    }
 
    private function cancelHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("cancelHandler: name=" + file.name);
    }
 
    private function openHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("openHandler: name=" + file.name);
    }
 
    private function progressHandler(event:ProgressEvent):void {
        var file:FileReference = FileReference(event.target);
        trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
    }
 
    private function completeHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("completeHandler: name=" + file.name);
        removePendingFile(file);
    }
 
    private function httpErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("httpErrorHandler: name=" + file.name);
    }
 
    private function ioErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("ioErrorHandler: name=" + file.name);
    }
 
    private function securityErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("securityErrorHandler: name=" + file.name + " event=" + event.toString());
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link></related-links><adobeApiEvent id="flash.net:FileReferenceList_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
 当用户从文件浏览对话框选择一个或多个要上载的文件时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates the usage of the <code>select</code> event.
 <listing version="2.0">
 import flash.net.FileReferenceList;
 import flash.net.FileReference;
 
 var listener:Object = new Object();
 
 listener.onSelect = function(fileRefList:FileReferenceList) {
 	trace("onSelect");
 	var list:Array = fileRefList.fileList;
 	var item:FileReference;
 	for(var i:Number = 0; i &lt; list.length; i++) {
 		item = list[i];
 		trace("name: " + item.name);
 		trace(item.addListener(this));
 		item.upload("http://www.yourdomain.com/");
 	}
 }
 
 listener.onComplete = function(file:FileReference):void {
 	trace("onComplete: " + file.name);
 }
 
 var fileRef:FileReferenceList = new FileReferenceList();
 fileRef.addListener(listener);
 fileRef.browse();
 </listing>
 </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户从文件浏览对话框选择一个或多个要上载的文件时分派。（当调用 <codeph>FileReferenceList.browse()</codeph>、<codeph>FileReference.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法时显示此对话框。） 当用户选择文件并确认该操作（例如，通过单击“保存”）时，会使用表示用户选择的文件的 FileReference 对象填充 <codeph>FileReferenceList</codeph> 对象。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReferenceList_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 当用户退出文件浏览对话框时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户退出文件浏览对话框时分派。（当调用 <codeph>FileReferenceList.browse()</codeph>、<codeph>FileReference.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法时显示此对话框。）
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:FileReferenceList:FileReferenceList"><apiName>FileReferenceList</apiName><shortdesc>
 	 创建新的 FileReferenceList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new <code>FileReferenceList</code> object,
	 iterates over each selected file, and outputs their names.
	 <listing version="2.0">
	 import flash.net.FileReferenceList;
	 
	 var listener:Object = new Object();
	 listener.onSelect = function(fileRefList:FileReferenceList) {
	 	trace("onSelect");
	 	var arr:Array = fileRefList.fileList;
	 	for(var i:Number = 0; i &lt; arr.length; i++) {
	 		trace("name: " + arr[i].name);
	 	}
	 }
	 
	 var fileRef:FileReferenceList = new FileReferenceList();
	 fileRef.addListener(listener);
	 fileRef.browse();
	 </listing>
  	 
  	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 	 创建新的 FileReferenceList 对象。在对 FileReferenceList 对象调用 <codeph>browse()</codeph> 方法且用户选择一个或多个文件之前，该对象不包含任何内容。当对 FileReference 对象调用 <codeph>browse()</codeph> 时，该对象的 <codeph>fileList</codeph> 属性用 <codeph>FileReference</codeph> 对象数组来填充。
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:FileReferenceList:browse"><apiName>browse</apiName><shortdesc>
	 显示文件浏览对话框，让用户选择一个或多个要上载的本地文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample><pre>
	 // ask the user to choose an image file for upload
	 var fileRef = new FileReference();
	 if (fileRef.browse(["Images", "jpg;gif;png", "Flash Movies", "swf"])) {
	   trace("Opened " + fileRef.name);
	 } else {
	   trace("User canceled");
	 }
	 </pre>
	 
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在以下情况下引发：1) 另一个 FileReference 或 FileReferenceList 浏览会话正在进行中；每次仅能执行一个文件浏览会话。2) 用户 mms.cfg 文件中的某个设置禁止此操作。 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>如果 <codeph>typeFilter</codeph> 数组包含格式不正确的 FileFilter 对象，将引发异常。有关过滤器正确格式化的详细信息，请参阅 FileFilter 文档。
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>为了响应用户动作（如鼠标事件或按键事件），将不会调用此方法。
     
	  
	  </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>如果参数有效并且打开了文件浏览对话框，则返回 <codeph>true</codeph>。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 FileFilter 实例数组，用于过滤在对话框中显示的文件。如果省略此参数，则显示所有文件。有关详细信息，请参阅 <xref href="FileFilter.html">FileFilter</xref> 类。 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>显示一个文件浏览对话框，让用户选择要上载的本地文件。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 显示文件浏览对话框，让用户选择一个或多个要上载的本地文件。该对话框对于用户的操作系统来说是本机的。
	 
	 <p platform="actionscript">在 Flash Player 10 和更高版本中，只有响应用户事件（例如，在鼠标单击或按键事件的事件处理函数中）才能成功调用此方法。否则，调用此方法将导致 Flash Player 引发错误。</p>
	 
	 <p>当调用此方法并且用户成功选择文件时，此 FileReferenceList 对象的 <codeph>fileList</codeph> 属性用 FileReference 对象数组来填充，数组中的每个对象表示一个用户选择的文件。以后每次调用 FileReferenceList.browse() 方法时，<codeph>FileReferenceList.fileList</codeph> 属性都重置为用户在对话框中选择的文件。</p>
	 
	 <p>使用 <codeph>typeFilter</codeph> 参数，可决定对话框显示哪些文件。</p>
	 
	 <p>每次只能对 FileReferenceList 对象执行一个 <codeph>FileReference.browse()</codeph>、<codeph>FileReference.download()</codeph> 或 <codeph>FileReferenceList.browse()</codeph> 会话（因为每次只能打开一个对话框）。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference"><linktext>FileReference 类</linktext></link><link href="flash.net.xml#FileFilter"><linktext>FileFilter 类</linktext></link></related-links><adobeApiEvent id="flash.net:FileReferenceList:browse_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当用户从对话框中成功选择了要上载的项时进行调用。
	 </apiDesc></adobeApiEventDetail><shortdesc>当用户从对话框中成功选择了要上载的项时进行调用。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReferenceList:browse_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在用户通过单击“取消”或关闭对话框来取消对话框时调用。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在用户通过单击“取消”或关闭对话框来取消对话框时调用。</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:FileReferenceList:fileList:get"><apiName>fileList</apiName><shortdesc>
	 一个 FileReference 对象数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example demonstrates the <code>fileList</code> property.
	 <listing version="2.0">
	 import flash.net.FileReferenceList;
	 import flash.net.FileReference;
	 
	 var listener:Object = new Object();
	 listener.onSelect = function(fileRefList:FileReferenceList) {
	 	trace("onSelect");
	 	var list:Array = fileRefList.fileList;
	 	var item:FileReference;
	 	for(var i:Number = 0; i &lt; list.length; i++) {
	 		item = list[i];
	 		trace("name: " + item.name);
	 	}
	 }
	 
	 var fileRef:FileReferenceList = new FileReferenceList();
	 fileRef.addListener(listener);
	 fileRef.browse();
	 </listing>
	 
	  
	  </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiTipTexts><apiTipText>一个 FileReference 对象数组。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 一个 <codeph>FileReference</codeph> 对象数组。
	 
	 <p>当调用了 <codeph>FileReferenceList.browse()</codeph> 方法并且用户已从 <codeph>browse()</codeph> 方法打开的对话框中选择了一个或多个文件后，此属性用 FileReference 对象数组来填充，数组中的每个对象表示一个用户选择的文件。然后，您可以通过 <codeph>FileReference.upload()</codeph> 方法使用此数组上载每个文件。必须一次上载一个文件。</p>
	 
	 <p>每次对该 FileReferenceList 对象调用 browse() 时都要重新填充 <codeph>fileList</codeph> 属性。</p>
	 
	 <p><codeph>FileReference</codeph> 对象的属性在 FileReference 类文档中介绍。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:FileReference"><apiName>FileReference</apiName><shortdesc>
  FileReference 类提供了在用户计算机和服务器之间上载和下载文件的方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>FileReference, FileReference.browse, FileReference.download, FileReference.create, browse, download, create
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  FileReference 类提供了在用户计算机和服务器之间上载和下载文件的方法。操作系统对话框会提示用户选择要上载的文件或用于下载的位置。每个 FileReference 对象都引用用户磁盘上的一个文件并且具有一些属性，这些属性包含有关文件大小、类型、名称、创建日期、修改日期和创建者类型（仅限 Macintosh）的信息。 
  
  <p><b>注意：</b>在 Adobe AIR 中，File 类（用于扩展 FileReference 类）提供了更多的功能，并具有比 FileReference 类更少的安全性限制。</p>
  
  <p>FileReference 实例的创建方式如下：</p>
  <ul>
  <li>当将 <codeph>new</codeph> 运算符与 FileReference 构造函数一起使用时：<codeph>var myFileReference = new FileReference();</codeph></li>
  
  <li>当调用 <codeph>FileReferenceList.browse()</codeph> 方法时，该方法将创建一个 FileReference 对象数组。</li>
  </ul>
  
  <p>在上载操作期间，FileReference 对象的所有属性通过调用 <codeph>FileReference.browse()</codeph> 或 <codeph>FileReferenceList.browse()</codeph> 方法来填充。在下载操作期间，<codeph>name</codeph> 属性在分派 <codeph>select</codeph> 事件时得到填充，所有其它属性在分派 <codeph>complete</codeph> 事件时得到填充。</p>
  
  <p><codeph>browse()</codeph> 方法打开一个操作系统对话框，提示用户选择要上载的文件。<codeph>FileReference.browse()</codeph> 方法允许用户选择一个文件；<codeph>FileReferenceList.browse()</codeph> 方法允许用户选择多个文件。成功调用 <codeph>browse()</codeph> 方法后，调用 <codeph>FileReference.upload()</codeph> 方法以每次上载一个文件。<codeph>FileReference.download()</codeph> 方法提示用户提供文件的保存位置并开始从远程 URL 进行下载。</p>
  
  <p>FileReference 类和 FileReferenceList 类不允许为 <codeph>browse()</codeph> 或 <codeph>download()</codeph> 生成的对话框设置默认文件位置。对话框中显示的默认位置是最近浏览过的文件夹（如果可以确定该位置）或桌面。这些类不允许对已传输的文件进行读取或写入。它们也不允许启动上载或下载的 SWF 文件访问已上载或下载的文件或用户磁盘上文件的位置。</p>
  
  <p>FileReference 类和 FileReferenceList 类也不提供用于身份验证的方法。通过要求身份验证的服务器，您可以使用 Flash <sup>®</sup> Player 浏览器插件下载文件，但上载（在所有播放器上）和下载（在独立播放器或外部播放器上）将失败。对 FileReference 事件进行侦听可确定操作是否成功完成，并进行错误处理。</p>
  
  <p>对于<ph platform="actionscript">在 Flash Player 中运行的内容或</ph>在 Adobe AIR 中的应用程序安全沙箱以外的区域运行的内容，上载和下载操作只能访问所在域和 URL 策略文件指定的任何域中的文件。如果启动上载或下载的内容与文件服务器不在相同的域中，则需要将策略文件放到文件服务器上。</p>
  
  <p>请注意，由于已向 Flash Player 中添加了新功能，因此当发布到 Flash Player 10 时，一次只可以激活下列操作中的一个操作：<codeph>FileReference.browse()</codeph>、<codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph>、<codeph>FileReference.load()</codeph>、<codeph>FileReference.save()</codeph>。否则，Flash Player 会引发运行时错误（代码 2174）。使用 <codeph>FileReference.cancel()</codeph> 可停止正在进行的操作。此限制仅适用于 Flash Player 10。早期版本的 Flash Player 在同时进行多个操作时不会受到此限制的影响。</p>
  
  <p platform="actionscript">调用 <codeph>FileReference.browse()</codeph>、<codeph>FileReferenceList.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法的过程中，对于 Linux 和 Mac OS X 10.1 及早期版本，将暂停 Flash Player 的独立和外部版本中以及 AIR 中的 SWF 文件播放</p>
  
  <p platform="actionscript">如果未指定任何参数，则 Flash Player 会向服务器端脚本发送以下范例 HTTP <codeph>POST</codeph> 请求：
  </p>
  
  <pre platform="actionscript">
  POST /handler.cfm HTTP/1.1 
  Accept: text/~~
  Content-Type: multipart/form-data; 
  boundary=----------Ij5ae0ae0KM7GI3KM7 
  User-Agent: Shockwave Flash 
  Host: www.example.com 
  Content-Length: 421 
  Connection: Keep-Alive 
  Cache-Control: no-cache
  
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filename"
  
  MyFile.jpg
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
  Content-Type: application/octet-stream
  
  FileDataHere
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Upload"
  
  Submit Query
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
  </pre>
  
  <p platform="actionscript">如果用户指定参数 <codeph>"api_sig"</codeph>、<codeph>"api_key"</codeph> 和 <codeph>"auth_token"</codeph>，Flash Player 将发送以下 HTTP <codeph>POST</codeph> 请求：
  </p>
  
  <pre platform="actionscript">
  POST /handler.cfm HTTP/1.1 
  Accept: text/~~
  Content-Type: multipart/form-data; 
  boundary=----------Ij5ae0ae0KM7GI3KM7 
  User-Agent: Shockwave Flash 
  Host: www.example.com 
  Content-Length: 421 
  Connection: Keep-Alive 
  Cache-Control: no-cache
  
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filename"
  
  MyFile.jpg
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="api_sig"
  
  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="api_key"
  
  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="auth_token"
  
  XXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
  Content-Type: application/octet-stream
  
  FileDataHere
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Upload"
  
  Submit Query
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
  </pre>
  </apiDesc><example conref="examples\FileReferenceExample.as"> 下例显示在运行时加载的文件的数据格式和状态信息。  
 <p> <b>注意：</b>要运行此示例，请更改 uploadURL.url 属性以指向实际的 URL，而不是示例中虚拟的地址。URL 应指向名为 <codeph>yourUploadHandlerScript.cfm</codeph> 的文件，该文件位于指定 URL 的根 Web 目录下。根据您的配置，您可能还需要编译 SWF 文件，将“本地回放安全性”设置为“只访问网络”，或更新 Flash Player 的安全设置，以允许此文件网络访问。
 </p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileFilter;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReferenceExample extends Sprite {
        private var uploadURL:URLRequest;
        private var file:FileReference;

        public function FileReferenceExample() {
            uploadURL = new URLRequest();
            uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
            file = new FileReference();
            configureListeners(file);
            file.browse(getTypes());
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
            dispatcher.addEventListener(DataEvent.UPLOAD_COMPLETE_DATA,uploadCompleteDataHandler);
        }

        private function getTypes():Array {
            var allTypes:Array = new Array(getImageTypeFilter(), getTextTypeFilter());
            return allTypes;
        }

        private function getImageTypeFilter():FileFilter {
            return new FileFilter("Images (*.jpg, *.jpeg, *.gif, *.png)", "*.jpg;*.jpeg;*.gif;*.png");
        }

        private function getTextTypeFilter():FileFilter {
            return new FileFilter("Text Files (*.txt, *.rtf)", "*.txt;*.rtf");
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function uploadCompleteDataHandler(event:DataEvent):void {
            trace("uploadCompleteData: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + uploadURL.url);
            file.upload(uploadURL);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReferenceList"><linktext>flash.net.FileReferenceList</linktext></link><link href="flash.filesystem.xml#File"><linktext>flash.filesystem.File</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference_flash.events.DataEvent.UPLOAD_COMPLETE_DATA_uploadCompleteData"><apiName>uploadCompleteData</apiName><shortdesc>
    成功上载并从服务器接收数据之后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DataEvent.UPLOAD_COMPLETE_DATA</apiEventType><adobeApiEventClassifier>flash.events.DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
    成功上载并从服务器接收数据之后分派。如果未从服务器返回数据，则不分派此事件。
    </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
	 在 upload() 或 uploadUnencoded() 方法调用尝试通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 在 <codeph>upload()</codeph> 或 <codeph>uploadUnencoded()</codeph> 方法调用尝试通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。 
	 
	 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/upload()"><linktext>upload()</linktext></link><link href="flash.net.xml#FileReference/uploadUnencoded()"><linktext>uploadUnencoded()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
     当上载失败并且存在可用来描述失败的 HTTP 状态代码时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     当上载失败并且存在可用来描述失败的 HTTP 状态代码时分派。分派 <codeph>httpStatus</codeph> 事件之后，将分派 <codeph>ioError</codeph> 事件。
     
     <p>仅在上载失败时才分派 <codeph>httpStatus</codeph> 事件。对于在 Flash Player 中运行的内容，此事件不适用于下载失败。如果下载由于 HTTP 错误而失败，则将错误报告为 I/O 错误。</p>
     
     </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
	当用户从文件浏览对话框选择要上载或下载的文件时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
    </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	当用户从文件浏览对话框选择要上载或下载的文件时分派。（调用 <codeph>FileReference.browse()</codeph>、<codeph>FileReferenceList.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法时将打开此对话框。） 当用户选择文件并确认操作（例如，通过单击“确定”）时，会填充 FileReference 对象的属性。
    
    <p>对于在 <ph platform="actionscript">Flash Player 内运行的内容或</ph>在 <ph platform="actionscript">Adobe AIR 运行时中、但在应用程序安全沙箱以外运行的内容</ph>，<codeph>select</codeph> 事件的行为方式略有不同，具体取决于调用该事件的方法。在调用 <codeph>browse()</codeph> 后分派 <codeph>select</codeph> 事件时，<ph platform="actionscript">Flash Player 或</ph> AIR 应用程序能够读取 FileReference 对象的所有属性，因为用户所选的文件位于本地文件系统上。在调用 <codeph>download()</codeph> 后发生 <codeph>select</codeph> 事件时，<ph platform="actionscript">Flash Player 或</ph> AIR 应用程序只能读取 <codeph>name</codeph> 属性，因为在分派 <codeph>select</codeph> 事件时，文件尚未下载到本地文件系统。如果已下载了文件，则分派 <codeph>complete</codeph> 事件时，<ph platform="actionscript">Flash Player 或</ph> AIR 应用程序可以读取 FileReference 对象的所有其它属性。</p>
    
    </apiDesc><example conref="examples\FileReference_event_select.as"> 下面的示例演示 <codeph>select</codeph> 事件对象的用法。要运行此示例，请将 <codeph>uploadURL.url</codeph> 属性更改为指向一个实际的域和文件，而不是虚拟的 http://www.[yourDomain].com/SomeFile.pdf。您可能还需要编译 SWF 文件，将“本地回放安全性”设置为“只访问网络”，或更新 Flash Player 的安全设置，以允许此文件网络访问。要想可以从桌面运行这个示例，您的服务器还需要发送 crossdomain.xml 文件。如果触发了 <codeph>ioErrorHandler()</codeph> 函数，可能需要使用一个有效的 URL 来更新提供的 <codeph>uploadURL</codeph>，此有效的 URL 被配置成接收上载。
<codeblock>
 
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_select extends Sprite {
        private var uploadURL:URLRequest;
        private var file:FileReference;

        public function FileReference_event_select() {
            uploadURL = new URLRequest();
            uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
            file = new FileReference();
            file.addEventListener(Event.SELECT, selectHandler);
            file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            file.addEventListener(Event.COMPLETE, completeHandler);
            file.browse();
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + uploadURL.url);
            file.upload(uploadURL);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
     当对 FileReference.upload() 或 FileReference.download() 方法的调用尝试将文件上载到调用方安全沙箱外部的服务器，或是从调用方安全沙箱外部的服务器上下载文件时进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     当对 <codeph>FileReference.upload()</codeph> 或 <codeph>FileReference.download()</codeph> 方法的调用尝试将文件上载到服务器，或是从调用方安全沙箱外部的服务器上下载文件时进行分派。用于描述发生的特定错误的文本属性的值通常为 <codeph>"securitySandboxError"</codeph>。执行调用的 SWF 可能已经尝试访问其域外部的 SWF 文件，但却无权这样做。您可以通过使用 URL 策略文件来尝试纠正此错误。
     
     <p>在 Adobe AIR 中，这些安全限制不适用于应用程序安全沙箱中的内容。</p>
     
	 <p>在 Adobe AIR 中，这些安全限制不适用于应用程序安全沙箱中的内容。</p>
	 
     </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
	在文件上载或下载操作期间定期分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
    </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	在文件上载或下载操作期间定期分派。<codeph>progress</codeph> 事件在 Flash Player 将字节传输到服务器时分派，即使传输最终没有成功，也会在传输期间定期分派。要确定文件传输是否真正成功和完成以及何时真正成功和完成，需要侦听 <codeph>complete</codeph> 事件。
    
    <p>在某些情况下，接收不到 <codeph>progress</codeph> 事件。例如，当所传输的文件非常小或者上载或下载速度非常快时，可能就不会分派 <codeph>progress</codeph> 事件。</p>
    
    <p>在低于 OS X 10.3 版本的 Macintosh 平台上不能确定文件上载进度。<codeph>progress</codeph> 事件在上载操作期间调用，但 progress 事件的 <codeph>bytesLoaded</codeph> 属性值为 -1，表示不能确定进度。</p>
    
    </apiDesc><example conref="examples\FileReference_event_progress.as"> 下面的示例演示 <codeph>progress</codeph> 事件的用法。要运行此示例，请将 <codeph>downloadURL.url</codeph> 属性更改为指向一个实际的域和文件，而不是虚拟的 http://www.[yourDomain].com/SomeFile.pdf。您可能还需要编译 SWF 文件，将“本地回放安全性”设置为“只访问网络”，或更新 Flash Player 的安全设置，以允许此文件网络访问。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_progress extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_progress() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            file.addEventListener(Event.COMPLETE, completeHandler);
            file.download(downloadURL, fileName);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
        
        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/event:complete"><linktext>FileReference.complete</linktext></link><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
	当上载或下载操作开始时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows the usage of the <code>open</code> event.
    It should be made clear that there is no way to actually track the progress
    of a download, just that it hasn't yet finished or failed.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onOpen = function(file:FileReference):void {
      trace("onOpen: " + file.name);
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	当上载或下载操作开始时分派。
    
    
    </apiDesc><example conref="examples\FileReference_download.as"> 下面的示例演示 <codeph>download</codeph> 事件对象的用法。要运行此示例，请将 <codeph>downloadURL.url</codeph> 属性更改为指向一个实际的域和文件，而不是虚拟的 http://www.[yourDomain].com/SomeFile.pdf。您可能还需要编译 SWF 文件，将“本地回放安全性”设置为“只访问网络”，或更新 Flash Player 的安全设置，以允许此文件网络访问。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;
    import flash.net.FileFilter;

    public class FileReference_download extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_download() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
	当上载或下载失败时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows the usage of the <code>ioError</code> event. 
    Note that for simplicity, none of the other event types are used in this
    example.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onIOError = function(file:FileReference):void {
      trace("onIOError");
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    fileRef.download("http://www.adobe.com/NonExistentFile.pdf", "NonExistentFile.pdf");
    
    </listing>
    
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	当上载或下载失败时分派。文件传输会失败的原因有：
    
    <ul>
    <li>当播放器正在读取、写入或传输文件时发生输入/输出错误。</li>
    <li><ph platform="javascript">AIR 应用程序</ph>的 <ph platform="actionscript">SWF 文件</ph>尝试将文件上载到要求身份验证（如用户名和密码）的服务器。在上载期间，<ph platform="actionscript">Flash Player 或</ph> Adobe AIR 不为用户提供输入密码的方法。如果 <ph platform="javascript">AIR 应用程序</ph>的 <ph platform="actionscript">SWF 文件</ph>尝试将文件上载到要求身份验证的服务器，上载将失败。</li>
    <li><ph platform="javascript">AIR 应用程序</ph>的 <ph platform="actionscript">SWF 文件</ph>尝试在独立或外部播放器中从要求身份验证的服务器下载文件。在下载期间，独立播放器和外部播放器不提供用户用于输入密码的方法。如果这些播放器中的 <ph platform="javascript">AIR 应用程序</ph>的 <ph platform="actionscript">SWF 文件</ph>尝试从要求身份验证的服务器下载文件，下载将失败。<ph platform="actionscript">文件下载只能在 ActiveX 控件、浏览器插件播放器和 Adobe AIR 运行时中成功。</ph></li>
    <li>传递到 <codeph>upload()</codeph> 方法中的 <codeph>url</codeph> 参数的值包含无效协议。有效协议包括 HTTP 和 HTTPS。</li>
    </ul>
    
    <p platform="actionscript"><b>重要说明：</b>只有在浏览器中运行的应用程序（即，使用浏览器插件或 ActiveX 控件的应用程序）和在 Adobe AIR 中运行的内容才可以提供对话框来提示用户输入用户名和密码以进行身份验证，并且只适用于下载。对于使用插件或 ActiveX 控件版本的 Flash Player 进行的上载操作，以及使用独立播放器或外部播放器进行的上载或下载操作，文件传输将失败。</p>
    
    </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	当下载操作完成或上载操作生成 HTTP 状态代码 200 时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows usage of the <code>complete</code> event 
    listener. It should be made clear that there is no way to actually track the progress
    of a download, just that it hasn't yet finished or failed.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onComplete = function(file:FileReference):void {
      trace("onComplete: " + file.name);
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	当下载操作完成或上载操作生成 HTTP 状态代码 200 时分派。对于文件下载操作，在 <ph platform="actionscript">Flash Player 或</ph> Adobe AIR 将整个文件下载到磁盘上时分派此事件。对于文件上载操作，在 <ph platform="actionscript">Flash Player 或</ph> Adobe AIR 接收到 HTTP 状态代码 200（来自接收传输的服务器）之后分派此事件。
    
    </apiDesc><example conref="examples\FileReference_event_complete.as"> 下面的示例演示 <codeph>complete</codeph> 事件对象的用法。要运行此示例，请将 <codeph>downloadURL.url</codeph> 属性更改为指向一个实际的域和文件，而不是虚拟的 http://www.[yourDomain].com/SomeFile.pdf。您可能还需要编译 SWF 文件，将“本地回放安全性”设置为“只访问网络”，或更新 Flash Player 的安全设置，以允许此文件网络访问。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_complete extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_complete() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
	当用户通过文件浏览对话框取消文件上载或下载时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example traces a message if the user dismisses the file-
    browsing dialog box. This method
    is triggered only if the user selects Cancel or presses the escape key after
    the dialog box opens.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onCancel = function(file:FileReference):void {
      trace("onCancel");
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    if(!fileRef.download(url, "FlashPlatform.pdf")) {
      trace("dialog box failed to open.");
    }
    </listing>
    
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	当用户通过文件浏览对话框取消文件上载或下载时分派。如果用户通过其它方式（关闭浏览器或停止当前应用程序）取消上载或下载，则 Flash Player 不会分派该事件。
    
    </apiDesc><example conref="examples\FileReference_event_cancel.as"> 下面的示例演示 <codeph>cancel</codeph> 事件对象的用法。要运行此示例，请将 <codeph>downloadURL.url</codeph> 属性更改为指向一个实际的域和文件，而不是虚拟的 http://www.[yourDomain].com/SomeFile.pdf。您可能还需要编译 SWF 文件，将“本地回放安全性”设置为“只访问网络”，或更新 Flash Player 的安全设置，以允许此文件网络访问。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_cancel extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_cancel() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            file.addEventListener(Event.CANCEL, cancelHandler);
            file.download(downloadURL, fileName);
        }
        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:FileReference:FileReference"><apiName>FileReference</apiName><shortdesc>
    创建新的 FileReference 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new <code>FileReference</code> object and 
    initiates the download of a pdf file.
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    listener.onComplete = function(file:FileReference) {
      trace("onComplete : " + file.name);
    }
    
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    
    </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
    创建新的 FileReference 对象。在填充后，FileReference 对象表示用户本地磁盘上的文件。
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:FileReference:browse"><apiName>browse</apiName><shortdesc>
    显示一个文件浏览对话框，让用户选择要上载的文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>browse, FileReference.browse
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在以下情况下引发：1) 另一个 FileReference 或 FileReferenceList 浏览会话正在进行中；每次仅能执行一个文件浏览会话。2) 用户 mms.cfg 文件中的某个设置禁止此操作。
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>如果 <codeph>typeFilter</codeph> 数组包含格式不正确的 FileFilter 对象，将引发异常。有关 FileFilter 对象正确格式的信息，请参阅 <xref href="FileFilter.html">FileFilter</xref> 类。
  
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>为了响应用户动作（如鼠标事件或按键事件），将不会调用此方法。
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>如果参数有效并且打开了文件浏览对话框，则返回 <codeph>true</codeph>。  
  
  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 FileFilter 实例数组，用于过滤在对话框中显示的文件。如果省略此参数，则显示所有文件。有关详细信息，请参阅 <xref href="FileFilter.html">FileFilter</xref> 类。
    
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    显示一个文件浏览对话框，让用户选择要上载的文件。该对话框对于用户的操作系统来说是本机的。用户可以选择本地计算机上的文件，也可以选择其它系统上的文件，例如，通过 Windows 上的 UNC 路径选择文件。
    
    <p><b>注意：</b>可在 Adobe AIR 中使用的 File 类包括用于访问更具体的系统文件选择对话框的方法。这些方法是 <codeph>File.browseForDirectory()</codeph>、<codeph>File.browseForOpen()</codeph>、<codeph>File.browseForOpenMultiple()</codeph> 和 <codeph>File.browseForSave()</codeph>。</p>
    
    <p>当调用此方法并且用户成功选择文件时，会使用该文件的属性填充此 FileReference 对象的属性。<codeph/>每次只能执行一个 <codeph>browse()</codeph> 或 <codeph>download()</codeph> 会话（因为每次只能调用一个对话框）。</p>
    
    <p>使用 <codeph>typeFilter</codeph> 参数，可决定对话框显示哪些文件。</p>
    
    <p platform="actionscript">在 Flash Player 10 和 Flash Player 9 Update 5 中，只有响应用户事件（例如，在鼠标单击或按键事件的事件处理函数中）才能成功调用此方法。否则，调用此方法将导致 Flash Player 引发 Error 异常。</p>
    
    <p platform="actionscript">请注意，由于已向 Flash Player 中添加了新功能，因此当发布到 Flash Player 10 时，一次只可以激活下列操作中的一个操作：<codeph>FileReference.browse()</codeph>、<codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph>、<codeph>FileReference.load()</codeph>、<codeph>FileReference.save()</codeph>。否则，Flash Player 会引发运行时错误（代码 2174）。使用 <codeph>FileReference.cancel()</codeph> 可停止正在进行的操作。此限制仅适用于 Flash Player 10。早期版本的 Flash Player 在同时进行多个操作时不会受到此限制的影响。</p> 
    
  </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReferenceList/event:select"><linktext>select 事件</linktext></link><link href="flash.net.xml#FileReference/event:cancel"><linktext>cancel 事件</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForDirectory().xml"><linktext>File.browseForDirectory()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForOpen().xml"><linktext>File.browseForOpen()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForOpenMultiple().xml"><linktext>File.browseForOpenMultiple()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForSave().xml"><linktext>File.browseForSave()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:browse_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当用户从浏览文件选择器成功选择了项目时分派。
  </apiDesc></adobeApiEventDetail><shortdesc>当用户从浏览文件选择器成功选择了项目时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:browse_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当用户取消文件上载浏览窗口时分派。
  
  </apiDesc></adobeApiEventDetail><shortdesc>当用户取消文件上载浏览窗口时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:cancel"><apiName>cancel</apiName><shortdesc>
  取消正在对该 FileReference 对象执行的任何上载或下载操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>cancel, FileReference.cancel
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>取消正在进行的任何上载或下载操作。
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  取消正在对该 FileReference 对象执行的任何上载或下载操作。调用此方法并不会分派 <codeph>cancel</codeph> 事件。仅在用户通过退出文件上载或下载对话框来取消操作时，才会分派该事件。
  
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:FileReference:download"><apiName>download</apiName><shortdesc>
    打开对话框，以允许用户从远程服务器下载文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在以下情况下引发：1) 另一个浏览会话正在进行中；每次仅能执行一个文件浏览会话。2) 传递给 <codeph>request</codeph> 的值不包含有效的路径或协议。3) 要下载的文件的名称中包含禁止使用的字符。4) 用户 mms.cfg 文件中的某个设置禁止此操作。
    
    	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>本地不受信任的内容可能无法与 Internet 进行通信。要避免这种情况，请将此 SWF 文件重新分类为只能与远程内容交互或受信任。引发此异常时会显示一条消息，指明由于本地文件安全性限制而不允许访问的文件名和 URL。
    
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果尝试连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。
    
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果 <codeph>url.data</codeph> 为 ByteArray 类型，将引发异常。当与 <codeph>FileReference.upload()</codeph> 和 <codeph>FileReference.download()</codeph> 方法一起使用时，<codeph>url.data</codeph> 只能为 URLVariables 或 String 类型。
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>发生此错误的原因有：1) Flash Player 无法将 <codeph>URLRequest.data</codeph> 参数从 UTF8 转换为 MBCS。如果传递给 <codeph>FileReference.download()</codeph> 方法的 URLRequest 对象设置为执行 GET 操作并且 <codeph>System.useCodePage</codeph> 设置为 <codeph>true</codeph>，将发生该错误。2) Flash Player 无法为 <codeph>POST</codeph> 数据分配内存。如果传递给 <codeph>FileReference.download()</codeph> 方法的 URLRequest 对象设置为执行 <codeph>POST</codeph> 操作，将发生该错误。
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>为了响应用户动作（如鼠标事件或按键事件），将不会调用此方法。
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>URLRequest 对象。URLRequest 对象的 <codeph>url</codeph> 属性应包含要下载到本地计算机的文件的 URL。若此参数为 <codeph>null</codeph>，将引发异常。URLRequest 对象的 <codeph>requestHeaders</codeph> 属性将被省略；上载或下载时不支持自定义 HTTP 请求标头。要向服务器发送 <codeph>POST</codeph> 或 GET 参数，请将 <codeph>URLRequest.data</codeph> 的值设置为您的参数，并将 <codeph>URLRequest.method</codeph> 设置为 <codeph>URLRequestMethod.POST</codeph> 或 <codeph>URLRequestMethod.GET</codeph>。
    
    	<p platform="actionscript">在某些浏览器上，URL 字符串长度受限。在某些浏览器或服务器上，长度超过 256 个字符的字符串可能失败。</p>
    
    </apiDesc></apiParam><apiParam><apiItemName>defaultFileName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>对话框中显示的要下载文件的默认文件名。此字符串不能包含以下字符：/ \ : ~~ ? " &lt; > | %
    <p>如果省略此参数，将分析出远程 URL 的文件名并用作默认文件名。 </p>
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    打开对话框，以允许用户从远程服务器下载文件。<ph platform="actionscript">虽然 Flash Player 没有限制可上载或下载的文件的大小，但是播放器正式支持的上载或下载文件大小最大为 100 MB。</ph>
    
    <p><codeph>download()</codeph> 方法首先打开一个操作系统对话框，让用户输入文件名并在本地计算机上选择用于保存文件的位置。用户选择了位置并确认下载操作时（例如，单击“保存”）后，开始从远程服务器下载。侦听器接收事件来指示下载的进度、成功或失败。为了在调用 <codeph>download()</codeph> 后确定对话框和下载操作的状态， 代码必须对 <codeph>cancel</codeph>、<codeph>open</codeph>、<codeph>progress</codeph> 和 <codeph>complete</codeph> 等事件进行侦听。
    </p>
    
    <p><codeph>FileReference.upload()</codeph> 和 <codeph>FileReference.download()</codeph> 函数是非阻塞式的。这些函数在调用之后即返回，而不会等待文件传输完成。此外，若 FileReference 对象离开作用域，则对该对象尚未完成的上载或下载操作将在它离开作用域后被取消。只要希望上载或下载操作继续，就应确保将 FileReference 对象保留在作用域中。</p>
    
    <p>成功下载文件之后，将使用本地文件的属性填充 FileReference 对象的属性。如果下载成功，将分派 <codeph>complete</codeph> 事件。</p>
    
    <p>每次只能执行一个 <codeph>browse()</codeph> 或 <codeph>download()</codeph> 会话（因为每次只能调用一个对话框）。</p>
    
    <p>此方法支持使用 HTTP 或 HTTPS 下载任何文件类型。</p>
    
     <p>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。</p>
    
    <p><b>注意</b>：如果服务器要求用户身份验证，则只有在浏览器中运行的 SWF 文件（即使用浏览器插件或 ActiveX 控件的文件）才可以提供对话框来提示用户输入用户名和密码以进行身份验证，并且只适用于下载。对于使用插件或 ActiveX 控件进行的上载操作，以及使用独立或外部播放器进行的上载和下载操作，文件传输会失败。</p>
    
    <p>当在应用程序安全沙箱以外的<ph platform="javascript">安全沙箱的内容中使用此方法时</ph>，请考虑 <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR</ph> 安全模型： </p>
    
    <ul>
    <li>如果执行调用的 SWF 文件在不受信任的本地沙箱中，则不允许进行加载操作。</li>
    
    <li>默认行为是拒绝沙箱之间的访问。网站可通过添加 URL 策略文件来实现对资源的访问。</li>
    
    <li platform="actionscript">可以在包含 SWF 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数，防止 SWF 文件使用此方法。</li>
    
    <li platform="actionscript">在 Flash Player 10 和 Flash Player 9 Update 5 中，只有响应用户事件（例如，在鼠标单击或按键事件的事件处理函数中）才能成功调用此方法。否则，调用此方法将导致 Flash Player 引发 Error 异常。</li>
    
    </ul>
    
    <p>但<ph platform="actionscript">在 Adobe AIR 中</ph>，<codeph>应用程序</codeph>安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
    
    <p>有关安全性的详细信息，请参阅以下部分：</p>
    
    <ul>
           
    <li product="flex">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
    
    <li product="flash">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
    
    <li><i>Developing AIR Applications</i>（《开发 AIR 应用程序》）一书的“Getting started with Adobe AIR”（Adobe AIR 入门）一章中的“Understanding AIR Security”（了解 AIR 安全性）一节。</li>
    
    <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
    
    </ul>
    
    <p>请注意，由于已向 Flash Player 中添加了新功能，因此当发布到 Flash Player 10 时，一次只可以激活下列操作中的一个操作：<codeph>FileReference.browse()</codeph>、<codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph>、<codeph>FileReference.load()</codeph>、<codeph>FileReference.save()</codeph>。否则，Flash Player 会引发运行时错误（代码 2174）。使用 <codeph>FileReference.cancel()</codeph> 可停止正在进行的操作。此限制仅适用于 Flash Player 10。早期版本的 Flash Player 在同时进行多个操作时不会受到此限制的影响。</p> 
	
    </apiDesc><example conref="examples\FileReference_download.as"> 下面的示例演示 <codeph>download</codeph> 事件对象的用法。要运行此示例，请将 <codeph>downloadURL.url</codeph> 属性更改为指向一个实际的域和文件，而不是虚拟的 http://www.[yourDomain].com/SomeFile.pdf。您可能还需要编译 SWF 文件，将“本地回放安全性”设置为“只访问网络”，或更新 Flash Player 的安全设置，以允许此文件网络访问。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;
    import flash.net.FileFilter;

    public class FileReference_download extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_download() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link><link href="flash.net.xml#FileReference/save()"><linktext>FileReference.save()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:download_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当下载操作开始时分派。
    </apiDesc></adobeApiEventDetail><shortdesc>当下载操作开始时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件下载操作期间进行定期分派。
    </apiDesc></adobeApiEventDetail><shortdesc>在文件下载操作期间进行定期分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当文件下载操作成功完成时分派。
    </apiDesc></adobeApiEventDetail><shortdesc>当文件下载操作成功完成时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当用户取消对话框时分派。
    </apiDesc></adobeApiEventDetail><shortdesc>当用户取消对话框时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当用户从对话框中选择要下载的文件时分派。 
    </apiDesc></adobeApiEventDetail><shortdesc>当用户从对话框中选择要下载的文件时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当由于安全错误导致下载失败时分派。
    </apiDesc></adobeApiEventDetail><shortdesc>当由于安全错误导致下载失败时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>由于下列任一原因进行分派：
    <ul>
    <li>读取或传输文件期间发生输入/输出错误。</li>
    	<li>在 Flash Player 的独立或外部版本中运行的 SWF 内容尝试从需要身份验证的服务器下载文件。在下载期间，独立播放器和外部播放器不为用户提供用于输入密码的方法。如果这些播放器中的 SWF 文件尝试从要求身份验证的服务器下载文件，则下载会失败。只有在 ActiveX 控件和浏览器插件播放器中，文件下载才有可能成功。</li>
    </ul>
    
    </apiDesc></adobeApiEventDetail><shortdesc>由于下列任一原因而分派：正在读取或传输文件时发生输入/输出错误。在 Flash Player 的独立或外部版本中运行的 SWF 内容尝试从需要身份验证的服务器下载文件。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:load"><apiName>load</apiName><shortdesc>
    开始加载用户选择的本地文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>load, FileReference.load
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在以下情况下引发：1) 另一个 FileReference 或 FileReferenceList 浏览会话正在进行中；每次仅能执行一个文件浏览会话。2) 用户 mms.cfg 文件中的某个设置禁止此操作。
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>如果应用程序无法为文件分配内存，则可能会发生此错误。文件可能太大，或者可用的内存可能太小。
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>开始加载本地文件。
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    开始加载用户选择的本地文件。<ph platform="actionscript">虽然 Flash Player 没有限制可上载、下载、加载或保存的文件的大小，但其正式支持的文件大小最大为 100 MB。对于 Flash Player 中运行的内容，必须先调用 <codeph>FileReference.browse()</codeph> 或 <codeph>FileReferenceList.browse()</codeph> 方法，然后再调用 <codeph>load()</codeph> 方法。不过，应用程序沙箱中运行于 AIR 中的内容调用 File 对象的 <codeph>load()</codeph> 方法之前不必先调用 <codeph>browse()</codeph> 方法。（AIR File 类扩展了 FileReference 类。）</ph>
    
    <p>侦听器接收事件来指示加载的进度、成功或失败。尽管可以使用 FileReferenceList 对象让用户选择多个要加载的文件，但仍必须逐个加载这些文件。要逐个加载文件，请遍历 FileReference 对象的 <codeph>FileReferenceList.fileList</codeph> 数组。</p>
    
    <p>Adobe AIR 还包括为读取文件提供更多选项的 FileStream 类。</p>
    
    <p><codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph>、<codeph>FileReference.load()</codeph> 和 <codeph>FileReference.save()</codeph> 函数均不分块。这些函数在调用之后即返回，而不会等待文件传输完成。此外，如果 FileReference 对象离开作用域，则该对象中尚未完成的任何事务将在离开作用域时被取消。只要希望上载、下载、加载或保存能继续，就应确保将 FileReference 对象保留在作用域中。</p>
    
    <p>如果文件成功完成加载，则其内容将作为字节数组存储在 FileReference 对象的 <codeph>data</codeph> 属性中。</p>
    
    <p platform="actionscript">有以下安全事项需要注意：</p>
    
    <ul platform="actionscript">
    <li>如果执行调用的 SWF 文件在不受信任的本地沙箱中，则不允许进行加载操作。</li>
    <li>默认行为是拒绝沙箱之间的访问。网站可通过添加跨域策略文件来实现对资源的访问。</li>
    <li>可以在包含 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数，防止 SWF 文件使用此方法。</li>
    </ul>
    
    <p platform="actionscript">不过，这些注意事项不适用于应用程序沙箱中的 AIR 内容。</p>
    
    <p>请注意，当发布到 Flash Player 10 或 AIR 1.5 时，一次只能激活以下操作中的一项：<codeph>FileReference.browse()</codeph>、<codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph>、<codeph>FileReference.load()</codeph>、<codeph>FileReference.save()</codeph>。否则，应用程序将引发运行时错误（代码 2174）。使用 <codeph>FileReference.cancel()</codeph> 可停止正在进行的操作。此限制仅适用于 Flash Player 10 和 AIR 1.5。早期版本的 Flash Player 或 AIR 在同时进行多个操作时不会受到此限制的影响。</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/data"><linktext>FileReference.data</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/save()"><linktext>FileReference.save()</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>flash.filesystem.FileStream</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在加载操作开始时分派。
    </apiDesc></adobeApiEventDetail><shortdesc>在加载操作开始时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件加载操作期间定期分派。
    </apiDesc></adobeApiEventDetail><shortdesc>在文件加载操作期间定期分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件加载操作成功完成时分派。
    </apiDesc></adobeApiEventDetail><shortdesc>在文件加载操作成功完成时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在应用程序读取或写入文件期间由于发生输入/输出错误而导致加载失败时调用。
    
    </apiDesc></adobeApiEventDetail><shortdesc>在应用程序读取或写入文件期间由于发生输入/输出错误而导致加载失败时调用。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:save"><apiName>save</apiName><shortdesc>
    打开一个对话框，允许用户将文件保存到本地文件系统。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在以下情况下引发：1) 另一个浏览会话正在进行中；每次仅能执行一个文件浏览会话。2) 要下载的文件的名称中包含禁止使用的字符。3) 用户 mms.cfg 文件中的某个设置禁止此操作。
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>如果 <codeph>data</codeph> 的类型不是 ByteArray，并且不具有 <codeph>toString()</codeph> 方法，则将引发异常。如果 <codeph>data</codeph> 的类型不是 XML，并且不具有 <codeph>toXMLString()</codeph> 方法，则将引发异常。
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>为了响应用户动作（如鼠标事件或按键事件），将不会调用此方法。
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>如果 Flash Player 无法为该文件分配内存，则可能会发生此错误。文件可能太大，或者可用的内存可能太小。
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>data</apiItemName><apiType value=""/><apiDesc>要保存的数据。数据可以采用几种格式之一，并将进行适当处理：
    <ul>
    <li>如果值为 <codeph>null</codeph>，则应用程序将引发 ArgumentError 异常。</li> 
    <li>如果值为 String，则将其保存为 UTF-8 文本文件。</li>
    <li platform="actionscript">如果值为 XML，则会以 XML 格式将其写入到文本文件，并保留所有格式设置。</li> 
    <li>如果值为 ByteArray 对象，则会将其逐字写入到数据文件。</li> 
    <li>如果值并非以上任何一种，则 <codeph>save()</codeph> 方法将调用对象的 <codeph>toString()</codeph> 方法，将数据转换为字符串，然后将数据保存为文本文件。如果该操作失败，则应用程序将引发 ArgumentError 异常。</li> 
    </ul>
    
    </apiDesc></apiParam><apiParam><apiItemName>defaultFileName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>对话框中显示的要保存文件的默认文件名。此字符串不能包含以下字符：/ \ : ~~ ? " &lt; > | %
    <p><ph platform="javascript">在 Flash Player 中，如果省略此参数，则在默认情况下，文件名将为空白。</ph>如果 File 对象调用此方法，则文件名将为 File 对象所引用文件的名称。（AIR File 类扩展了 FileReference 类。）</p>
    
	</apiDesc></apiParam></apiOperationDef><apiDesc>
    打开一个对话框，允许用户将文件保存到本地文件系统。<ph platform="actionscript">虽然 Flash Player 没有限制可上载、下载、加载或保存的文件的大小，但是播放器正式支持的文件大小最大为 100 MB。</ph>
    
    <p><codeph>save()</codeph> 方法首先打开一个操作系统对话框，让用户输入文件名并在本地计算机上选择用于保存文件的位置。当用户选择了位置并确认保存操作时（例如通过单击“保存”），保存过程即会开始。侦听器接收事件来指示保存操作的进度、成功或失败。为了在调用 <codeph>save()</codeph> 后确定对话框和保存操作的状态，代码必须对 <codeph>cancel</codeph>、<codeph>open</codeph>、<codeph>progress</codeph> 和 <codeph>complete</codeph> 等事件进行侦听。
    </p>
    
    <p>Adobe AIR 还包括为本地保存文件提供更多选项的 FileStream 类。</p>
    
    <p><codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph>、<codeph>FileReference.load()</codeph> 和 <codeph>FileReference.save()</codeph> 函数均不分块。这些函数在调用之后即返回，而不会等待文件传输完成。此外，如果 FileReference 对象离开作用域，则该对象中尚未完成的任何事务将在离开作用域时被取消。只要希望上载、下载、加载或保存能继续，就应确保将 FileReference 对象保留在作用域中。</p>
    
    <p>在成功保存文件之后，将使用本地文件的属性填充 FileReference 对象的属性。如果保存成功，将分派 <codeph>complete</codeph> 事件。</p>
    
    <p>每次只能执行一个 <codeph>browse()</codeph> 或 <codeph>save()</codeph> 会话（因为每次只能调用一个对话框）。</p>
    
    <p platform="actionscript">在 Flash Player 中，只有在响应用户事件（例如，在鼠标单击或按键事件的事件处理函数中）时才能成功调用此方法。否则，调用此方法将导致 Flash Player 引发 Error 异常。此限制不适用于应用程序沙箱中的 AIR 内容。</p>
    
    </apiDesc><example conref="examples\FileReference_save.as"> 以下示例将键入到文本字段的内容保存到文件。该示例创建一个可编辑的文本字段 (<codeph>MyTextField</codeph>)，创建另一不可编辑的文本字段 (<codeph>MyButtonField</codeph>) 作为“按钮”以响应鼠标单击。用户可以编辑第一个文本字段并单击按钮，将文本字段内容保存到本地文件。鼠标单击事件处理函数 <codeph>clickhandler</codeph> 使用 <codeph>FileReference.save()</codeph> 方法（针对名为 <codeph>MyFileReference</codeph> 的 FileReference 对象）打开用户当前操作系统中的对话框，因此用户可以将内容保存为本地文件，使用用户提供的名称作为文件名。
<codeblock>
var MyTextField:TextField = new TextField();
var MyButtonField:TextField = new TextField();
var MyFile:FileReference = new FileReference();

MyTextField.border = true;
MyTextField.type = TextFieldType.INPUT;

MyButtonField.background = true;
MyButtonField.backgroundColor = 0x339933;
MyButtonField.x = 150;
MyButtonField.height = 20;
MyButtonField.text = "Click here to save";

addChild(MyTextField);
addChild(MyButtonField);
MyButtonField.addEventListener(MouseEvent.CLICK, clickhandler);

function clickhandler(e:MouseEvent): void {
    MyFile.save(MyTextField.text);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/load()"><linktext>FileReferenceList.load()</linktext></link><link href="flash.net.xml#FileReferenceList/data"><linktext>FileReferenceList.data</linktext></link><link href="flash.net.xml#FileReferenceList/upload"><linktext>FileReferenceList.upload</linktext></link><link href="flash.net.xml#FileReferenceList/download"><linktext>FileReferenceList.download</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>FileStream</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:save_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当下载操作开始时分派。
	</apiDesc></adobeApiEventDetail><shortdesc>当下载操作开始时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件下载操作期间进行定期分派。
	</apiDesc></adobeApiEventDetail><shortdesc>在文件下载操作期间进行定期分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当文件下载操作成功完成时分派。
    </apiDesc></adobeApiEventDetail><shortdesc>当文件下载操作成功完成时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当用户取消对话框时分派。
	</apiDesc></adobeApiEventDetail><shortdesc>当用户取消对话框时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当用户从对话框中选择要下载的文件时分派。 
    </apiDesc></adobeApiEventDetail><shortdesc>当用户从对话框中选择要下载的文件时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>读取或传输文件期间发生输入/输出错误时分派。
    
    </apiDesc></adobeApiEventDetail><shortdesc>读取或传输文件期间发生输入/输出错误时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:upload"><apiName>upload</apiName><shortdesc>
    开始将用户选择的文件上载到远程服务器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>upload, FileReference.upload
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>本地不受信任的 SWF 文件可能无法与 Internet 进行通信。要避免这种情况，请将此 SWF 文件重新分类为只能与远程内容交互或受信任。引发此异常时会附带一个消息，指明不允许访问的本地文件和 URL 的名称。
    
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果尝试连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。
     
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>在以下情况下引发：1) 另一个 FileReference 或 FileReferenceList 浏览会话正在进行中；每次仅能执行一个文件浏览会话。2) URL 参数为无效的路径或协议。文件上载必须使用 HTTP 协议，文件下载则必须使用 FTP 或 HTTP 协议。3) <codeph>uploadDataFieldName</codeph> 参数设置为 <codeph>null</codeph>。4) 用户 mms.cfg 文件中的某个设置禁止此操作。
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>在以下情况下引发：1) <codeph>uploadDataFieldName</codeph> 参数为空字符串。2) <codeph>url.data</codeph> 为 ByteArray 类型。当与 <codeph>FileReference.upload()</codeph> 和 <codeph>FileReference.download()</codeph> 方法一起使用时，<codeph>url.data</codeph> 只能为 URLVariables 或 String 类型。3) 在 AIR 运行时中（在应用程序安全沙箱中），URLRequest 的方法不是 GET 和 POST（而是使用 <codeph>uploadEncoded()</codeph>）。
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>发生此错误的原因有：1) Flash Player 无法将 <codeph>URLRequest.data</codeph> 参数从 UTF8 转换为 MBCS。如果传递给 <codeph>FileReference.upload()</codeph> 的 URLRequest 对象设置为执行 GET 操作并且 <codeph>System.useCodePage</codeph> 设置为 <codeph>true</codeph>，将发生该错误。2) Flash Player 无法为 <codeph>POST</codeph> 数据分配内存。如果传递给 <codeph>FileReference.upload()</codeph> 的 URLRequest 对象设置为执行 <codeph>POST</codeph> 操作，将发生该错误。
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>URLRequest 对象，URLRequest 对象的 <codeph>url</codeph> 属性应包含特定服务器脚本的 URL，该服务器脚本被配置为通过 HTTP <codeph>POST</codeph> 调用处理上载。在某些浏览器上，URL 字符串长度受限。在某些浏览器或服务器上，长度超过 256 个字符的字符串可能失败。若此参数为 <codeph>null</codeph>，将引发异常。URLRequest 对象的 <codeph>requestHeaders</codeph> 属性将被省略；上载或下载时不支持自定义 HTTP 请求标头。
     
    <p>该 URL 可以是 HTTP，或者为了安全地进行上载，也可以是 HTTPS。要使用 HTTPS，请在 <codeph>url</codeph> 参数中使用 HTTPS URL。如果在 <codeph>url</codeph> 参数中没有指定端口号，则默认情况下，将使用端口 80（对于 HTTP）或端口 443（对于 HTTPS）。</p>
    
    <p>要向服务器发送 <codeph>POST</codeph> 或 <codeph>GET</codeph> 参数，请将 URLRequest 对象的 <codeph>data</codeph> 属性设置为您的参数，并将 <codeph>method</codeph> 属性设置为 <codeph>URLRequestMethod.POST</codeph> 或 <codeph>URLRequestMethod.GET</codeph>。</p>
    
    
    </apiDesc></apiParam><apiParam><apiItemName>uploadDataFieldName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>Filedata</apiData><apiDesc>在上载 <codeph>POST</codeph> 操作中位于文件数据之前的字段名。<codeph>uploadDataFieldName</codeph> 值必须为非空字符串。默认情况下，<codeph>uploadDataFieldName</codeph> 的值为 <codeph>"Filedata"</codeph>，如下面的范例 <codeph>POST</codeph> 请求所示：
    <pre>
    Content-Type: multipart/form-data; boundary=AaB03x
    --AaB03x 
    Content-Disposition: form-data; name="Filedata"; filename="example.jpg" 
    Content-Type: application/octet-stream
    ... contents of example.jpg ... 
    --AaB03x-- 
    </pre>
    
    </apiDesc></apiParam><apiParam><apiItemName>testUpload</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>请求上载测试文件的设置。如果 <codeph>testUpload</codeph> 为 <codeph>true</codeph>，则对于大于 10 KB 的文件，Flash Player 将尝试进行内容长度为 0 的测试文件上载 <codeph>POST</codeph>。测试上载将检查实际文件上载是否可能成功，以及服务器身份验证（如果需要）是否可能成功。测试上载仅适用于 Windows 播放器。
    
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>开始将文件上载到远程服务器。
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    开始将用户选择的文件上载到远程服务器。<ph platform="actionscript">虽然 Flash Player 没有限制可上载或下载的文件的大小，但是播放器正式支持的上载或下载文件大小最大为 100 MB。</ph>调用此方法之前，必须先调用 <codeph>FileReference.browse()</codeph> 或 <codeph>FileReferenceList.browse()</codeph> 方法。
    
    <p>侦听器接收事件来指示上载的进度、成功或失败。尽管可以使用 FileReferenceList 对象让用户选择多个要上载的文件，但必须逐个上载文件。为此，需遍历由 FileReference 对象组成的 <codeph>FileReferenceList.fileList</codeph> 数组。</p>
    
    <p><codeph>FileReference.upload()</codeph> 和 <codeph>FileReference.download()</codeph> 函数是非阻塞式的。这些函数在调用之后即返回，而不会等待文件传输完成。此外，若 FileReference 对象离开作用域，则对该对象尚未完成的上载或下载操作将在它离开作用域后被取消。只要希望上载或下载操作继续，就应确保将 FileReference 对象保留在作用域中。</p>
    
    <p>文件上载到在 <codeph>url</codeph> 参数中传递的 URL。该 URL 必须是配置为接受上载的服务器脚本。Flash Player 使用 HTTP <codeph>POST</codeph> 方法上载文件。处理上载的服务器脚本应收到包含下列元素的 <codeph>POST</codeph> 请求：</p>
    <ul>
    <li><codeph>Content-Type</codeph> ，属于 <codeph>multipart/form-data</codeph></li>
    <li><codeph>Content-Disposition</codeph>，其 <codeph>name</codeph> 属性默认情况下设置为 <codeph>"Filedata"</codeph>，<codeph>filename</codeph> 属性设置为原始文件的名称</li>
    <li>文件的二进制内容</li></ul>
    
     <p>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。</p>
    
    <p>对于范例 <codeph>POST</codeph> 请求，请参阅有关 <codeph>uploadDataFieldName</codeph> 参数的描述。可以使用 <codeph>upload()</codeph> 方法向服务器发送 <codeph>POST</codeph> 或 <codeph>GET</codeph> 参数，请参阅有关 <codeph>request</codeph> 参数的描述。</p>
    
    <p>如果 <codeph>testUpload</codeph> 参数为 <codeph>true</codeph>，并且要上载的文件大于约 10 KB，则基于 Windows 的 Flash Player 在上载实际的文件之前，会先发送不带内容的测试上载 <codeph>POST</codeph> 操作，以验证传输操作是否可能成功。之后，Flash Player 会再次发送 <codeph>POST</codeph> 操作，这时其中将包含实际的文件内容。对于小于 10 KB 的文件，Flash Player 则仅执行一次上载 <codeph>POST</codeph> 操作，其中包含要上载的实际文件内容。基于 Macintosh 的 Flash Player 不执行测试上载 <codeph>POST</codeph> 操作。</p>
    
    <p><b>注意</b>：如果服务器要求用户身份验证，则只有在浏览器中运行的 SWF 文件（即使用浏览器插件或 ActiveX 控件的文件）才可以提供对话框来提示用户输入用户名和密码以进行身份验证，并且只适用于下载。对于使用插件或 ActiveX 控件进行的上载操作，以及使用独立或外部播放器进行的上载和下载操作，文件传输会失败。</p>
    
    <p>当在应用程序安全沙箱以外的<ph platform="javascript">安全沙箱的内容中使用此方法时</ph>，请考虑 <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR</ph> 安全模型： </p>
    
    
    <ul>
    <li>如果执行调用的 SWF 文件在不受信任的本地沙箱中，则不允许进行加载操作。</li>
    
    <li>默认行为是拒绝沙箱之间的访问。网站可通过添加 URL 策略文件来实现对资源的访问。</li>
    
	<li platform="actionscript">可以在包含 SWF 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数，防止 SWF 文件使用此方法。</li>
    
    </ul>
    
    <p>但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
    
	<p>有关详细信息，请参阅以下部分：</p>
    
    <ul>
    
    <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
    
    <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
    
    <li><i>Developing AIR Applications</i>（《开发 AIR 应用程序》）一书的“Getting started with Adobe AIR”（Adobe AIR 入门）一章中的“Understanding AIR Security”（了解 AIR 安全性）一节。</li>
    
    <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
    </ul>
    <p>请注意，由于已向 Flash Player 中添加了新功能，因此当发布到 Flash Player 10 时，一次只可以激活下列操作中的一个操作：<codeph>FileReference.browse()</codeph>、<codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph>、<codeph>FileReference.load()</codeph>、<codeph>FileReference.save()</codeph>。否则，Flash Player 会引发运行时错误（代码 2174）。使用 <codeph>FileReference.cancel()</codeph> 可停止正在进行的操作。此限制仅适用于 Flash Player 10。早期版本的 Flash Player 在同时进行多个操作时不会受到此限制的影响。</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/load()"><linktext>FileReference.load()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:upload_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当上载操作开始时分派。
	
    </apiDesc></adobeApiEventDetail><shortdesc>当上载操作开始时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件上载操作期间进行定期分派。
	
    </apiDesc></adobeApiEventDetail><shortdesc>在文件上载操作期间进行定期分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当文件上载操作成功完成时分派。
	
    </apiDesc></adobeApiEventDetail><shortdesc>当文件上载操作成功完成时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_uploadCompleteData"><apiName>uploadCompleteData</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>成功上载文件并从服务器接收数据之后分派。
	
    </apiDesc></adobeApiEventDetail><shortdesc>成功上载文件并从服务器接收数据之后分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>由于安全错误导致上载失败时分派。
	
    </apiDesc></adobeApiEventDetail><shortdesc>由于安全错误导致上载失败时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>由于 HTTP 错误导致上载失败时分派。
	
 	</apiDesc></adobeApiEventDetail><shortdesc>由于 HTTP 错误导致上载失败时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>上载操作成功完成，服务器返回响应 URL 和响应标头。
	
    </apiDesc></adobeApiEventDetail><shortdesc>上载操作成功完成，服务器返回响应 URL 和响应标头。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在下列任一情形下调用：
    <ul>
    <li>由于 <ph platform="actionscript">Flash Player </ph>或 Adobe AIR 在读/写或传输文件期间发生输入/输出错误，导致上载失败。</li>
    <li>由于试图将文件上载到要求身份验证（如用户名和密码）的服务器而使上载失败。在上载过程中，没有为用户提供输入密码的方式。</li>
    <li>由于 <codeph>url</codeph> 参数包含无效协议，导致上载失败。<codeph>FileReference.upload()</codeph> 必须使用 HTTP 或 HTTPS。</li>
    
    </ul>
    
    </apiDesc></adobeApiEventDetail><shortdesc>在下列任一情况下调用：由于 Flash Player 或 Adobe AIR 在读取、写入或传输文件时出现输入/输出错误，上载失败。由于试图将文件上载到要求身份验证（如用户名和密码）的服务器而使上载失败。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:uploadUnencoded"><apiName>uploadUnencoded</apiName><shortdesc>
    启动将文件上载到 URL 的操作，不进行任何编码。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>本地不受信任的 SWF 文件可能无法与 Internet 进行通信。要避免这种情况，请将此 SWF 文件重新分类为只能与远程内容交互或受信任。引发此异常时会附带一个消息，指明不允许访问的本地文件和 URL 的名称。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>在以下情况下引发：1) 另一个 FileReference 或 FileReferenceList 浏览会话正在进行中；每次仅能执行一个文件浏览会话。2) URL 参数为无效的路径或协议。文件上载必须使用 HTTP。
	
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>URLRequest 对象，URLRequest 对象的 <codeph>url</codeph> 属性应包含特定服务器脚本的 URL，该服务器脚本被配置为通过 HTTP <codeph>POST</codeph> 调用处理上载。在某些浏览器上，URL 字符串长度受限。在某些浏览器或服务器上，长度超过 256 个字符的字符串可能失败。若此参数为 <codeph>null</codeph>，将引发异常。  
	 
	<p>该 URL 可以是 HTTP，或者为了安全地进行上载，也可以是 HTTPS。要使用 HTTPS，请在 <codeph>url</codeph> 参数中使用 HTTPS URL。如果在 <codeph>url</codeph> 参数中没有指定端口号，则默认情况下，将使用端口 80（对于 HTTP）或端口 443（对于 HTTPS）。</p>
	
	<p>要向服务器发送 <codeph>POST</codeph> 或 <codeph>GET</codeph> 参数，请将 URLRequest 对象的 <codeph>data</codeph> 属性设置为您的参数，并将 <codeph>method</codeph> 属性设置为 <codeph>URLRequestMethod.POST</codeph> 或 <codeph>URLRequestMethod.GET</codeph>。</p>
   	
    </apiDesc></apiParam><apiTipTexts><apiTipText>开始将文件上载到远程服务器，而无需进行编码。 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    启动将文件上载到 URL 的操作，不进行任何编码。由于 <codeph>upload()</codeph> 方法会在 form-data 封套中对文件进行编码，因此 <codeph>uploadUnencoded()</codeph> 方法会在 HTTP 请求正文中按原样传递文件内容。如果要发送的数据已编码为接收服务器能够理解的格式，请使用 uploadUnencoded() 方法。<codeph>uploadeUnencoded()</codeph> 方法通常与 <codeph>HTTP/WebDAV PUT</codeph> 方法一起使用。
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>upload()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当上载操作开始时分派。
	
	</apiDesc></adobeApiEventDetail><shortdesc>当上载操作开始时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件上载操作期间进行定期分派。
	
	</apiDesc></adobeApiEventDetail><shortdesc>在文件上载操作期间进行定期分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当文件上载操作成功完成时分派。
	
	</apiDesc></adobeApiEventDetail><shortdesc>当文件上载操作成功完成时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_uploadCompleteData"><apiName>uploadCompleteData</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>成功上载文件并从服务器接收数据之后分派。
	
	</apiDesc></adobeApiEventDetail><shortdesc>成功上载文件并从服务器接收数据之后分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>由于安全错误导致上载失败时分派。
	
	</apiDesc></adobeApiEventDetail><shortdesc>由于安全错误导致上载失败时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>由于 HTTP 错误导致上载失败时分派。
	
 	</apiDesc></adobeApiEventDetail><shortdesc>由于 HTTP 错误导致上载失败时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>上载操作成功完成，服务器返回响应 URL 和响应标头。
	
	</apiDesc></adobeApiEventDetail><shortdesc>上载操作成功完成，服务器返回响应 URL 和响应标头。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在下列任一情形下调用：
    <ul>
	<li>由于 Adobe AIR 在读/写或传输文件期间发生输入/输出错误，导致上载失败。</li>
	<li>由于试图将文件上载到要求身份验证（如用户名和密码）的服务器而使上载失败。在上载过程中，没有为用户提供输入密码的方式。</li>
	<li>由于 <codeph>url</codeph> 参数包含无效协议，导致上载失败。<codeph>FileReference.upload()</codeph> 必须使用 HTTP 或 HTTPS。</li>
	</ul>
	
	</apiDesc></adobeApiEventDetail><shortdesc>在下列任一情况下调用：由于 Adobe AIR 在读取、写入或传输文件时出现输入/输出错误，上载失败。由于试图将文件上载到要求身份验证（如用户名和密码）的服务器而使上载失败。</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:FileReference:creationDate:get"><apiName>creationDate</apiName><shortdesc>
    本地磁盘上文件的创建日期。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>creationDate, FileReference.creationDate
    
    </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Date</apiValueClassifier><apiException><apiDesc>若 <codeph>FileReference.browse()</codeph>、<codeph>FileReferenceList.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法未能成功调用，将引发异常，同时显示一条信息，指出函数的调用顺序不正确或先前调用未成功。此时，<codeph>creationDate</codeph> 属性的值为 <codeph>null</codeph>。
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>若不能访问文件信息，则会引发一个异常，同时显示一条信息，指出发生文件 I/O 错误。
    
    </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>作为 Date 对象获取文件的创建日期。
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    本地磁盘上文件的创建日期。如果未填充对象，则为获取此属性的值而执行的调用将返回 <codeph>null</codeph>。
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:creator:get"><apiName>creator</apiName><shortdesc>
    文件的 Macintosh 创建者类型，此类型仅用于 Mac OS X 之前的 Mac OS 版本中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>creator, FileReference.creator
    </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>在 Macintosh 系统上，若 <codeph>FileReference.browse()</codeph>、<codeph>FileReferenceList.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法未能成功调用，将引发异常，同时显示一条信息，指出函数的调用顺序不正确或先前调用未成功。此时，<codeph>creator</codeph> 属性的值为 <codeph>null</codeph>。
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Macintosh 创建者类型。
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    文件的 Macintosh 创建者类型，此类型仅用于 Mac OS X 之前的 Mac OS 版本中。在 Windows 或 Linux 中，此属性为 <codeph>null</codeph>。如果未填充 FileReference 对象，则为获得此属性的值而执行的调用将返回 <codeph>null</codeph>。
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference/extension"><linktext>FileReference.extension</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:data:get"><apiName>data</apiName><shortdesc>
    成功调用 load() 方法之后代表所加载文件中的数据的 ByteArray 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><refpath>
    </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>如果 <codeph>load()</codeph> 方法未能成功调用，则将引发异常，同时显示一条消息，指示函数的调用顺序不正确或先前调用未成功。在这种情况下，<codeph>data</codeph> 属性的值为 <codeph>null</codeph>。
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>若无法打开或读取文件，或者在访问文件时遇到类似错误，将引发异常，同时显示一条信息，指明发生文件 I/O 错误。在这种情况下，<codeph>data</codeph> 属性的值为 <codeph>null</codeph>。
    
    </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>文件的已加载数据，用 ByteArray 表示。
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    成功调用 <codeph>load()</codeph> 方法之后代表所加载文件中的数据的 ByteArray 对象。
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference/load()"><linktext>FileReference.load()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:extension:get"><apiName>extension</apiName><shortdesc>
	 文件扩展名。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>如果未初始化引用。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 文件扩展名。
	 
	 <p>文件的扩展名是最后一个句点（“.”）后面的名称部分（不包括句点）。如果文件名中没有句点，则 extension 为 <codeph>null</codeph>。</p>
	 
	 <p><i>注意：</i>应该使用 <codeph>extension</codeph> 属性来确定文件的类型，不要使用 <codeph>creator</codeph> 或 <codeph>type</codeph> 属性。应该将 <codeph>creator</codeph> 和 <codeph>type</codeph> 属性视为已不推荐使用。它们适用于 Mac OS 的早期版本。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileReference:modificationDate:get"><apiName>modificationDate</apiName><shortdesc>
   本地磁盘上文件的上一次修改日期。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>modificationDate, FileReference.modificationDate
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Date</apiValueClassifier><apiException><apiDesc>若 <codeph>FileReference.browse()</codeph>、<codeph>FileReferenceList.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法未能成功调用，将引发异常，同时显示一条信息，指出函数的调用顺序不正确或先前调用未成功。此时，<codeph>modificationDate</codeph> 属性的值为 <codeph>null</codeph>。
   
   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>若不能访问文件信息，则会引发一个异常，同时显示一条信息，指出发生文件 I/O 错误。
   
   </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>作为 Date 对象获取文件的修改日期。
   </apiTipText></apiTipTexts></apiValueDef><apiDesc>
   本地磁盘上文件的上一次修改日期。如果未填充 FileReference 对象，则为获得此属性的值而执行的调用将返回 <codeph>null</codeph>。
   
   </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:name:get"><apiName>name</apiName><shortdesc>
   本地磁盘上的文件的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
   </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>若 <codeph>FileReference.browse()</codeph>、<codeph>FileReferenceList.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法未能成功调用，将引发异常，同时显示一条信息，指出函数的调用顺序不正确或先前调用未成功。
   
   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>作为 String 获取文件的名称。
   </apiTipText></apiTipTexts></apiValueDef><apiDesc>
   本地磁盘上的文件的名称。如果未填充 FileReference 对象（通过对 <codeph>FileReference.download()</codeph> 或 <codeph>FileReference.browse()</codeph> 的有效调用），则在尝试获取此属性的值时，Flash Player 将引发错误。
   <p>FileReference 对象的所有属性都通过调用 <codeph>browse()</codeph> 方法进行填充。与其它 FileReference 属性不同，如果调用 <codeph>download()</codeph> 方法，则在分派 <codeph>select</codeph> 事件时将填充 <codeph>name</codeph> 属性。</p>
   
   </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:size:get"><apiName>size</apiName><shortdesc>
  本地磁盘上文件的大小（以字节为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><refpath>
  </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>若 <codeph>FileReference.browse()</codeph>、<codeph>FileReferenceList.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法未能成功调用，将引发异常，同时显示一条信息，指出函数的调用顺序不正确或先前调用未成功。
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>若无法打开或读取文件，或者在访问文件时遇到类似错误，将引发异常，同时显示一条信息，指明发生文件 I/O 错误。
  
  </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>文件的大小，以字节为单位。
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  本地磁盘上文件的大小（以字节为单位）。<ph platform="actionscript">如果 <codeph>size</codeph> 为 0，将引发异常。</ph>
  
  <p platform="actionscript"><i>注意：</i>在 ActionScript 3.0 的初始版本中，<codeph>size</codeph> 属性定义为 uint 对象，该对象支持大小达 4 GB 的文件。现在，它以 Number 对象的形式实现，以支持更大的文件。 </p>
  
  </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:type:get"><apiName>type</apiName><shortdesc>
  文件类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>type, FileReference.type
  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>若 <codeph>FileReference.browse()</codeph>、<codeph>FileReferenceList.browse()</codeph> 或 <codeph>FileReference.download()</codeph> 方法未能成功调用，将引发异常，同时显示一条信息，指出函数的调用顺序不正确或先前调用未成功。此时，<codeph>type</codeph> 属性的值为 <codeph>null</codeph>。
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>获取文件的类型或扩展名。
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  文件类型。 
  
  <p>在 Windows 或 Linux 上，此属性是文件扩展名。在 Macintosh 上，此属性是由四个字符组成的文件类型，仅用于 Mac OS X 之前的 Mac OS 版本中。如果未填充 FileReference 对象，则为获取此属性的值而执行的调用将返回 <codeph>null</codeph>。</p>
    
	<p>对于 Windows、Linux 和 Mac OS X，文件扩展名 — <codeph>name</codeph> 属性最后一个句点 (.) 字符后的部分character — 标识文件类型。</p>
	
  
  </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/extension"><linktext>FileReference.extension</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:SharedObjectFlushStatus"><apiName>SharedObjectFlushStatus</apiName><shortdesc>
 SharedObjectFlushStatus 类为通过调用 SharedObject.flush() 方法而返回的代码提供了值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 SharedObjectFlushStatus 类为通过调用 <codeph>SharedObject.flush()</codeph> 方法而返回的代码提供了值。
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links><apiValue id="flash.net:SharedObjectFlushStatus:FLUSHED"><apiName>FLUSHED</apiName><shortdesc>
 指示成功完成了刷新。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>flushed</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 指示成功完成了刷新。
 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObjectFlushStatus:PENDING"><apiName>PENDING</apiName><shortdesc>
 指示在可以刷新之前，提示用户增加共享对象的磁盘空间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pending</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 指示在可以刷新之前，提示用户增加共享对象的磁盘空间。
 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:URLRequest"><apiName>URLRequest</apiName><shortdesc>
  URLRequest 类可捕获单个 HTTP 请求中的所有信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The above include is not a mistake, but rather code re-use.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  URLRequest 类可捕获单个 HTTP 请求中的所有信息。URLRequest 对象将传递给 Loader、URLStream 和 URLLoader 类的 <codeph>load()</codeph> 方法和其它加载操作，以便启动 URL 下载。这些对象还将传递给 FileReference 类的 <codeph>upload()</codeph> 和 <codeph>download()</codeph> 方法。
 
  <p platform="actionscript">只能与本地文件系统内容交互的沙箱中的 SWF 文件无法加载网络沙箱中的资源所包含的数据，也无法为该资源提供数据。 </p>
 
  <p>默认情况下，执行调用的 <ph platform="actionscript">SWF</ph> 文件和加载的 URL 必须在同一域中。例如，位于 www.adobe.com 的 <ph platform="actionscript">SWF</ph> 文件只能从同样位于 www.adobe.com 的源中加载数据。<ph platform="actionscript">要从不同的域中加载数据，请在承载数据的服务器上放置一个 URL 策略文件。</ph></p>
 
  <p> 但在 Adobe AIR 中，应用程序安全沙箱中的内容（与 AIR 应用程序一起安装的内容）不受这些安全限制的约束。对于在 Adobe AIR 中运行的内容，应用程序安全沙箱中的文件可以访问使用以下任一 URL 方案的 URL：</p>

  <p platform="javascript"> 应用程序安全域中的文件（随 AIR 应用程序一起安装的文件），可以使用以下任一 URL 方案访问 URL：</p>
 
 <ul>
 
  <li><codeph>http</codeph> 和 <codeph>https</codeph> </li>
 
  <li><codeph>file</codeph> </li>
 
  <li><codeph>app-storage</codeph> </li>
 
  <li><codeph>app</codeph> </li>
 
 </ul>
 
  <p><ph platform="actionscript">在 Adobe AIR 中运行</ph>且不在应用程序安全沙箱中的内容与在浏览器<ph platform="actionscript">（在 Flash Player 中）</ph>中运行的内容遵循相同的限制，加载操作受内容的域<ph platform="actionscript">和 URL 策略文件中授予的任何权限控制</ph>。</p>
 
 <p>有关安全性的详细信息，请参阅以下部分：</p>
 
 <ul>
 
 <li product="flex">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 <li product="flash">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 
 <li><i>Developing AIR Applications</i>（《开发 AIR 应用程序》）一书的“Getting started with Adobe AIR”（Adobe AIR 入门）一章中的“Understanding AIR Security”（了解 AIR 安全性）一节。</li>
 
  <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
 </ul>
 
 </apiDesc><example conref="examples\URLRequestExample.as"> 下例创建一个新的 Loader 对象，并为其传递一个包含 XML 文件路径的 URLRequest 对象。如果加载操作成功，将分派 <codeph>complete</codeph> 事件，并且 XML 文件中的数据会跟踪至输出。附加的事件处理函数会捕获其它事件，包括错误事件。
 <p>要运行该示例，请将名为 XMLFile.xml 的文件与 SWF 文件放在同一个目录下。</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLRequestExample extends Sprite {

        public function URLRequestExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("XMLFile.xml");
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link><link href="flash.net.xml#URLRequestDefaults"><linktext>URLRequestDefaults</linktext></link><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>HTMLLoader 类</linktext></link></related-links><apiConstructor id="flash.net:URLRequest:URLRequest"><apiName>URLRequest</apiName><shortdesc>
     创建 URLRequest 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>所请求的 URL。随后可以使用 <codeph>url</codeph> 属性来设置 URL。
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建 URLRequest 对象。如果 <codeph>System.useCodePage</codeph> 为 <codeph>true</codeph>，则使用系统代码页对该请求进行编码，而不使用 Unicode。如果 <codeph>System.useCodePage</codeph> 为 <codeph>false</codeph>，则使用 Unicode 对该请求进行编码，而不使用系统代码页。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.system.xml#System/useCodePage"><linktext>flash.system.System.useCodePage</linktext></link></related-links></apiConstructor><apiValue id="flash.net:URLRequest:authenticate:get"><apiName>authenticate</apiName><shortdesc>
	指定是否应为此请求处理验证请求，如果是，则为 true，否则为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	指定是否应为此请求处理身份验证请求，如果是，则为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。如果为 <codeph>false</codeph>，则验证挑战返回 HTTP 错误。  
	
	<p>支持的身份验证方法有：</p>
    
	<ul>
	
		<li>Windows — HTTP 基本/摘要、Windows 集成式身份验证（包括 NTLM 和 Kerberos）、SSL 证书身份验证。</li>
    
		<li>Mac — HTTP 基本/摘要、NTLM、SSL 证书身份验证。</li>
	
	</ul>
	
	<p><b>注意</b>：<codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph> 和 <codeph>HTMLLoader.load()</codeph> 方法不支持 <codeph>URLRequest.authenticate</codeph> 属性。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/authenticate"><linktext>flash.net.URLRequestDefaults.authenticate</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:cacheResponse:get"><apiName>cacheResponse</apiName><shortdesc>
	指定是否应为此请求缓存成功的响应数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	指定是否应为此请求缓存成功的响应数据。设置为 <codeph>true</codeph> 时，AIR 应用程序将使用操作系统的 HTTP 缓存。
	
	<p><b>注意</b>：<codeph>HTMLLoader.load()</codeph> 方法不支持 <codeph>URLRequest.cacheResponse</codeph> 属性。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/cacheResponse"><linktext>flash.net.URLRequestDefaults.cacheResponse</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:contentType:get"><apiName>contentType</apiName><shortdesc>
     data 属性中内容的 MIME 内容类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     <codeph>data</codeph> 属性中内容的 MIME 内容类型。
     
     <p>默认值为 <codeph>application/x-www-form-urlencoded</codeph>。</p>
     
     <p><b>注意：</b><codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph> 和 <codeph>HTMLLoader.load()</codeph> 方法不支持 <codeph>URLRequest.contentType</codeph> 属性。</p>
     
     <p>发送 POST 请求时，<codeph>contentType</codeph> 和 <codeph>data</codeph> 属性的值必须正确对应。<codeph>contentType</codeph> 属性的值指示服务器如何解释 <codeph>data</codeph> 属性的值。 </p>
     
     <ul> 
     <li>如果 <codeph>data</codeph> 属性的值是一个 URLVariables 对象，则 <codeph>contentType</codeph> 的值必须是 <codeph>application/x-www-form-urlencoded</codeph>。 </li>
     
     <li> 如果 <codeph>data</codeph> 属性的值为其它类型，则 <codeph>contentType</codeph> 的值应指示将要发送的 POST 数据的类型（该数据为 <codeph>data</codeph> 属性的值中包含的二进制或字符串数据）。 </li>
     
     <li>对于 <codeph>FileReference.upload()</codeph>，请求的内容类型将自动设置为 <codeph>multipart/form-data</codeph> 并忽略 <codeph>contentType</codeph> 属性的值。</li>
     </ul>
     
     <p> 在 Flash Player 10 和更高版本中，如果使用包含上载（由 POST 体内的“content-disposition”标头中的“filename”参数表示）的 multipart Content-Type（例如“multipart/form-data”），则 POST 操作会受应用于上载的安全规则的约束：</p>
	 <ul>
	 <li>必须执行 POST 操作以响应用户启动的操作（如鼠标单击或按键）。</li>
	 <li>如果 POST 操作是跨域的（POST 目标与发送 POST 请求的 SWF 文件不在同一台服务器上），则目标服务器必须提供一个允许跨域访问的 URL 策略文件。</li>
	 </ul>
     <p>另外，对于任何 multipart Content-Type，语法必须有效（根据 RFC2046 标准）。如果语法无效，则 POST 操作受应用于上载的安全规则约束。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/data"><linktext>data</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:data:get"><apiName>data</apiName><shortdesc>
     一个对象，它包含将随 URL 请求一起传输的数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     一个对象，它包含将随 URL 请求一起传输的数据。 
     
     <p>该属性与 <codeph>method</codeph> 属性配合使用。当 <codeph>method</codeph> 值为 <codeph>GET</codeph> 时，将使用 HTTP 查询字符串语法将 <codeph>data</codeph> 值追加到 <codeph>URLRequest.url</codeph> 值。当 <codeph>method</codeph> 值为 <codeph>POST</codeph>（或 <codeph>GET</codeph> 之外的任何值）时，将在 HTTP 请求体中传输 <codeph>data</codeph> 值。</p>
     
     <p>URLRequest API 支持二进制 <codeph>POST</codeph>，并支持 URL 编码变量和字符串。该数据对象可以是 ByteArray、URLVariables 或 String 对象。</p>
     
     <p>该数据的使用方式取决于所用对象的类型：</p>
     
     <ul>
     
         <li>如果该对象为 ByteArray 对象，则 ByteArray 对象的二进制数据用作 <codeph>POST</codeph> 数据。对于 <codeph>GET</codeph>，不支持 ByteArray 类型的数据。对于 <codeph>FileReference.upload()</codeph> 和 <codeph>FileReference.download()</codeph>，也不支持 ByteArray 类型的数据。</li>
     
         <li>如果该对象是 URLVariables 对象，并且该方法是 <codeph>POST</codeph>，则使用 <i>x-www-form-urlencoded</i> 格式对变量进行编码，并且生成的字符串会用作 <codeph>POST</codeph> 数据。一种例外情况是对 <codeph>FileReference.upload()</codeph> 的调用，在该调用中变量将作为 <codeph>multipart/form-data</codeph> 发布中的单独字段进行发送。</li>
     
      <li>如果该对象是 URLVariables 对象，并且该方法是 <codeph>GET</codeph>，则 URLVariables 对象将定义要随 URLRequest 对象一起发送的变量。</li>
     
         <li>否则，该对象会转换为字符串，并且该字符串会用作 <codeph>POST</codeph> 或 <codeph>GET</codeph> 数据。</li>
     
     </ul>
     
     <p>在方法（如 <codeph>navigateToURL()</codeph> 或 <codeph>FileReference.upload()</codeph>）使用 URLRequest 对象前，不会发送该数据。</p>
     
     <p><b>注意</b>：<codeph>contentType</codeph> 值必须与 <codeph>data</codeph> 属性中的数据类型对应。请参阅 <codeph>contentType</codeph> 属性说明中的注释。</p>
     
     </apiDesc><example conref="examples\URLVariablesExample.as"> 下例在一个新的浏览器窗口中打开位于 http://www.[yourDomain].com/application.jsp 上的远程应用程序，并将 URLVariables 对象中捕获的有关用户会话的数据传递给该应用程序。 
  
 <p>该示例的要点遵循：</p>
 <ol>
    <li>构造函数会创建名为 <codeph>request</codeph> 的 URLRequest 实例，同时将远程应用程序的 URL 作为参数。</li>
    <li>创建了一个 URLVariables 对象，并对它的两个属性进行了赋值。</li>
    <li>URLVariables 对象被赋给了 URLRequest 对象的 <codeph>data</codeph> 属性。</li>
    <li>该示例调用 <codeph>navigateToURL</codeph>，在一个新的浏览器窗口中打开远程应用程序的 URL。</li>
 </ol>
 <p> <b>注意：</b>要运行该示例，必须将该示例中的远程应用程序 URL 替换为工作 URL。此外，需要用服务器代码处理 Flash Player 在 URLVariables 对象中捕获的信息。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class URLVariablesExample extends Sprite {

        public function URLVariablesExample() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/method"><linktext>URLRequest.method</linktext></link><link href="flash.net.xml#URLRequestMethod"><linktext>URLRequestMethod</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.net.xml#URLRequest/contentType"><linktext>contentType</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:digest:set"><apiName>digest</apiName><shortdesc>
     唯一地标识将存储到 Flash Player 缓存中（或从中检索）的已签名 Adobe 平台组件的字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>提供的摘要与从下载的签名文件或从缓存中加载的签名文件中提取的文件摘要不匹配。如果提供的摘要长度错误或包含无效（非十六进制）字符，则应用程序也会引发此错误。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     唯一地标识将存储到 Flash Player 缓存中（或从中检索）的已签名 Adobe 平台组件的字符串。<ph platform="actionscript">Adobe 平台组件是一个签名文件（SWZ 文件），其中包含永久缓存在用户计算机上的 SWF 内容。Adobe 对所有 SWZ 进行签名。摘要对应于单个缓存文件；如果对该文件进行了任何更改，则其摘要的更改将以不可预知的方式进行。通过使用摘要，您可以跨多个域验证缓存文件。具有相同摘要的两个文件是同一个文件，具有不同摘要的两个文件是不同的文件。实际上无法创建文件来“窃听”摘要以假装是另一个摘要。</ph><ph platform="javascript">此属性仅适用于 SWF 内容，不适用于在 AIR 中运行的 JavaScript 代码。</ph>
     
     <p platform="actionscript">摘要基于 SHA-256 消息摘要算法（长度为 64 个字符，采用十六进制格式）。</p>
     
     <p platform="actionscript">例如，Flex SDK 包括 Flex 框架的 SWZ（而且它为该 SWZ 文件提供了摘要字符串）。可以将此 SWZ 发布到您的 Web 服务器上并加载到 SWF 文件中（使用 URLLoader 对象的 <codeph>load()</codeph> 方法）。如果最终用户的计算机已缓存了匹配的 SWZ 文件，则应用程序将使用此缓存的 SWZ 文件。（SWZ 文件在其 <codeph>digest</codeph> 与您提供的摘要匹配时匹配。）否则，应用程序将从您指定的 URL 下载 SWZ 文件。 </p>
     
     <p platform="actionscript">仅在 <codeph>URLLoader.load()</codeph> 方法调用中使用的 URLRequest 对象中设置 <codeph>digest</codeph> 参数即可加载 SWZ 文件。如果 URLRequest 对象的 <codeph>digest</codeph> 属性在用于其它方法时进行了设置，则应用程序将引发 IOError 异常。</p>
     
     </apiDesc><example conref="examples\URLRequest_digest.as"> 下面的示例将远程文件加载到缓存中。加载结束时，字节数组包含实际的文件（而不是签名的文件）。该示例通过调用 <codeph>loadBytes()</codeph> 完成加载操作：
<codeblock>
 
var myURLReq:URLRequest = new URLRequest();
myURLReq.url = "http://yourdomain/users/jdoe/test01/_rsc/Automated/AssetCaching_rsc/test01/rsl.swz";
myURLReq.digest = "3B0AA28C7A990385E044D80F5637FB036317BB41E044D80F5637FB036317BB41";
var myURLLoader:URLLoader = new URLLoader();
myURLLoader.dataFormat = URLLoaderDataFormat.BINARY;
myURLLoader.addEventListener("complete", onC);

myURLLoad.load(myURLReq);

function onC(e) {
    var someLoader:Loader = new Loader();
    addChild(someLoader);
    someLoader.loadBytes((ByteArray)(myURLLoad.data)); 
}

</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.net:URLRequest:followRedirects:get"><apiName>followRedirects</apiName><shortdesc>
	指定是否要遵循重定向，如果是，则为 true，否则为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	指定是否要遵循重定向，如果是，则为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。 
	
	<p><b>注意</b>：<codeph>FileReference.upload()</codeph>、<codeph>FileReference.download()</codeph> 和 <codeph>HTMLLoader.load()</codeph> 方法不支持 <codeph>URLRequest.followRedirects</codeph> 属性。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/followRedirects"><linktext>URLRequestDefaults.followRedirects</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:manageCookies:get"><apiName>manageCookies</apiName><shortdesc>
	指定 HTTP 协议堆栈是否应管理此请求的 cookie。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true 
	
	</apiDefaultValue></apiValueDef><apiDesc>
	指定 HTTP 协议堆栈是否应管理此请求的 cookie。如果为 <codeph>true</codeph>，则将 cookie 添加到请求中并记住响应 cookie。如果为 <codeph>false</codeph>，则<i>不</i> 将 cookie 添加到请求中且<i>不</i> 记住响应 cookie，但用户可以通过直接处理标头来自行管理 cookie。 
	
	<p>在 Mac OS 上，cookie 与 Safari 共享。清除 Mac OS 上的 cookie：</p>
	
	<ol>
		<li>打开 Safari。</li>
      <li>选择“Safari”>“首选参数”，然后单击“安全”面板。</li>
      <li>单击“显示 Cookie”按钮。</li>
		<li>单击“全部删除”按钮。</li>
	</ol>
	
	<p>清除 Windows 上的 cookie：</p>
	
	<ol>
		<li>打开“Internet 属性”控制面板并单击“常规”选项卡。</li>
		<li>单击“删除 Cookie”按钮。 </li>
	</ol>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/manageCookies"><linktext>flash.net.URLRequestDefaults.manageCookies</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:method:get"><apiName>method</apiName><shortdesc>
     控制 HTTP 式提交方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>如果 <codeph>value</codeph> 参数不是 <codeph>URLRequestMethod.GET</codeph> 或 <codeph>URLRequestMethod.POST</codeph>。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>URLRequestMethod.GET
     
     </apiDefaultValue></apiValueDef><apiDesc>
     控制 HTTP 式提交方法。 
     
     <p><ph platform="actionscript">对于在 Flash Player 中（在浏览器中）运行的 SWF 内容，此属性限制为 GET 或 POST 操作，有效值为 <codeph>URLRequestMethod.GET</codeph> 或 <codeph>URLRequestMethod.POST</codeph>。</ph></p>
     
     <p><ph platform="actionscript">对于在 Adobe AIR 中运行的内容，如果该内容位于应用程序安全沙箱内，</ph><ph platform="javascript"/>则可以使用任何字符串值。否则，<ph platform="actionscript">与在 Flash Player 中运行的内容一样，</ph>仅能使用 GET 或 POST 操作<ph platform="javascript">，有效值为 <codeph>URLRequestMethod.GET</codeph> 或 <codeph>URLRequestMethod.POST</codeph></ph>。</p>
     
     <p><ph platform="actionscript">对于在 Adobe AIR 中运行的内容，</ph><ph platform="javascript">当</ph>使用 <codeph>navigateToURL()</codeph> 函数时，运行时将使用 POST 方法的 URLRequest（其 <codeph>method</codeph> 属性设置为 <codeph>URLRequestMethod.POST</codeph>）视为使用 GET 方法。</p>
     
     <p><ph platform="actionscript"><b>注意：</b>如果在 Flash Player 中运行并且引用的表单没有正文，则即使将方法设置为 <codeph>URLRequestMethod.POST</codeph>，Flash Player 也会自动使用 GET 操作。因此，建议始终包括“虚拟”正文以确保使用正确的 method。</ph></p>
     
     </apiDesc><example conref="examples\URLRequest_method.as"> 下例在一个新的浏览器窗口中打开位于 http://www.[yourDomain].com/application.jsp 上的远程应用程序，并将 URLVariables 对象中捕获的有关用户会话的数据传递给该应用程序。它将 <codeph>URLRequest.method</codeph> 属性值显式设置为 <codeph>URLRequestMethod.POST</codeph>。
 <p>该示例的要点遵循：</p>
 <ol>
    <li>构造函数会创建名为 <codeph>request</codeph> 的 URLRequest 实例，同时将远程应用程序的 URL 作为参数。</li>
    <li>创建了一个 URLVariables 对象，并对它的两个属性进行了赋值。</li>
    <li>URLVariables 对象被赋给了 URLRequest 对象的 <codeph>data</codeph> 属性。</li>
  <li><codeph>URLRequest.method</codeph> 属性的值设置为 <codeph>URLRequestMethod.POST</codeph>。</li>
    <li>该示例调用 <codeph>navigateToURL</codeph>，在一个新的浏览器窗口中打开远程应用程序的 URL。</li>
 </ol>
 <p> <b>注意：</b>要运行该示例，必须将该示例中的远程应用程序 URL 替换为工作 URL。此外，需要用服务器代码处理 Flash Player 在 URLVariables 对象中捕获的信息。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLRequestMethod;
    import flash.net.URLVariables;

    public class URLRequest_method extends Sprite {

        public function URLRequest_method() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            request.method = URLRequestMethod.POST;
            
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.net.xml#URLRequestMethod"><linktext>URLRequestMethod 类</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:requestHeaders:get"><apiName>requestHeaders</apiName><shortdesc>
     要追加到 HTTP 请求的 HTTP 请求标头的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     要追加到 HTTP 请求的 HTTP 请求标头的数组。该数组由 URLRequestHeader 对象组成。数组中的每一对象必须是包含一个名称字符串和一个值字符串的 URLRequestHeader 对象，如下所示： 
     <codeblock>
     var rhArray:Array = new Array(new URLRequestHeader("Content-Type", "text/html"));
     </codeblock>
     
     <p><ph platform="actionscript">Flash Player 和 AIR 运行时对请求标头强加</ph><ph platform="javascript">AIR 运行时对请求标头强加</ph>某些限制；有关详细信息，请参阅 URLRequestHeader 类的描述。</p>
     
     <p>并非所有接受 URLRequest 参数的方法都支持 <codeph>requestHeaders</codeph> 属性，请参阅有关调用的方法的文档。例如，<codeph>FileReference.upload()</codeph> 和 <codeph>FileReference.download()</codeph> 方法不支持 <codeph>URLRequest.requestHeaders</codeph> 属性。</p>
     <p>由于存在浏览器限制，因此仅对 <codeph>POST</codeph> 请求支持自定义 HTTP 请求标头，而对 <codeph>GET</codeph> 请求不提供相应支持。</p> 
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:url:get"><apiName>url</apiName><shortdesc>
     所请求的 URL。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     所请求的 URL。 
     
     <p>确保对统一资源定位器规范（请参阅 http://www.faqs.org/rfcs/rfc1738.html）中说明为不安全的字符或 URLRequest 对象的 URL 架构中保留的字符（如果未用于其保留用途）进行编码。例如，按照 <codeph>"http://www.example.com/orderForm.cfm?item=%23B-3&amp;discount=50%25"</codeph> 的规定，对百分比符号 (%) 使用 <codeph>"%25"</codeph>，对数字符号 (#) 使用 <codeph>"%23"</codeph>。</p>
     
      <p>默认情况下，除非内容在 <ph platform="actionscript">Adobe AIR </ph>应用程序安全沙箱中运行，否则 URL 必须与执行调用的文件位于同一域中。<ph platform="actionscript">要从其它域中加载数据，请在承载数据的服务器上放置一个 URL 策略文件</ph>。有关详细信息，请参阅 URLRequest 类的说明。</p>
     
     <p><ph platform="actionscript">对于在 Adobe AIR 中运行的内容，应用程序安全沙箱中的文件</ph><ph platform="javascript"/>（使用 AIR 应用程序安装的文件）可以使用以下任一 URL 方案访问 URL：</p>
     
     <ul>
     
      <li><codeph>http</codeph> 和 <codeph>https</codeph> </li>
     
      <li><codeph>file</codeph> </li>
     
      <li><codeph>app-storage</codeph> </li>
     
      <li><codeph>app</codeph> </li>
     
     </ul>
     
     <p><b>注意：</b>AIR 和 Flash Player 9.0.115.0 及更高版本中支持 IPv6（Internet 协议版本 6）<ph platform="actionscript"/>。IPv6 是支持 128 位地址的 Internet 协议版本（它是支持 32 位地址的早期 IPv4 协议的改进版本）。您可能需要在网络接口中激活 IPv6。有关详细信息，请参阅承载数据的操作系统的帮助。<ph platform="actionscript">如果承载系统上支持 IPv6，则可以在用方括号 ([]) 括起的 URL 中指定数字 IPv6 文本地址，如下所示</ph>。 </p>
     
     <ph platform="actionscript">
     <pre>
     rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]:1935/test
     </pre>
     </ph>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequest:useCache:get"><apiName>useCache</apiName><shortdesc>
	指定在此 URLRequest 获取数据之前是否应查询本地缓存。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	指定在此 URLRequest 获取数据之前是否应查询本地缓存。 
	
	<p><b>注意</b>：<codeph>HTMLLoader.load()</codeph> 方法不支持 <codeph>URLRequest.useCache</codeph> 属性。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/useCache"><linktext>flash.net.URLRequestDefaults.useCache</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:userAgent:get"><apiName>userAgent</apiName><shortdesc>
	指定要在 HTTP 请求中使用的用户代理字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>调用方不在 AIR 应用程序安全沙箱中。
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	指定要在 HTTP 请求中使用的用户代理字符串。 
	
	<p platform="actionscript">默认值是由 Flash Player 使用的同一用户代理字符串，该字符串在 Mac、Linux 和 Windows 中有所不同。</p>
	
	<p><i>注意：</i>在将 URLRequest 对象与 HTMLLoader 对象的 <codeph>load()</codeph> 方法一起使用时，此属性不影响用户代理字符串。要设置 HTMLLoader 对象的用户代理字符串，请设置 HTMLLoader 对象的 <codeph>userAgent</codeph> 属性或设置静态 <codeph>URLRequestDefaults.userAgent</codeph> 属性。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/userAgent"><linktext>flash.net.URLRequestDefaults.userAgent</linktext></link><link href="../../flash/html/HTMLLoader.html#userAgent"><linktext>flash.html.HTMLLoader.userAgent</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:FileFilter"><apiName>FileFilter</apiName><shortdesc>
 FileFilter 类用于指示在调用 FileReference.browse() 方法、FileReferenceList.browse() 方法或调用 File、FileReference 或 FileReferenceList 对象的 browse 方法时显示的文件浏览对话框中显示用户系统上的哪些文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 FileFilter 类用于指示在调用 <codeph>FileReference.browse()</codeph> 方法、<codeph>FileReferenceList.browse()</codeph> 方法或调用 File、FileReference 或 FileReferenceList 对象的 browse 方法时显示的文件浏览对话框中显示用户系统上的哪些文件。FileFilter 实例作为可选 <codeph>typeFilter</codeph> 参数的值传递给该方法。如果使用 FileFilter 实例，则会滤除 FileFilter 实例中未指定的扩展名和文件类型，即用户无法选择这些类型。如果未向方法传递任何 FileFilter 对象，则对话框中将显示所有文件。
 
 <p>可以采用以下两种方式之一使用 FileFilter 实例：</p>
 
 <ul>
 
   <li>仅包含文件扩展名的描述</li>
 
   <li>包含文件扩展名和 Macintosh 文件类型的描述</li>
 
 </ul>
 
 <p>这两种格式不能在一个 browse 方法调用中互换。必须使用其中一种格式。</p>
 
 <p>可以向 browse 方法传递一个或多个 FileFilter 实例，如下所示：</p>
 
 <codeblock platform="actionscript">
 var imagesFilter:FileFilter = new FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter:FileFilter = new FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFileReference:FileReference = new FileReference();
 myFileReference.browse([imagesFilter, docFilter]);
 </codeblock>
 
 <p platform="actionscript">或者在 AIR 应用程序中：</p>
 
 <codeblock platform="actionscript">
 var imagesFilter:FileFilter = new FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter:FileFilter = new FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFile:File = new File();
 myFile.browseForOpen("Open", [imagesFilter, docFilter]);
 </codeblock>
 
 <codeblock platform="javascript">
 var imagesFilter = new air.FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter = new air.FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFile = new air.File();
 myFile.browseForOpen("Open", [imagesFilter, docFilter]);
 </codeblock>
 
 <p><codeph>FileFilter.extension</codeph> 属性中的扩展名列表用于筛选文件浏览对话框中显示的文件。该列表实际并不显示在对话框中；要对用户显示文件类型，必须在描述字符串以及扩展名列表中列出文件类型。在 Windows 和 Linux 中，描述字符串显示在对话框中。（在 Macintosh<sup>®</sup> 中不使用该列表。）在 Macintosh 上，如果提供 Macintosh 文件类型的列表，则该列表用于过滤文件。如果未提供，则使用文件扩展名列表。 </p> 
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:FileFilter:FileFilter"><apiName>FileFilter</apiName><shortdesc>
	 创建一个新的 FileFilter 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>description</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>用户选择要上载的文件时可以看到的描述字符串。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>文件扩展名列表，其中列出用户选择要上载的文件时可以看到的文件格式。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>macType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Macintosh 文件类型列表，其中列出用户选择要上载的文件时可以看到的文件类型。如果不传递任何值，则将此参数设为 <codeph>null</codeph>。
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 FileFilter 实例。
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.net:FileFilter:description:get"><apiName>description</apiName><shortdesc>
	 滤镜的描述字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 滤镜的描述字符串。调用 <codeph>FileReference.browse()</codeph> 或 <codeph>FileReferenceList.browse()</codeph> 时，用户将在打开的对话框中看到此描述。描述字符串包含诸如 <codeph>"Images (~~.gif, ~~.jpg, ~~.png)"</codeph> 之类的字符串，这些字符串有助于用户辨认可以上载或下载的文件类型。请注意，此 FileReference 对象支持的实际文件类型存储在 <codeph>extension</codeph> 属性中。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileFilter:extension:get"><apiName>extension</apiName><shortdesc>
	 一个文件扩展名列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 一个文件扩展名列表。此列表指示要在文件浏览对话框中显示的文件的类型。（用户看不到此列表，只能看到 <codeph>description</codeph> 属性值。） <codeph>extension</codeph> 属性包含以分号分隔的文件扩展名列表，其中每个扩展名之前都具有通配符 (~~)，如下面的字符串所示：<codeph>"~~.jpg;~~.gif;~~.png"</codeph>。
	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileFilter:macType:get"><apiName>macType</apiName><shortdesc>
	 一个 Macintosh 文件类型列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 一个 Macintosh 文件类型列表。此列表指示要在文件浏览对话框中显示的文件的类型。（用户看不到此列表，只能看到 <codeph>description</codeph> 属性值。） <codeph>macType</codeph> 属性包含以分号分隔的 Macintosh 文件类型列表，如下面的字符串所示：<codeph>"JPEG;jp2_;GIFF"</codeph>。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStream"><apiName>NetStream</apiName><shortdesc>
 NetStream 类在 AIR 或 Flash Player 应用程序与 Flash Media Server 之间或在 AIR 或 Flash Player 应用程序与本地文件系统之间打开单向流连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 NetStream 类在 AIR <ph platform="actionscript">或 Flash Player</ph> 应用程序与 Flash Media Server 之间或在 AIR <ph platform="actionscript">或 Flash Player</ph> 应用程序与本地文件系统之间打开单向流连接。NetStream 对象是 NetConnection 对象中的一个通道。此通道可以使用 <codeph>NetStream.publish()</codeph> 发布流，也可以使用 <codeph>NetStream.play()</codeph> 订阅发布的流并接收数据。您可以发布或播放实时数据及先前录制的数据。您还可以调用 <codeph>NetStream.send()</codeph> 方法向所有已订阅的客户端发送文本消息。
 
 <p platform="actionscript">与在 SWF 文件中嵌入视频相比，播放外部视频文件有很多好处，例如，更好的性能和内存管理以及独立的视频和 SWF 帧速率。 </p>
 
 <p>Adobe AIR 和 Flash Player 9.0.115.0 _cn 和更高版本支持从标准 MPEG-4 容器格式（包括 F4V、MP4、M4A、MOV、MP4V、3GP 和 3G2）中派生的文件（如果文件包含 H.264 视频和/或 HEAAC v2 编码音频）。与 Sorenson 或 On2 中同样的编码配置文件相比，H.264 可以在更低的位速率下传送更高品质的视频。HE-AAC v2 是 AAC（在 MPEG-4 视频标准中定义的一种标准音频格式）的扩展，它使用频带复制 (SBR) 和参量立体声 (PS) 技术在低位速率下提高编码效率。有关支持的编解码器和文件格式的信息，请参阅 <xref href="http://www.adobe.com/go/hardware_scaling_cn" scope="external">http://www.adobe.com/go/hardware_scaling_cn</xref> 和 <xref href="http://www.adobe.com/go/learn_fms_fileformats_cn" scope="external">www.adobe.com/go/learn_fms_fileformats_cn</xref>。</p>
 
 <p><b>发布和播放流的工作流程：</b></p>
 
 <ol>
 <li>创建一个 NetConnection 对象。</li>
 <li>调用 <codeph>NetConnection.connect()</codeph> 方法，连接到服务器上的应用程序实例。</li>
 <li>创建 NetStream 对象，在连接中创建流。</li>
 <li>要捕获、编码和发布音频和视频，请调用 <codeph>NetStream.attachAudio()</codeph> 方法和 <codeph>NetStream.attachCamera()</codeph> 方法。</li>
 <li>调用 <codeph>NetStream.publish()</codeph> 方法为流指定唯一的名称，然后通过流将数据发送到服务器，以使其他用户能够收到数据。您还可以在发布数据时进行录制，以便用户可以在日后回放该数据。</li>
 <li>调用 <codeph>NetStream.play()</codeph> 方法，播放实时流或录制的流。将传递给 <codeph>publish()</codeph> 方法的字符串的名称传递给 <codeph>play()</codeph> 方法。</li>
 </ol>
 
 <p><b>将数据关键帧用于 Flash Media Server：</b>创建 NetConnection 和 NetStream 对象后，您可以在将实时音频或视频流式传输到服务器时，使用 <codeph>NetStream.send()</codeph> 向实时音频或视频中添加元数据。元数据可以是如下信息：视频高度或宽度、其持续时间、其创建者的姓名等。要定义元数据，请使用特殊的处理函数名称 <codeph>@setDataFrame</codeph> 作为 <codeph>NetStream.send()</codeph> 的第一个参数。</p>
 
 <p><b>从 Flash Media Server 流、渐进式 F4V 文件或渐进式 FLV 文件中接收数据：</b>Flash Media Server、F4V 文件和 FLV 文件可以在流处理或播放过程中发送包含特定数据点上的数据的事件对象。您可以使用两种方法在回放过程中从流或 FLV 文件中处理数据：</p>
 
 <ul><li>将客户端属性与事件处理函数相关联以接收数据对象。使用 <codeph>NetStream.client</codeph> 属性分配对象以调用特定的数据处理函数。分配给 <codeph>NetStream.client</codeph> 属性的对象可以侦听以下数据点：<codeph>onCuePoint()</codeph>、<codeph>onImageData()</codeph>、<codeph>onMetaData()</codeph>、<codeph>onPlayStatus()</codeph>、<codeph>onTextData()</codeph> 和 <codeph>onXMPData()</codeph>。然后在这些函数内编写过程，以处理在回放过程中从流或 FLV 文件中返回的数据对象。有关详细信息，请参阅 <codeph>NetStream.client</codeph> 属性。</li>
 <li>将客户端属性与 NetStream 类的子类相关联，然后编写事件处理函数以接收数据对象。NetStream 是一个密封类，即无法在运行时将属性或方法添加到 NetStream 对象。然而，您可以创建 NetStream 的子类并在其中定义您的事件处理函数，或者将该子类变为动态的并对子类的实例添加事件处理函数。</li></ul>
 
 <p><b>注意：</b>要通过音频文件（如 MP3 文件）发送数据，请使用 Sound 类将音频文件与 Sound 对象关联起来。然后使用 <codeph>Sound.id3</codeph> 属性读取声音文件中的元数据。</p>
 
 </apiDesc><example conref="examples\NetConnectionExample.as"> 以下示例将 Video 对象与 NetConnection 和 NetStream 类一同使用，以加载和播放 FLV 文件。为了运行此示例，需要一个 FLV 文件，其名称和位置与传递给 <codeph>videoURL</codeph> 的变量匹配，在本例中，名为 Video.flv 的 FLV 文件与 SWF 文件在同一个目录中。
 <p>在本例中，创建 Video 和 NetStream 对象并调用 <codeph>Video.attachNetStream()</codeph> 和 <codeph>NetStream.play()</codeph> 方法的代码放在处理函数中。仅当连接到 NetConnection 对象的尝试取得成功时才调用处理函数，即，当 <codeph>netStatus</codeph> 事件返回 <codeph>info</codeph> 对象（带有一个表示成功的 <codeph>code</codeph> 属性）时，才调用该处理函数。建议您在调用 <codeph>NetStream.play()</codeph> 之前，等待连接成功。 </p>
 <codeblock>

package {
    import flash.display.Sprite;
    import flash.events.NetStatusEvent;
    import flash.events.SecurityErrorEvent;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.Event;

    public class NetConnectionExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function NetConnectionExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Stream not found: " + videoURL);
                    break;
            }
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.client = new CustomClient();
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
    }
}

class CustomClient {
    public function onMetaData(info:Object):void {
        trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate);
    }
    public function onCuePoint(info:Object):void {
        trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Video"><linktext>flash.media.Video</linktext></link><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link></related-links><adobeApiEvent id="flash.net:NetStream_flash.events.DRMStatusEvent.DRM_STATUS_drmStatus"><apiName>drmStatus</apiName><shortdesc>
 在开始播放数字权限管理 (DRM) 加密的内容时（如果已对用户进行身份验证并授权播放该内容）分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMStatusEvent.DRM_STATUS</apiEventType><adobeApiEventClassifier>flash.events.DRMStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在开始播放数字权限管理 (DRM) 加密的内容时（如果已对用户进行身份验证并授权播放该内容）分派。
 <p>
 DRMStatusEvent 对象包含与凭证有关的信息，如是否可以脱机使用该内容或凭证何时过期而无法再查询该内容。
 </p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMStatusEvent"><linktext>flash.events.DRMStatusEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.DRMErrorEvent.DRM_ERROR_drmError"><apiName>drmError</apiName><shortdesc>
 在 NetStream 对象尝试播放数字权限管理 (DRM) 加密的文件的过程中遇到与 DRM 相关的错误时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMErrorEvent.DRM_ERROR</apiEventType><adobeApiEventClassifier>flash.events.DRMErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 NetStream 对象尝试播放数字权限管理 (DRM) 加密的文件的过程中遇到与 DRM 相关的错误时分派。例如，用户身份验证失败时，将分派 DRMErrorEvent 对象。这可能是由于用户没有购买查看内容的权限或者是由于内容提供程序不支持执行查看的应用程序。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMErrorEvent"><linktext>flash.events.DRMErrorEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.DRMAuthenticateEvent.DRM_AUTHENTICATE_drmAuthenticate"><apiName>drmAuthenticate</apiName><shortdesc>
 在 NetStream 对象尝试播放使用数字权限管理 (DRM) 加密的内容（播放前需要用户凭据以进行身份验证）时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMAuthenticateEvent.DRM_AUTHENTICATE</apiEventType><adobeApiEventClassifier>flash.events.DRMAuthenticateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 NetStream 对象尝试播放使用数字权限管理 (DRM) 加密的内容（播放前需要用户凭据以进行身份验证）时分派。 
 
 <p>
 使用 NetStream 对象的 <codeph>setDRMAuthenticationCredentials()</codeph> 方法对用户进行身份验证。如果用户身份验证失败，则应用程序将重新尝试身份验证并为 NetStream 对象分派一个新的 DRMAuthenticateEvent 事件。
 </p>
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMAuthenticateEvent"><linktext>flash.events.DRMAuthenticateEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onDRMContentData"><apiName>onDRMContentData</apiName><shortdesc>
 建立一个侦听器，以便在 AIR 提取媒体文件中嵌入的 DRM 内容元数据时作出响应。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 建立一个侦听器，以便在 AIR 提取媒体文件中嵌入的 DRM 内容元数据时作出响应。
 
 <p>DRMContentData 对象包含获取凭证所需的信息，在播放受 DRM 保护的媒体文件时需要该凭证。使用 DRMManager 类可根据这些信息下载该凭证。</p>
 
 <p><codeph>onDRMContentData</codeph> 实际上是 <codeph>NetStream.client</codeph> 对象的一个属性。它不是事件，但之所以在 Events 一节中列出，是因为从本地媒体文件预加载嵌入的数据时它将响应数据事件。有关详细信息，请参阅 NetStream 类的描述。不能使用 <codeph>addEventListener()</codeph> 方法或任何其它 EventDispatcher 方法将 <codeph>onDRMContentData</codeph> 作为事件进行侦听或处理。相反，您必须定义一个回调函数，并将其直接附加到以下对象之一：</p>
 <ul>
  <li>NetStream 实例的 <codeph>client</codeph> 属性所引用的对象。</li>    
  <li>NetStream 子类的一个实例。NetStream 是一个密封类，即无法在运行时将属性或方法添加到 NetStream 对象。然而，您可以创建 NetStream 的子类并在其中定义您的事件处理函数，或者将该子类变为动态的并对子类的实例添加事件处理函数。</li>
 </ul>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.drm.xml#DRMContentData"><linktext>flash.net.drm.DRMContentData</linktext></link><link href="flash.net.xml#NetStream/preloadEmbeddedData()"><linktext>preloadEmbeddedData()</linktext></link><link href="flash.net.drm.xml#DRMManager"><linktext>flash.net.drm.DRMManager</linktext></link><link href="flash.net.drm.xml#DRMVoucher"><linktext>flash.net.drm.DRMVoucher</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onPlayStatus"><apiName>onPlayStatus</apiName><shortdesc>
 在 NetStream 对象已完全播放流时建立侦听器进行响应。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 NetStream 对象已完全播放流时建立侦听器进行响应。关联的事件对象除了提供由 <codeph>netStatus</codeph> 事件返回的信息以外，还提供一些其它信息。您可以在 NetStream 对象从播放列表中的一个流切换到另一个流时（如信息对象 <codeph>NetStream.Play.Switch</codeph> 所示），或者在 NetStream 对象播放到结尾时（如信息对象 <codeph>NetStream.Play.Complete</codeph> 所示），使用此属性触发代码中的操作。 
 
 <p><codeph>onPlayStaus</codeph> 实际上是 <codeph>NetStream.client</codeph> 对象的属性。它不是一个事件，之所以列在事件部分，是因为它在流媒体使用 Flash Media Server 时或在 FLV 文件回放过程中响应数据事件。有关详细信息，请参阅 NetStream 类的描述。不能使用 <codeph>addEventListener()</codeph> 方法或任何其它 EventDispatcher 方法将 <codeph>onPlayStatus</codeph> 作为事件进行侦听或处理。相反，您必须定义一个回调函数，并将其直接附加到以下对象之一：</p>
 
 <ul>
  <li>NetStream 实例的 <codeph>client</codeph> 属性所引用的对象。</li>    
  <li>NetStream 子类的一个实例。NetStream 是一个密封类，即无法在运行时将属性或方法添加到 NetStream 对象。然而，您可以创建 NetStream 的子类并在其中定义您的事件处理函数，或者将该子类变为动态的并对子类的实例添加事件处理函数。</li>
    
 </ul>
 
 <p>此事件可返回一个具有以下属性的信息对象：</p>
 
 <adobetable class="innertable">
  
  
  
   
 <tgroup cols="3"><thead><row><entry>代码属性</entry><entry>级别属性</entry><entry>意义</entry></row></thead><tbody><row>
    <entry><codeph>NetStream.Play.Switch</codeph></entry>
    <entry><codeph>"status"</codeph></entry>
    <entry>订阅者正在从播放列表中的一个流切换到另一个流。</entry>
  </row><row>
    <entry><codeph>NetStream.Play.Complete</codeph></entry>
    <entry><codeph>"status"</codeph></entry>
    <entry>播放已结束。</entry>
  </row><row>
    <entry><codeph>NetStream.Play.TransitionComplete</codeph></entry>
    <entry><codeph>"status"</codeph></entry>
    <entry>应用流比特率切换之后，订户将切换到新的流</entry>
  </row></tbody></tgroup></adobetable>
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.events.xml#NetStatusEvent/NET_STATUS"><linktext>flash.events.NetStatusEvent.NET_STATUS</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onCuePoint"><apiName>onCuePoint</apiName><shortdesc>
 在播放视频文件期间到达嵌入提示点时建立侦听器进行响应。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在播放视频文件期间到达嵌入提示点时建立侦听器进行响应。在视频到达某个特定提示点时，您可以使用此侦听器触发代码中的操作，从而使应用程序中的其它操作与视频回放事件实现同步。有关 Flash Media Server 支持的视频文件格式的信息，请参阅 <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>。

 
 <p><codeph>onCuePoint</codeph> 实际上是 <codeph>NetStream.client</codeph> 对象的属性。它不是一个事件，之所以列在事件部分，是因为它在流媒体使用 Flash Media Server 时或在 FLV 文件回放过程中响应数据事件。有关详细信息，请参阅 NetStream 类的描述。不能使用 <codeph>addEventListener()</codeph> 方法或任何其它 EventDispatcher 方法将 <codeph>onCuePoint</codeph> 作为事件进行侦听或处理。相反，您必须定义一个回调函数，并将其直接附加到以下对象之一：</p>
 
 <ul>
  <li>NetStream 实例的 <codeph>client</codeph> 属性所引用的对象。</li>    
  <li>NetStream 子类的一个实例。NetStream 是一个密封类，即无法在运行时将属性或方法添加到 NetStream 对象。然而，您可以创建 NetStream 的子类并在其中定义您的事件处理函数，或者将该子类变为动态的并对子类的实例添加事件处理函数。</li>
    
 </ul>
 
 <p>关联的事件侦听器在调用 <codeph>NetStream.play()</codeph> 方法之后、在视频播放头前进之前触发。</p>
 
 <p>可以在视频文件中嵌入以下类型的提示点：</p>
 
 <ul>
 <li>导航提示点，它指定视频文件中的一个关键帧，而且其 <codeph>time</codeph> 属性对应于该关键帧。导航提示点经常被用作书签或入口点，以便用户在视频文件中导航。</li>
 
 <li>事件提示点，它由时间指定，而不管该时间是否对应于某个特定的关键帧。事件提示点通常代表视频中的某个时间，到达这个时间时可用于触发其它应用程序事件的情况就会发生。</li>
 </ul>
 
 <p><codeph>onCuePoint</codeph> 事件对象具有以下属性：</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>属性</entry><entry>说明</entry></row></thead><tbody><row>
   <entry><codeph>name</codeph></entry>
   <entry>将提示点嵌入视频文件时为其指定的名称。</entry></row><row>
   <entry><codeph>parameters</codeph></entry>
   <entry>为此提示点指定的一个由名称/值对字符串组成的关联数组。任何有效的字符串都可用于参数名或参数值。</entry>
 </row><row>
   <entry><codeph>time</codeph></entry>
   <entry>提示点在视频文件回放期间的出现时间（以秒为单位）。</entry>
 </row><row>
   <entry><codeph>type</codeph></entry>
   <entry>到达的提示点的类型：导航提示点或事件提示点。</entry>
 </row></tbody></tgroup></adobetable>
 
 <p>在首次对视频文件进行编码时，或者在 Flash 创作工具中使用“视频导入”向导导入视频剪辑时，您可以在该视频文件中定义提示点。</p>
 
 <p><codeph>onMetaData</codeph> 事件还会在视频文件中检索有关提示点的信息。不过，<codeph>onMetaData</codeph> 事件会在视频开始播放之前，获取有关所有提示点的信息。<codeph>onCuePoint</codeph> 事件会在回放期间对某个提示点所指定的时间，接收有关该提示点的信息。</p>
 
 <p>通常，要让代码在特定的提示点出现时对它给予响应，请使用 <codeph>onCuePoint</codeph> 事件来触发代码中的某个操作。</p>
 
 <p>您可以使用提供给 <codeph>onMetaData</codeph> 事件的提示点列表，允许用户在视频流的预定义点处开始播放视频。将提示点的 <codeph>time</codeph> 属性的值传递给 <codeph>NetStream.seek()</codeph> 方法，以便从该提示点播放视频。</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onTextData"><apiName>onTextData</apiName><shortdesc>
  在 Flash Player 接收到正在播放的媒体文件中嵌入的文本数据时建立侦听器进行响应。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  在 Flash Player 接收到正在播放的媒体文件中嵌入的文本数据时建立侦听器进行响应。文本数据采用 UTF-8 格式并可以包含有关基于 3GP Timed Text 规范的格式设置的信息。
  <p><codeph>onTextData</codeph> 实际上是 <codeph>NetStream.client</codeph> 对象的属性。它不是一个事件，之所以列在事件部分，是因为它在流媒体使用 Flash Media Server 时或在 FLV 文件回放过程中响应数据事件。有关详细信息，请参阅 NetStream 类的描述。不能使用 <codeph>addEventListener()</codeph> 方法或任何其它 EventDispatcher 方法将 <codeph>onTextData</codeph> 作为事件进行侦听或处理。相反，您必须定义一个回调函数，并将其直接附加到以下对象之一：</p>
 
 <ul>
  <li>NetStream 实例的 <codeph>client</codeph> 属性所引用的对象。</li>    
  <li>NetStream 子类的一个实例。NetStream 是一个密封类，即无法在运行时将属性或方法添加到 NetStream 对象。然而，您可以创建 NetStream 的子类并在其中定义您的事件处理函数，或者将该子类变为动态的并对子类的实例添加事件处理函数。</li>
    
 </ul>
 
 <p>关联的事件侦听器在调用 <codeph>NetStream.play()</codeph> 方法之后、在视频播放头前进之前触发。</p>
  
  <p>onTextData 事件对象对每段文本数据包含一个属性。</p>
  
  </apiDesc><example conref="examples\OnTextDataExample.as"> 本示例中的代码使用 <codeph>Netstream.client</codeph> 属性来处理 <codeph>onTextData</codeph> 和 <codeph>onImageData</codeph> 的回调函数。<codeph>onImageDataHandler()</codeph> 函数使用 onImageData 事件对象 <codeph>imageData</codeph> 来存储该字节数组。而 <codeph>onTextDataHandler()</codeph> 函数使用 onTextData 事件对象 <codeph>textData</codeph> 来存储各段文本数据（每段数据都是 <codeph>textData</codeph> 对象的一个属性）。
 <p>您需要在代码中用位置 <codeph>"yourURL"</codeph> 的文本或图像元数据替换媒体文件的实际位置。</p>
 <p> 您也可以使用自定义类处理图像和文本数据。有关详细信息和示例，请参阅文章 <xref href="http://www.adobe.com/devnet/flash/quickstart" scope="external">Handling metadata and cue points in Flash video</xref>（处理 Flash 视频中的元数据和提示点）。</p>
 <codeblock>
package {
    import flash.display.*;
    import flash.net.*;
    import flash.media.*;
    import flash.system.*;
    import flash.events.*;

        public class OnTextDataExample extends Sprite {
                                              
            public function OnTextDataExample():void {

                var customClient:Object = new Object();
                customClient.onImageData = onImageDataHandler;           
                customClient.onTextData = onTextDataHandler;               

                var my_nc:NetConnection = new NetConnection();
                my_nc.connect(null);
                var my_ns:NetStream = new NetStream(my_nc);
                my_ns.play("yourURL");
                my_ns.client = customClient;

                var my_video:Video = new Video();
                my_video.attachNetStream(my_ns);
                addChild(my_video);

            }

            public function onImageDataHandler(imageData:Object):void {

                trace("imageData length: " + imageData.data.length);
                var imageloader:Loader = new Loader();           
                imageloader.loadBytes(imageData.data); // imageData.data is a ByteArray object.
                addChild(imageloader);
            }

    
            public function onTextDataHandler(textData:Object):void {

                trace("--- textData properties ----");
                var key:String;

                for (key in textData) {
                    trace(key + ": " + textData[key]);
                }
            }

        }

}

</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onImageData"><apiName>onImageData</apiName><shortdesc>
 在 Flash Player 以字节数组形式接收到正在播放的媒体文件中嵌入的图像数据时建立侦听器进行响应。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 Flash Player 以字节数组形式接收到正在播放的媒体文件中嵌入的图像数据时建立侦听器进行响应。图像数据可以生成 JPEG、PNG 或 GIF 内容。使用 <codeph>flash.display.Loader.loadBytes()</codeph> 方法可以将该字节数组加载到显示对象中。
 <p><codeph>onImageData</codeph> 实际上是 <codeph>NetStream.client</codeph> 对象的属性。它不是一个事件，之所以列在事件部分，是因为它在流媒体使用 Flash Media Server 时或在 FLV 文件回放过程中响应数据事件。有关详细信息，请参阅 NetStream 类的描述。不能使用 <codeph>addEventListener()</codeph> 方法或任何其它 EventDispatcher 方法侦听或处理 <codeph>onImageData</codeph> 事件。相反，您必须定义一个回调函数，并将其直接附加到以下对象之一：</p>
 
 <ul>
  <li>NetStream 实例的 <codeph>client</codeph> 属性所引用的对象。</li>    
  <li>NetStream 子类的一个实例。NetStream 是一个密封类，即无法在运行时将属性或方法添加到 NetStream 对象。然而，您可以创建 NetStream 的子类并在其中定义您的事件处理函数，或者将该子类变为动态的并对子类的实例添加事件处理函数。</li>
    
 </ul>
 
 <p>关联的事件侦听器在调用 <codeph>NetStream.play()</codeph> 方法之后、在视频播放头前进之前触发。</p>
 
 <p>onImageData 事件对象包含通过 AMF0 数据通道以字节数组形式发送的图像数据。</p>
 
 </apiDesc><example conref="examples\OnTextDataExample.as"> 本示例中的代码使用 <codeph>Netstream.client</codeph> 属性来处理 <codeph>onTextData</codeph> 和 <codeph>onImageData</codeph> 的回调函数。<codeph>onImageDataHandler()</codeph> 函数使用 onImageData 事件对象 <codeph>imageData</codeph> 来存储该字节数组。而 <codeph>onTextDataHandler()</codeph> 函数使用 onTextData 事件对象 <codeph>textData</codeph> 来存储各段文本数据（每段数据都是 <codeph>textData</codeph> 对象的一个属性）。
 <p>您需要在代码中用位置 <codeph>"yourURL"</codeph> 的文本或图像元数据替换媒体文件的实际位置。</p>
 <p> 您也可以使用自定义类处理图像和文本数据。有关详细信息和示例，请参阅文章 <xref href="http://www.adobe.com/devnet/flash/quickstart" scope="external">Handling metadata and cue points in Flash video</xref>（处理 Flash 视频中的元数据和提示点）。</p>
 <codeblock>
package {
    import flash.display.*;
    import flash.net.*;
    import flash.media.*;
    import flash.system.*;
    import flash.events.*;

        public class OnTextDataExample extends Sprite {
                                              
            public function OnTextDataExample():void {

                var customClient:Object = new Object();
                customClient.onImageData = onImageDataHandler;           
                customClient.onTextData = onTextDataHandler;               

                var my_nc:NetConnection = new NetConnection();
                my_nc.connect(null);
                var my_ns:NetStream = new NetStream(my_nc);
                my_ns.play("yourURL");
                my_ns.client = customClient;

                var my_video:Video = new Video();
                my_video.attachNetStream(my_ns);
                addChild(my_video);

            }

            public function onImageDataHandler(imageData:Object):void {

                trace("imageData length: " + imageData.data.length);
                var imageloader:Loader = new Loader();           
                imageloader.loadBytes(imageData.data); // imageData.data is a ByteArray object.
                addChild(imageloader);
            }

    
            public function onTextDataHandler(textData:Object):void {

                trace("--- textData properties ----");
                var key:String;

                for (key in textData) {
                    trace(key + ": " + textData[key]);
                }
            }

        }

}

</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/event:onTextData"><linktext>onTextData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onMetaData"><apiName>onMetaData</apiName><shortdesc>
 在 Flash Player 接收到正在播放的视频中嵌入的描述性信息时建立侦听器进行响应。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 Flash Player 接收到正在播放的视频中嵌入的描述性信息时建立侦听器进行响应。有关 Flash Media Server 支持的视频文件格式的信息，请参阅 <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>。
 
 <p><codeph>onMetaData</codeph> 实际上是 <codeph>NetStream.client</codeph> 对象的属性。它不是一个事件，之所以列在事件部分，是因为它在流媒体使用 Flash Media Server 时或在 FLV 文件回放过程中响应数据事件。有关详细信息，请参阅 NetStream 类的描述以及 <codeph>NetStream.client</codeph> 属性。不能使用 <codeph>addEventListener()</codeph> 方法或任何其它 EventDispatcher 方法侦听或处理 <codeph>onMetaData</codeph> 事件。相反，您必须定义一个回调函数，并将其直接附加到以下对象之一：</p>
 
 <ul>
 
  <li>NetStream 实例的 <codeph>client</codeph> 属性所引用的对象。</li>    
 
  <li>NetStream 子类的一个实例。NetStream 是一个密封类，即无法在运行时将属性或方法添加到 NetStream 对象。然而，您可以创建 NetStream 的子类并在其中定义您的事件处理函数，或者将该子类变为动态的并对子类的实例添加事件处理函数。</li>
    
 </ul>
 
 <p>Flash Video Exporter 实用程序（1.1 版本或更高版本）将视频的持续时间、创建日期、数据速率及其它信息嵌入视频文件本身。不同的视频编码器嵌入不同的元数据组中。</p>
 
 <p>关联的事件侦听器在调用 <codeph>NetStream.play()</codeph> 方法之后、在视频播放头前进之前触发。</p>
 
 <p>在多数情况下，流元数据中嵌入的持续时间值接近于实际持续时间，但并不精确。换言之，当播放头在视频流的结尾处时，此值不会始终与 <codeph>NetStream.time</codeph> 属性的值相匹配。</p>
 <p>传递到 onMetaData 事件处理函数的事件对象包含每段数据的一个属性。</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onXMPData"><apiName>onXMPData</apiName><shortdesc>
 建立一个侦听器，以便在 Flash Player 接收到特定于正在播放的视频中嵌入的 Adobe 可扩展元数据平台 (XMP) 的信息时进行响应。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 建立一个侦听器，以便在 Flash Player 接收到特定于正在播放的视频中嵌入的 Adobe 可扩展元数据平台 (XMP) 的信息时进行响应。有关 Flash Media Server 支持的视频文件格式的信息，请参阅 <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>。
 
 <p><codeph>onXMPData</codeph> 实际上是 <codeph>NetStream.client</codeph> 对象的属性。它不是一个事件，之所以列在事件部分，是因为它在流媒体使用 Flash Media Server 时或在 FLV 文件回放过程中响应数据事件。有关详细信息，请参阅 NetStream 类的描述以及 <codeph>NetStream.client</codeph> 属性。不能使用 <codeph>addEventListener()</codeph> 方法或任何其它 EventDispatcher 方法侦听或处理 <codeph>onMetaData</codeph> 事件。相反，您必须定义一个回调函数，并将其直接附加到以下对象之一：</p>
 
 <ul>
  <li>NetStream 实例的 <codeph>client</codeph> 属性所引用的对象。</li>    
  <li>NetStream 子类的一个实例。NetStream 是一个密封类，即无法在运行时将属性或方法添加到 NetStream 对象。然而，您可以创建 NetStream 的子类并在其中定义您的事件处理函数，或者将该子类变为动态的并对子类的实例添加事件处理函数。</li>
    
 </ul>
 
 <p>关联的事件侦听器在调用 <codeph>NetStream.play()</codeph> 方法之后、在视频播放头前进之前触发。</p>
 
 <p>传递给 <codeph>onXMPData()</codeph> 事件处理函数的对象包含一个 <codeph>data</codeph> 属性，此属性是一个字符串。此字符串在顶级 UUID 框中生成。（顶级框的 128 位 UUID 为 <codeph>BE7ACFCB-97A9-42E8-9C71-999491E3AFAC</codeph>。）此顶级 UUID 框正好包含一个 XML 文档，该文档以 null 结尾的 UTF-8 字符串形式表示。</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 在 NetStream 对象报告其状态或错误条件时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 NetStream 对象报告其状态或错误条件时分派。<codeph>netStatus</codeph> 事件包含一个 <codeph>info</codeph> 属性，该属性是一个包含有关事件特定信息（例如连接尝试成功还是失败）的信息对象。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 在出现输入或输出错误并导致网络操作失败时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在出现输入或输出错误并导致网络操作失败时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 在异步引发异常（即来自本机异步代码）时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在异步引发异常（即来自本机异步代码）时分派。当服务器调用客户端上未定义的方法时分派此事件。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/event:onPlayStatus"><linktext>NetStream.onPlayStatus</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>NetStream.onMetaData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 在应用程序尝试通过调用 NetStream.play() 方法播放用数字权限管理 (DRM) 加密的内容时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在应用程序尝试通过调用 <codeph>NetStream.play()</codeph> 方法播放用数字权限管理 (DRM) 加密的内容时分派。状态代码属性的值将为<codeph>“DRM.encryptedFLV”</codeph>。 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:NetStream:NetStream"><apiName>NetStream</apiName><shortdesc>
 	 创建可用于通过指定的 NetConnection 对象播放视频文件的流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, constructor
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>未连接 NetConnection 实例。
 	 
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>connection</apiItemName><apiOperationClassifier>flash.net:NetConnection</apiOperationClassifier><apiDesc>一个 NetConnection 对象。
     </apiDesc></apiParam><apiParam><apiItemName>peerID</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>connectToFMS</apiData><apiDesc>此参数是可选的。随 Flash Player 10 及更高版本提供。对于与 FMS 的连接，将此值设置为 <codeph>NetStream.CONNECT_TO_FMS</codeph>。对于向同级的直接发布，请指定 <codeph>NetStream.DIRECT_CONNECTIONS</codeph>。要从特定同级直接播放，请指定该同级的标识（请参阅 <codeph>NetConnection.nearID</codeph> 和 <codeph>NetConnection.farID</codeph>）。如果 <codeph>peerID</codeph> 参数设置为一个同级，则 <codeph>NetConnection.protocol</codeph> 属性值必须为 <codeph>"rtmfp"</codeph>。对于非 RTMFP 连接，将忽略 <codeph>peerID</codeph> 参数。ActionScript 对 <codeph>peerID</codeph> 参数使用默认值 <codeph>"connectToFMS"</codeph>，以便捕获以编程方式将 null 值作为参数传递给 NetStream() 方法的情况。
     <p>不过，由于 <codeph>peerID</codeph> 参数是可选参数，因此以下代码仍可用于通过客户端服务器连接进行的渐进式播放：</p>
     <codeblock>
     new NetStream(nc:NetConnection);
     </codeblock>
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 创建可用于通过指定的 NetConnection 对象播放视频文件的流。 
     
     <p>
     有关支持的编解码器和文件格式的信息，请参阅 <xref href="http://www.adobe.com/go/hardware_scaling_cn" scope="external">http://www.adobe.com/go/hardware_scaling_cn</xref> 和 <xref href="http://www.adobe.com/go/learn_fms_fileformats_cn" scope="external">www.adobe.com/go/learn_fms_fileformats_cn</xref>。
     </p>
	 
 	 </apiDesc><example conref="examples\NetStreamExample_constructor.as"> 以下代码演示一个用于渐进式下载和显示分配给变量 <codeph>videoURL</codeph> 的视频的连接：
<codeblock>
            var my_nc:NetConnection = new NetConnection();
            my_nc.connect(null);
            var my_ns:NetStream = new NetStream(my_nc);
            my_ns.play(videoURL);
            var my_video:Video = new Video();
            my_video.attachNetStream(my_ns);
            addChild(my_video);
</codeblock></example><example conref="examples\NetStreamExample_constructor2.as"> 以下代码演示一个用于流式处理和显示 <codeph>connect()</codeph> 命令中指定的远程 Flash Media Server 实例上的视频（为变量 <codeph>videoURL</codeph> 分配的视频）的连接：
<codeblock>
            var my_nc:NetConnection = new NetConnection();
            my_nc.connect("rtmp://www.yourfmsserver.com/someappname");
            var my_ns:NetStream = new NetStream(my_nc, NetStream.CONNECT_TO_FMS);
            my_ns.play(videoURL);
            var my_video:Video = new Video();
            my_video.attachNetStream(my_ns);
            addChild(my_video);
</codeblock></example></apiConstructorDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.media.xml#Video/attachCamera()"><linktext>flash.media.Video.attachCamera()</linktext></link><link href="flash.net.xml#NetStream/CONNECT_TO_FMS"><linktext>CONNECT_TO_FMS</linktext></link><link href="flash.net.xml#NetStream/DIRECT_CONNECTIONS"><linktext>DIRECT_CONNECTIONS</linktext></link><link href="flash.net.xml#NetConnection/nearID"><linktext>flash.net.NetConnection.nearID</linktext></link><link href="flash.net.xml#NetConnection/farID"><linktext>flash.net.NetConnection.farID</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:NetStream:attachAudio"><apiName>attachAudio</apiName><shortdesc>
	 指定一个通过 NetStream 对象发送的音频流，它来自作为源传递的 Microphone 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiDefaultValue>"null" 
	 </apiDefaultValue><apiParam><apiItemName>microphone</apiItemName><apiOperationClassifier>flash.media:Microphone</apiOperationClassifier><apiDesc>要传输的音频流的源。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定一个通过 NetStream 对象发送的音频流，它来自作为源传递的 Microphone 对象。此方法仅供指定的流的发布者使用。
	 
	 <p><codeph>attachAudio</codeph> 方法用于 Flash Media Server。此方法通常是由从客户端计算机向服务器发送实时音频（或包含音频的实时视频）的用户调用的。
	 </p>
	 
	 <p>您可以在调用 <codeph>publish()</codeph> 方法并真正开始传输之前或之后，调用此方法。想要收听此音频的订阅者必须调用 <codeph>NetStream.play()</codeph> 方法。设置麦克风的 <codeph>rate</codeph>，使其与声音捕获设备的速率匹配，并通过 <codeph>setSilenceLevel()</codeph> 方法设置静音级别阈值。可以通过 microphone 对象的 <codeph>soundTransform</codeph> 属性控制此音频流的声音属性（音量和声相）。</p>
     <codeblock>
     var conn:NetConnection = new NetConnection();
     conn.connect("rtmp://server.domain.com/path");
     var stream:NetStream = new NetStream(conn);
     var live_mic:Microphone = Microphone.get();
     live_mic.rate = 8;
     live_mic.setSilenceLevel(20,200);
     var soundTrans:SoundTransform = new SoundTransform();
     soundTrans.volume = 6;
     live_mic.soundTransform = soundTrans;
     stream.attachAudio(live_mic);
     stream.publish("mic_stream","live")
     </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.media.xml#Microphone"><linktext>flash.media.Microphone</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:attachCamera"><apiName>attachCamera</apiName><shortdesc>
	 开始从摄像头捕获视频，如果将 theCamera 设置为 null，则会停止捕获操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>theCamera</apiItemName><apiOperationClassifier>flash.media:Camera</apiOperationClassifier><apiDesc>视频传输的源。有效值为一个 Camera 对象（可开始捕获视频）和 <codeph>null</codeph>。如果传递 <codeph>null</codeph>，应用程序将停止捕获视频，并忽略发送的其它任何参数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>snapshotMilliseconds</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>指定视频流是连续、单帧，还是用于创建延时拍摄的一系列单帧。
	 
	 <ul>
     <li>如果省略此参数，应用程序将捕获所有视频，直到将 <codeph>null</codeph> 值传递给 <codeph>attachCamera</codeph>。</li>
	 <li>如果传递 0，应用程序将仅捕获一个视频帧。使用此值可传输先前流中的“快照”。<ph platform="actionscript">Flash Player 或</ph>AIR 会将无效参数、负参数或非数字参数均解释为 0。</li>
     <li>如果传递了正数值，应用程序将捕获单个视频帧，然后将指定长度的停顿作为片尾追加到快照上。使用此值可实现延时拍摄效果。</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 开始从摄像头捕获视频，如果将 <codeph>theCamera</codeph> 设置为 <codeph>null</codeph>，则会停止捕获操作。此方法仅供指定的流的发布者使用。 
	 
     <p>此方法用于 Flash Media Server；有关详细信息，请参阅类说明。</p>
	 
	 <p> 在附加了视频源后，必须调用 <codeph>NetStream.publish()</codeph> 才能开始传输。希望显示视频的订户必须调用 <codeph>NetStream.play()</codeph> 和 <codeph>Video.attachCamera()</codeph> 方法，才能在舞台上显示视频。</p>
	 
	 <p>可以使用 <codeph>snapshotMilliseconds</codeph> 并通过提供一个正数值，将指定毫秒数的尾片添加到视频输入信号中的方式来发送单个快照（通过提供值 0）或一系列快照（实际上是延时拍摄镜头）。尾片延长了视频消息的显示时间。通过对 <codeph>snapshotMilliseconds</codeph> 使用正数值来重复调用 <codeph>attachCamera()</codeph>，交替快照和尾片的序列将创建延时拍摄镜头。例如，可以每天捕获一个帧，将其追加到视频文件上。当订阅者播放该文件时，每个帧都会在屏幕上显示指定的毫秒数，然后才会显示下一个帧。</p>
	 
	 <p><codeph>snapshotMilliseconds</codeph> 参数的用途不同于可通过 <codeph>Camera.setMode()</codeph> 设置的 <codeph>fps</codeph> 参数。在指定 <codeph>snapshotMilliseconds</codeph> 时，您可以控制录制的帧之间的时间间隔。在使用 <codeph>Camera.setMode()</codeph> 指定 <codeph>fps</codeph> 时，您在控制录制和回放多长时间。</p>
	 
	 <p>例如，假设您想每隔 5 分钟取一个快照，一共要取 100 个快照。您可以通过以下两种方式来实现：</p>
     
	 <ul>
	 <li>您可以每隔 5 分钟发出一个 <codeph>NetStream.attachCamera(myCamera, 500)</codeph> 命令，重复执行 100 次。整个录制过程将需要 500 分钟，但是产生的文件将在 50 秒内完成回放（100 个帧，帧与帧之间的时间间隔为 500 毫秒）。</li> 
	 
	 <li>您可以发出一个 <codeph>fps</codeph> 值为 1/300（每 300 秒一次，即每 5 分钟一次）的 <codeph>Camera.setMode()</codeph> 命令，然后发出一个 <codeph>NetStream.attachCamera(source)</codeph> 命令，使摄像头连续捕捉 500 分钟的图像。产生的文件将在 500 分钟内完成回放，这与录制的时间长度相同，每个帧显示 5 分钟。</li>
	 </ul>
     
	 <p>这两种方法都同样捕获了 500 个帧，并且都很有用；具体采用何种方法，主要取决于对回放的要求。例如，在第二种情况中，可以是整段时间一直在录制音频。另外，两个文件的大小也相近。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:close"><apiName>close</apiName><shortdesc>
	 停止播放流上的所有数据，将 time 属性设置为 0，并使该流可用于其它用途。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.close, close
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 停止播放流上的所有数据，将 <codeph>time</codeph> 属性设置为 0，并使该流可用于其它用途。此方法还会删除通过 HTTP 下载的视频文件的本地副本。虽然应用程序会删除它所创建的文件的本地副本，但可能会在缓存目录中永久保留一个副本。如果必须完全禁止缓存视频文件或在本地进行存储，请使用 Flash Media Server。
     
     <p>
     如果使用 Flash Media Server，则在从发布流中调用 <codeph>NetStream.play()</codeph> 或从订阅流中调用 <codeph>NetStream.publish()</codeph> 时，将隐式地调用此方法。请注意：
     </p>
     
     <ul>
     <li>
     如果从发布流中调用 <codeph>close()</codeph>，该流将停止发布，发布者现在可以将该流用于其它用途。订阅者不再接收在该流中发布的任何内容，因为该流已停止发布。 
     </li>
     <li>
     如果从订阅流中调用 <codeph>close()</codeph>，该流将停止为订阅者播放，订阅者现在可以将该流用于其它用途。其他订阅者不受影响。
     </li>
     <li>
     您可以让订阅流停止播放，而无需使用 <codeph>flash.net.NetStream.play(false)</codeph> 关闭该流或更改流类型。
     </li>
     </ul>
     
     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/publish()"><linktext>publish()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:onPeerConnect"><apiName>onPeerConnect</apiName><shortdesc>
	 
     每当一个同级发布流与一个同级订阅流相匹配时即调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>subscriber</apiItemName><apiOperationClassifier>flash.net:NetStream</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 
     每当一个同级发布流与一个同级订阅流相匹配时即调用。在订户连接到发行者之前，调用此方法以允许 ActionScript 代码细化同级对同级发布的访问控制。以下代码显示一个如何创建此方法的回调函数的示例：
     <codeblock>
	 var c:Object = new Object;
	 c.onPeerConnect = function(subscriber:NetStream):Boolean {
	 if (accept)
	 	return true;
	  else
	      return false;
	  };
	  m_netStream.client = c;
     </codeblock>
     
     <p>如果同级发行者不实现此方法，则允许所有同级播放已发布的任何内容。</p>
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:pause"><apiName>pause</apiName><shortdesc>
	 暂停视频流的回放。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.pause, pause
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 暂停视频流的回放。如果视频已经暂停，则调用此方法将不会执行任何操作。要在暂时视频后恢复播放，请调用 <codeph>resume()</codeph>。要在暂停和播放之间切换（先暂停视频，然后恢复），请调用 <codeph>togglePause()</codeph>。
	 
	 <p>从 Flash Player 9.0.115.0 开始，在调用 <codeph>NetStream.pause()</codeph> 时，Flash Player 不再清除缓冲区。在 Flash Player 9.0.115.0 之前，恢复播放之前 Flash Player 将等待缓冲区填满，这通常会导致延迟。</p>
	 
	 <p>对于一次暂停，<codeph>NetStream.bufferLength</codeph> 属性的限值为 60 秒或二倍的 <codeph>NetStream.bufferTime</codeph> 值（取二者之中的较大值）。例如，如果 <codeph>bufferTime</codeph> 为 20 秒，在 <codeph>NetStream.bufferLength</codeph> 为较大值 20~~2 (40) 或 60 之前，Flash Player 将一直进行缓冲，因此在本例中，在 <codeph>bufferLength</codeph> 为 60 之前，Flash Player 将一直进行缓冲。如果 <codeph>bufferTime</codeph> 为 40 秒，在 <codeph>bufferLength</codeph> 为较大值 40~~2 (80) 或 60 之前，则 Flash Player 将一直进行缓冲，因此在本例中，在 <codeph>bufferLength</codeph> 为 80 秒之前，Flash Player 将一直进行缓冲。</p>
	 
	 <p><codeph>bufferLength</codeph> 属性还有一个绝对限制。如果对 <codeph>pause()</codeph> 的任何调用导致 <codeph>bufferLength</codeph> 增大到 600 秒以上或 <codeph>bufferTime</codeph> ~~ 2 的值（取二者中的较大值），Flash Player 将刷新缓冲区并将 <codeph>bufferLength</codeph> 重置为 0。例如，如果 <codeph>bufferTime</codeph> 为 120 秒，当 <codeph>bufferLength</codeph> 达到 600 秒时，Flash Player 将刷新缓冲区；如果 <codeph>bufferTime</codeph> 为 360 秒，当 <codeph>bufferLength</codeph> 达到 720 秒时，Flash Player 将刷新缓冲区。</p>
	 
	 <p><b>提示</b>：例如，在查看器监视商用版的同时，可以在代码中使用 <codeph>NetStream.pause()</codeph> 来缓冲数据，然后在开始播放主视频时取消暂停。</p>
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/resume()"><linktext>resume()</linktext></link><link href="flash.net.xml#NetStream/togglePause()"><linktext>togglePause()</linktext></link><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:play"><apiName>play</apiName><shortdesc>
     播放媒体文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>"at"see flash.media.Video#attachVideo()  This method no longer exists.  Replace with new method.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>本地不受信任的 SWF 文件无法与 Internet 通信。您可以通过将此 SWF 文件重新分类为只能与远程内容交互或受信任来消除此限制。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>至少必须指定一个参数。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>NetStream 对象无效。这可能是由于失败的 NetConnection 造成的。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>要播放的媒体文件的位置（字符串形式）、<codeph>URLRequest.url</codeph> 属性或引用这二者之一的变量。在应用程序安全沙箱以外的<ph platform="actionscript"> Flash Player 和</ph> AIR 内容中，您可以播放与 SWF 文件存储在同一个目录或子目录中的本地视频文件，但是不能导航到更高级别的目录。
	 
	 <p>
	 如果使用 Flash Media Server，<codeph>play()</codeph> 将使用以下参数：
	 </p>
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>名称</entry><entry>必需</entry><entry>说明</entry></row></thead><tbody><row>
	   <entry><codeph>name:Object</codeph></entry>
	   <entry>必需 </entry>
       <entry> 录制的文件的名称、<codeph>NetStream.publish()</codeph> 发布的实时数据的标识符或 <codeph>false</codeph>。如果为 <codeph>false</codeph>，流将停止播放并忽略任何其它参数。有关文件名语法的详细信息，请参阅此表后面的文件格式表。</entry>
	 </row><row>
	   <entry><codeph>start:Number</codeph></entry>
	   <entry>可选</entry>
	   <entry> 开始时间（以秒为单位）。允许的值为 -2、-1、0 或正数。默认值为 -2，它先查找实时流，然后查找录制流，如果都没有找到，则打开实时流。如果为 -1，则只播放实时流。如果为 0 或正数，则播放录制流，从第 <codeph>start</codeph> 秒开始。
	   </entry>
	 </row><row>
	   <entry> <codeph>len:Number</codeph> </entry>
	   <entry> 如果指定了 <codeph>start</codeph>，则是可选的。 </entry>
	   <entry> 回放持续时间（以秒为单位）。允许的值为 -1、0 或正数。默认值为 -1，它一直播放完实时流或录制流。如果为 0，则播放距录制流开始处 <codeph>start</codeph> 秒的单个帧。如果为正数，则播放实时流或录制流 <codeph>len</codeph> 秒。
	   </entry>
	 </row><row>
	   <entry> <codeph>reset:Object</codeph> </entry>
	   <entry> 如果指定了 <codeph>len</codeph>，则是可选的。 </entry>
	   <entry> 是否清除播放列表。默认值为 1 或 <codeph>true</codeph>，它清除任何以前的 <codeph>play</codeph> 调用并立即播放 <codeph>name</codeph>。如果为 0 或 <codeph>false</codeph>，则将流添加到播放列表中。如果为 2，则将播放列表保持不变，并同时返回所有流消息，而不是分段返回。如果为 3，则清除播放列表，并同时返回所有流消息。  </entry>
	 </row></tbody></tgroup></adobetable>
	 
     <p>
     可以播放下表中所列的文件格式。语法将随文件格式的不同而不同。</p>
     <p>
     <adobetable class="innertable">
     
     
     
     
     <tgroup cols="3"><thead><row><entry>文件格式</entry><entry>语法</entry><entry>示例</entry></row></thead><tbody><row>
     <entry>FLV</entry>
     <entry>以字符串形式指定流名称，不带文件扩展名。</entry>
     <entry><codeph>ns.play("myflvstream");</codeph></entry>
     </row><row>
     <entry>MP3 或 ID3</entry>
     <entry>以字符串形式指定流名称，带有前缀 <codeph>mp3:</codeph> 或 <codeph>id3:</codeph>，不带文件扩展名。</entry>
     <entry><codeph>ns.play("mp3:mymp3stream");</codeph> <codeph>ns.play("id3:myid3data");</codeph></entry>
     </row><row>
     <entry>基于 MPEG-4 的文件（如 F4V 和 MP4）</entry>
      <entry>以字符串形式指定流名称，带有前缀 <codeph>mp4:</codeph>，带有或不带文件扩展名。此前缀将向服务器表明，该文件在 MPEG-4 Part 14 容器格式中包含 H.264 编码的视频和 AAC 编码的音频。如果服务器上的文件有文件扩展名，请指定文件扩展名。如果文件扩展名是在 <codeph>publish()</codeph> 方法中指定的，请指定文件扩展名。</entry>
     <entry><codeph>ns.play("mp4:myvideo.f4v")</codeph> <codeph>ns.play("mp4:myvideo.mp4")</codeph> <codeph>ns.play("mp4:myvideo")</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     播放媒体文件。 
     
     <p>
     有关支持的编解码器和文件格式的信息，请参阅 <xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">http://www.adobe.com/go/hardware_scaling_en</xref> 和 <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>。</p>
     
	 <p>要查看视频数据，请创建一个 Video 对象，并调用 <codeph>Video.attachNetStream()</codeph> 方法。要从麦克风建立音频流，请使用 <codeph>NetStream.attachAudio()</codeph> 方法。可以使用 Microphone 对象控制音频的某些方面。</p>
	 
	 <p>调用 <codeph>DisplayObjectContainer.addChild()</codeph> 方法可将音频路由至显示列表上的某个对象。然后可以创建一个 Sound 对象来控制音频的某些方面。有关详细信息，请参阅 <codeph>DisplayObjectContainer.addChild()</codeph> 方法。</p>
	 
	 <p>如果无法找到视频文件，将分派 <codeph>NetStatusEvent</codeph> 对象。</p>
	 
     <p>在不使用 Flash Media Server 的情况下使用此方法时，有一些安全注意事项。受信任的本地沙箱或只能与远程内容交互的沙箱中的 文件可以加载并播放远程沙箱中的视频文件，但如果没有以 URL 策略文件的形式进行显式许可，则无法访问该远程文件的数据。<ph platform="actionscript">此外，还可以在包含 SWF 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数，以防止在 Flash Player 中运行的 SWF 文件使用此方法。</ph></p>
	 
      <p>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。</p>
     
      <p>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。</p>
     
	 <p>有关安全性的详细信息，请参阅以下部分：</p>
	 
     <ul>
     
     <li product="flex">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     <li product="flash">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
     <li><codeph>NetStream.checkPolicyFile</codeph> 属性。</li>
     </ul>
     
	 
     </apiDesc><example><b>Flash Media Server</b> 此示例从头开始播放录制的 F4V 文件，最长播放 100 秒。对于 MPEG-4 文件，如果服务器上的文件有文件扩展名，请在 <codeph>play()</codeph> 方法中指定文件扩展名。 
	 <codeblock>
     ns.play("mp4:record1.f4v", 0, 100, true);
	 </codeblock>
	 
	 </example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>DisplayObjectContainer.addChild()</linktext></link><link href="flash.net.xml#NetStream/checkPolicyFile"><linktext>checkPolicyFile</linktext></link></related-links><adobeApiEvent id="flash.net:NetStream:play_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在尝试播放用数字权限管理 (DRM) 加密的内容时分派。<codeph>code</codeph> 属性的值为 <codeph>"DRM.encryptedFLV"</codeph>。
	 
     </apiDesc></adobeApiEventDetail><shortdesc>在尝试播放用数字权限管理 (DRM) 加密的内容时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:NetStream:play2"><apiName>play2</apiName><shortdesc>
     开始播放媒体文件（提供一些播放选项）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>flash.net:NetStreamPlayOptions</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
     开始播放媒体文件（提供一些播放选项）。
     
     <p>此方法是 <codeph>NetStream.play()</codeph> 的增强版。与 <codeph>play()</codeph> 方法类似，<codeph>play2()</codeph> 方法开始播放媒体文件或对媒体文件进行排队以创建播放列表。在将此方法用于 Flash Media Server 时，它还可以请求服务器切换到不同的媒体文件。此过渡在客户端应用程序中以无缝方式进行。</p> 
     
     <p>使用 <codeph>play2()</codeph> 方法可切换到内容相同、但以不同比特率编码的流，或从播放列表中换出流。使用 <codeph>NetStreamInfo</codeph> 类可监视网络状况并根据数据切换流。还可以为功能不同的客户端切换流。使用 ActionScript 切换流称为<i>动态流</i>。有关详细信息，请在位于 <xref href="http://www.adobe.com/go/learn_fms_devguide_en">www.adobe.com/go/learn_fms_devguide_en</xref> 的“Adobe Flash Media Server Developer Guide”（《Adobe Flash Media Server 开发人员指南》）中搜索“dynamic streaming”（动态流）。Adobe 构建了一个称为 DynamicStream 的自定义 ActionScript 类，该类扩展了 NetStream 类。可以使用 DynamicStream 类在应用程序中实现动态流，而不必自行编写代码来检测网络状况。即使决定自行编写动态流代码，也请参考 DynamicStream 类，以查看可以正常工作的实现。从以下网址下载类及其文档：<xref href="http://www.adobe.com/go/fms_tools">www.adobe.com/go/fms_tools</xref>。</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions"><linktext>NetStreamPlayOptions</linktext></link><link href="flash.net.xml#NetStreamPlayTransitions"><linktext>NetStreamPlayTransitions</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:preloadEmbeddedData"><apiName>preloadEmbeddedData</apiName><shortdesc>
	 从本地存储的媒体文件中提取任何 DRM 元数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>flash.net:NetStreamPlayOptions</apiOperationClassifier><apiDesc>描述在处理内容文件期间要使用的选项的 NetStreamPlayOptions。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从本地存储的媒体文件中提取任何 DRM 元数据。
	 
	 <p>使用 <codeph>preloadEmbeddedMetaData()</codeph> 作为下载和缓存脱机播放所需的 DRM 凭证的第一步。在媒体文件中检测到嵌入的 DRM 元数据时，将向 NetStream client 的 <codeph>onDRMContentData</codeph> 函数传递一个 DRMContentData 对象。此 DRMContentData 对象包含获取凭证所需的信息，在播放内容时需要该凭证。将 DRMContentDataObject 对象传递给 DRMManager <codeph>loadVoucher()</codeph> 方法，以下载凭证。</p>
	 
	 <p>预加载 DRM 凭证的步骤包括：</p>
	 <ul>
	 <li>
	 <p>新建一个 NetStream 对象用于预加载元数据。</p>
	 </li>
	 <li>将一个回调函数赋给 NetStream <codeph>client</codeph> 的 <codeph>onDRMContentData</codeph> 属性。</li>
	 <li>新建一个 NetStreamPlayOptions 对象，并将其 <codeph>streamName</codeph> 属性设置为本地视频文件的 URL 字符串。</li>
	 <li>调用 <codeph>preloadEmbeddedMetadata()</codeph>，同时传入 NetStreamPlayOptions 对象。</li>
	 <li>作为对 <codeph>onDRMContentData</codeph> 回调的响应，调用 DRMManager <codeph>loadVoucher()</codeph> 方法，同时传入 DRMContentData 对象。如果 DRMContentData 对象的 <codeph>authenticationMethod</codeph> 属性的值为 <codeph>userNameAndPassWord</codeph>，则在加载凭证之前必须在媒体权限服务器上验证用户的身份。</li>
	 <li>关闭用于预加载的 NetStream。</li> 
	 </ul>
	 
	 <p><b>注意：</b>如果使用同一个 NetStream 对象预加载元数据和播放内容，则在开始播放前，必须等待预加载操作生成 <codeph>onPlayStatus</codeph> 调用。</p>
	 
	 <p>下载的凭证存储在本地缓存中。在线播放内容也会下载和缓存凭证。在查看受 DRM 保护的内容文件时，将自动从本地存储区检索缓存的凭证。使用 DRMManager 可管理凭证缓存。</p>
	   
	 <p><b>注意：</b>不支持通过 HTTP、HTTPS 或 RTMP 连接预加载 DRM 元数据。只能从文件系统上存储的文件预加载元数据。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/event:onDRMContentData"><linktext>onDRMContentData</linktext></link><link href="flash.net.drm.xml#DRMContentData"><linktext>flash.net.drm.DRMContentData</linktext></link><link href="flash.net.drm.xml#DRMManager/loadVoucher()"><linktext>flash.net.drm.DRMManager.loadVoucher()</linktext></link><link href="flash.net.drm.xml#DRMVoucher"><linktext>flash.net.drm.DRMVoucher</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:publish"><apiName>publish</apiName><shortdesc>
	 将音频流、视频流和文本消息流从客户端发送到 Flash Media Server，并可选择在传输期间录制该流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>标识该流的字符串。订阅此流的客户端必须在调用 <codeph>NetStream.play()</codeph> 时仍然传递此名称。流名称后面不要跟“/”。例如，不要使用流名称“<codeph>bolero/</codeph>”。 
     
     <p>
     可以发布下表所述格式的文件。语法将随文件格式的不同而不同。</p>
     <p>
     <adobetable class="innertable">
     
     
     
     
     <tgroup cols="3"><thead><row><entry>文件格式</entry><entry>语法</entry><entry>示例</entry></row></thead><tbody><row>
     <entry>FLV</entry>
     <entry>以字符串形式指定流名称，不带文件扩展名。</entry>
     <entry><codeph>ns.publish("myflvstream");</codeph></entry>
     </row><row>
     <entry>MP3 或 ID3</entry>
     <entry>以字符串形式指定流名称，带有前缀 <codeph>mp3:</codeph> 或 <codeph>id3:</codeph>，不带文件扩展名。</entry>
     <entry><codeph>ns.publish("mp3:mymp3stream");</codeph> <codeph>ns.publish("id3:myid3data");</codeph></entry>
     </row><row>
     <entry>基于 MPEG-4 的文件（如 F4V 和 MP4）</entry>
     <entry>以字符串形式指定流名称，带有前缀 <codeph>mp4:</codeph>，带有或不带文件扩展名。此前缀将向服务器表明，该文件在 MPEG-4 Part 14 容器格式中包含 H.264 编码的视频和 AAC 编码的音频。</entry>
     <entry><codeph>ns.publish("mp4:myvideo.f4v")</codeph> <codeph>ns.publish("mp4:myvideo.mp4");</codeph> <codeph>ns.publish("mp4:myvideo");</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>     
	 
	 </apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>指定如何发布该流的字符串。有效值为“<codeph>record</codeph>”、“<codeph>append</codeph>”和“<codeph>live</codeph>”。默认值为“<codeph>live</codeph>”。
	 <ul>
	 <li>如果传递“<codeph>record</codeph>”，则 Flash Media Server 将发布并录制实时数据，同时将录制的数据保存到名称与传递给 <codeph>name</codeph> 参数的值相匹配的新文件中。如果该文件存在，则覆盖该文件。</li>
	 <li>如果传递“<codeph>append</codeph>”，则 Flash Media Server 将发布并录制实时数据，同时将录制的数据追加到名称与传递给 <codeph>name</codeph> 参数的值相匹配的文件中。如果未找到与 <codeph>name</codeph> 参数相匹配的文件，则创建一个文件。 </li>
	 <li>如果省略此参数或传递“<codeph>live</codeph>”，则 Flash Media Server 将发布实时数据，但不录制这些数据。如果存在名称与传递给 <codeph>name</codeph> 参数的值相匹配的文件，则删除它。</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将音频流、视频流和文本消息流从客户端发送到 Flash Media Server，并可选择在传输期间录制该流。此方法仅供指定的流的发布者使用。
	 
	 <p>可以录制 FLV 或 MPEG-4 格式的文件。如果录制 MPEG-4 格式的文件，则必须使用 flattener 工具才能在另一个应用程序中编辑或播放该文件。要下载此工具，请参阅 <xref href="http://www.adobe.com/go/fms_tools" scope="external">www.adobe.com/go/fms_tools</xref>。</p>
     
     <p>请勿使用此方法播放已发布和录制的流。要播放流，请调用 <codeph>NetStream.play()</codeph> 方法。</p>
	 
	 <codeblock platform="actionscript">
	 var subscribeNS:NetStream = new NetStream(myNetConnection);
	 subscribeNS.play("streamToPlay");
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var subscribeNS = new air.NetStream(myNetConnection);
	 subscribeNS.play("streamToPlay");
	 </codeblock>
	 
     <p>在 Flash Media Server 录制流时，它会创建一个文件，并将其存储在服务器上应用程序目录的子目录中。每个流都存储在名称与传递给 <codeph>NetConnection.connect()</codeph> 的应用程序实例名称相匹配的目录中。服务器自动创建这些目录。例如，下面的代码连接到“lectureseries”应用程序，并录制“lecture”流。文件“lecture.flv”录制到 applications/lectureseries/streams/_definst_ 目录下：
     </p>
     
     <codeblock platform="actionscript">
     var myNC:NetConnection = new NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries");
     var myNS:NetStream = new NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <codeblock platform="javascript">
     var myNC = new air.NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries");
     var myNS = new air.NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <p>下例说明如何连接到同一应用程序的不同实例。文件“lecture.flv”录制到 /applications/lectureseries/streams/monday 目录下：</p>
     
     <codeblock>
     var myNC:NetConnection = new NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries/monday");
     var myNS:NetStream = new NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <codeblock platform="javascript">
     var myNC = new air.NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries/monday");
     var myNS = new air.NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
   	 
	 <p>此方法分派 <codeph>NetStatusEvent</codeph> 对象。例如，如果某个用户已在发布具有指定名称的流，则将分派 <codeph>code</codeph> 属性为<codeph>“NetStream.Publish.BadName”</codeph>的 <codeph>NetStatusEvent</codeph> 对象。有关详细信息，请参阅 <codeph>NetStatusEvent</codeph> 对象。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetConnection/connect()"><linktext>NetConnection.connect()</linktext></link><link href="" invalidHref="flash.net.xml#NetStatusEvent/info"><linktext>NetStatusEvent.info</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:receiveAudio"><apiName>receiveAudio</apiName><shortdesc>
	 指定传入的音频是否在流上播放。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>flag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>指定传入音频是在流上播放 (<codeph>true</codeph>) 还是不播放 (<codeph>false</codeph>)。默认值为 <codeph>true</codeph>。 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定传入的音频是否在流上播放。此方法仅可用于订阅了指定流的客户端，不可用于流的发布者。
	 
     <p>此方法主要用于 Flash Media Server；有关详细信息，请参阅类说明。</p> 
	 
	 <p>您可以在调用 <codeph>NetStream.play()</codeph> 方法并真正开始接收流之前或之后，调用此方法。例如，您可以将这些方法附加到某个按钮上，用户可以通过单击该按钮将传入的音频流静音或取消静音。</p>
	 
	 <p>如果指定的流仅包含音频数据，则将 <codeph>false</codeph> 值传递给该方法可以阻止 <codeph>NetStream.time</codeph> 进一步递增。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:receiveVideo"><apiName>receiveVideo</apiName><shortdesc>
	 指定传入的音频是否将在流上播放。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>flag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>指定传入视频是在此流上播放 (<codeph>true</codeph>) 还是不播放 (<codeph>false</codeph>)。默认值为 <codeph>true</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定传入的音频是否将在流上播放。此方法仅可用于订阅了指定流的客户端，不可用于流的发布者。
	 
     <p>此方法主要用于 Flash Media Server；有关详细信息，请参阅类说明。</p>
	 
	 <p>您可以在调用 <codeph>NetStream.play()</codeph> 方法并真正开始接收流之前或之后，调用此方法。例如，您可以将这些方法附加到某个按钮上，用户可以通过按该按钮来显示或隐藏传入的视频流。</p>
	 
	 <p>如果指定的流仅包含视频数据，则将 <codeph>false</codeph> 值传递给该方法可以阻止 <codeph>NetStream.time</codeph> 进一步递增。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:receiveVideoFPS"><apiName>receiveVideoFPS</apiName><shortdesc>
	 指定传入视频的帧速率。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>FPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>指定用于播放传入视频的每秒帧速率。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定传入视频的帧速率。此方法仅可用于订阅了指定流的客户端，不可用于流的发布者。
	 
     <p>此方法主要用于 Flash Media Server；有关详细信息，请参阅类说明。</p>
	 
	 <p>您可以在调用 <codeph>NetStream.play()</codeph> 方法并真正开始接收流之前或之后，调用此方法。例如，可以将这些方法附加到供用户设置传入视频帧速率的文本字段。</p>
     
     <p>要停止接收视频，请为 FPS 传递 0。要确定当前帧速率，请使用 <codeph>NetStream.currentFPS</codeph>。</p>
     
     <p>如果向 <codeph>FPS</codeph> 参数传递一个值以限制视频的帧速率，Flash Media Server 将会尝试在保持视频完整性的同时降低帧速率。服务器将发送最小数量的视频帧以满足每两个关键帧之间需要的速率。但请牢记，必须连续发送 I 帧（即，中间帧）；否则，视频将损坏。因此，在关键帧后需要立即连续发送需要的帧数。由于各个帧不是均匀分布的，因此在由于中断而截断的部分中，动作仍会平滑地显示。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:resetDRMVouchers"><apiName>resetDRMVouchers</apiName><shortdesc>
     删除所有本地缓存的数字权限管理 (DRM) 凭证数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, resetDRMVouchers
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>无法删除凭证数据。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     删除所有本地缓存的数字权限管理 (DRM) 凭证数据。
     <p>
     应用程序必须从媒体权限服务器重新下载任何必要的凭证，用户才能访问受保护的内容。调用此函数等同于调用 DRMManager 对象的 <codeph>resetDRMVouchers()</codeph> 函数。</p>
     
     </apiDesc><example conref="examples\NetStream.resetDRMVouchers.1.as"> 下例重置所有 DRM 凭证：
<codeblock>

NetStream.resetDRMVouchers();
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.drm.xml#DRMManager/resetDRMVouchers()"><linktext>flash.net.drm.DRMManager.resetDRMVouchers()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:resume"><apiName>resume</apiName><shortdesc>
	 恢复回放暂停的视频流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.resume, resume
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 恢复回放暂停的视频流。如果视频已在播放，则调用此方法将不会执行任何操作。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/togglePause()"><linktext>togglePause()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:seek"><apiName>seek</apiName><shortdesc>
	 
	 搜索与指定位置最接近的关键帧（在视频行业中也称为 I 帧）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.seek, seek
	 
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要在视频文件中移动到的时间近似值（以秒为单位）。使用 Flash Media Server 时，如果在 Application.xml 配置文件中将 <codeph>&lt;EnhancedSeek></codeph> 设置为 <codeph>true</codeph>（这是默认设置），服务器将在 <codeph>offset</codeph> 位置生成一个关键帧。 
	 
	 <ul>
	   <li>要返回到该流的开始处，请将 0 传递给 <codeph>offset</codeph>。</li>
	   <li>要从流的开始处向前搜寻，应传递将要前进的秒数。例如，要将播放头放在距开始处 15 秒的位置（或 15 秒之前的关键帧），请使用 <codeph>myStream.seek(15)</codeph>。</li>
	   <li>要搜索当前位置的相对位置，请传递 <codeph>NetStream.time + n</codeph> 或 <codeph>NetStream.time - n</codeph>，以分别从当前位置向前或向后搜索 <codeph>n</codeph> 秒的位置。例如，要从当前位置后退 20 秒，请使用 <codeph>NetStream.seek(NetStream.time - 20)</codeph>。</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 搜索与指定位置最接近的关键帧（在视频行业中也称为 I 帧）。关键帧位于从流的开始处算起的偏移位置（以秒为单位）。 
	 
     <p>
     视频流通常是使用以下两种类型的帧进行编码的：关键帧（或 I 帧）和 P 帧。关键帧包含完整图像；而 P 帧是一个中间帧，它在两个关键帧之间提供额外的视频信息。通常，视频流每 10 到 50 帧中有一个关键帧。 
     </p>
     
     <p>
     在 Flash Media Server 上，<codeph>seek()</codeph> 的行为是由 <codeph>Application.xml</codeph> 配置文件中的 <codeph>EnhancedSeek</codeph> 元素的值控制的。
     </p>
     
     <p>
     如果 <codeph>EnhancedSeek</codeph> 为 <codeph>false</codeph>，服务器将使用标准搜索模式。在标准搜索模式下，服务器开始从最近的关键帧进行流式传输。例如，如果视频在第 0 秒和第 10 秒处各有一个关键帧，则搜索第 4 秒位置的操作将导致使用 0 秒处的关键帧在第 4 秒处开始播放。在到达下一个关键帧（在第 10 秒处）之前，视频将保持冻结。为了获得更好的搜索体验，您需要缩短关键帧间隔。在标准搜索模式下，无法在两个关键帧之间的位置启动视频。
     </p>
     
     <p>
     如果 <codeph>EnhancedSeek</codeph> 为 <codeph>true</codeph>（默认值），服务器将基于前一个关键帧和所有中间的 P 帧在 <codeph>offset</codeph> 位置生成一个新的关键帧。不过，这会在服务器上产生较高的处理负载，并且生成的关键帧中可能会发生扭曲。如果视频编解码器为 On2，则会将搜索点之前的关键帧以及该关键帧和搜索点之间的所有 P 帧发送到客户端。
     </p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:send"><apiName>send</apiName><shortdesc>
	 在发布的流上向所有订阅客户端发送一条消息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>handlerName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要发送的消息；还有接收消息使用的 ActionScript 处理函数的名称。处理函数的名称只能为单级形式（即不能是父/子多级形式）并相对于流对象。不要对处理函数名称使用保留字。例如，将“<codeph>close</codeph>”用作处理函数名称将导致该方法失败。如果使用 Flash Media Server，请使用 <codeph>@setDataFrame</codeph> 将元数据关键帧添加到实时流中，或者使用 <codeph>@clearDataFrame</codeph> 删除关键帧。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>可以是任何类型的可选参数。它们经过序列化并通过该连接发送，而接收处理函数则以相同的顺序接收它们。如果某个参数为循环对象（如循环的链接列表），则序列化函数可以正确处理引用。使用 Flash Media Server 时，如果 <codeph>@setDataFrame</codeph> 是第一个参数，请使用 <codeph>onMetaData</codeph> 作为第二个参数；对于第三个参数，请传递将元数据设置为属性的 <codeph>Object</codeph> 或 <codeph>Array</codeph> 实例。有关建议的属性名称的列表，请参阅<xref href="http://www.adobe.com/go/learn_fms_devguide_en" scope="external">《Flash Media Server 开发人员指南》</xref>。如果将 <codeph>@clearDataFrame</codeph> 作为第一个参数，请使用 <codeph>onMetaData</codeph> 作为第二个参数，而不使用第三个参数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在发布的流上向所有订阅客户端发送一条消息。此方法仅供指定的流的发布者使用，并与 Flash Media Server 一起使用。要处理并响应该消息，请在 <codeph>NetStream</codeph> 对象上创建一个处理函数，例如，<codeph>ns.HandlerName</codeph>。
     
     <p>
     <ph platform="actionscript">Flash Player 或</ph>AIR 不对方法或方法的数据、对象原型变量或不可枚举的变量进行序列化处理。对于显示对象，<ph platform="actionscript">Flash Player 或 </ph> AIR 仅对路径而不对数据进行序列化处理。
	 </p>
	 
	 <p>
	 您可以调用 <codeph>send()</codeph> 方法，将数据关键帧添加到发送给 Flash Media Server 的实时流中。数据关键帧是发布者添加到实时流中的消息。通常，在从摄像头和麦克风为实时流捕获数据之前，使用数据关键帧将元数据添加到该流中。在发布实时流期间，发布者可以随时添加数据关键帧。只要发布者连接到服务器上，就会将数据关键帧保存在服务器的内存中。 
	 </p>
	 <p>
	 如果客户端是在添加数据关键帧之前订阅实时流的，则会在添加后立即收到该关键帧。如果客户端是在添加数据关键帧之后订阅实时流的，则会在订阅时收到该关键帧。
	 </p>
	 <p>
	 要将元数据关键帧添加到发送给 Flash Media Server 的实时流中，请使用 <codeph>@setDataFrame</codeph> 作为处理函数名称，后跟两个其它参数，例如：
	 </p>
	 
	 <codeblock platform="actionscript">
	 var ns:NetStream = new NetStream(nc);
	 ns.send("@setDataFrame", "onMetaData", metaData);
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var ns = new air.NetStream(nc);
	 ns.send("@setDataFrame", "onMetaData", metaData);
	 </codeblock>
	 
	 <p>
	 <codeph>@setDataFrame</codeph> 参数引用 Flash Media Server 中内置的一个特殊处理函数。<codeph>onMetaData</codeph> 参数是客户端应用程序中侦听 <codeph>onMetaData</codeph> 事件并检索元数据的回调函数的名称。第三项 <codeph>metaData</codeph> 是包含用于定义元数据值的属性的 <codeph>Object</codeph> 或 <codeph>Array</codeph> 实例。发布者应该设置订阅者易于理解的属性名称；有关建议的属性名称的列表，请参阅<xref href="http://www.adobe.com/go/learn_fms_devguide_cn" scope="external">《Flash Media Server 开发人员指南》</xref>。
	 </p>
	 
	 <p>可以使用 <codeph>@clearDataFrame</codeph> 清除已在流中设置的元数据关键帧：
	 </p>
	 <codeblock>
	 ns.send("@clearDataFrame", "onMetaData");
	 </codeblock>
	 
	 
	 </apiDesc><example conref="examples\NetStream.send.1.as"> 下面的示例创建两个 <codeph>NetStream</codeph> 对象。一个对象用于将实时流发布到服务器上；另一个对象用于订阅该流。
<codeblock>
package {
   import flash.display.Sprite;
   import flash.net.NetConnection;
   import flash.net.NetStream;
   import flash.events.NetStatusEvent;
   import flash.media.Video;
   import flash.utils.setTimeout;

 
   public class TestExample extends Sprite
   {
     var nc:NetConnection = new NetConnection();
     var ns1:NetStream;
     var ns2:NetStream;
     var vid:Video = new Video(300,300);
     var obj:Object = new Object();
 
     public function TestExample() {
        nc.objectEncoding = 0;
        nc.addEventListener("netStatus", onNCStatus);
        nc.connect("rtmp://localhost/FlashVideoApp");
        addChild(vid); 
     }
  
     function onNCStatus(event:NetStatusEvent):void {
       switch (event.info.code) {
           case "NetConnection.Connect.Success":
               trace("You've connected successfully");
               ns1 = new NetStream(nc);
               ns2 = new NetStream(nc);
               
               ns1.client = new CustomClient();
               ns1.publish("dummy", "live");
    
               ns2.play("dummy");
               ns2.client = new CustomClient();
               vid.attachNetStream(ns2);
               setTimeout(sendHello, 3000);
               break;
              
           case "NetStream.Publish.BadName":
               trace("Please check the name of the publishing stream" );
               break;
        }   
     }

     function sendHello():void {
         ns1.send("myFunction", "hello");
     }       
   }
 }
 
 class CustomClient {
    public function myFunction(event:String):void {
       trace(event);
    }
 }
</codeblock></example><example conref="examples\NetStream.send.2.as"> 下面的示例创建元数据，并将其添加到实时流中：
<codeblock>
private function netStatusHandler(event:NetStatusEvent):void {
     switch (event.info.code) {  
        case "NetStream.Publish.Start":
            var metaData:Object = new Object();
            metaData.title = "myStream";
            metaData.width = 400;
            metaData.height = 200;
            ns.send("&amp;#64;setDataFrame", "onMetaData", metaData);
            ns.attachCamera( Camera.getCamera() );
            ns.attachAudio( Microphone.getMicrophone() );        
    }
}
</codeblock></example><example conref="examples\NetStream.send.3.as"> 为了响应添加到视频中的数据关键帧，客户端需要定义 <codeph>onMetaData</codeph> 事件处理函数。<codeph>onMetaData</codeph> 事件处理函数不是使用 <codeph>addEventListener()</codeph> 注册的，而是一个具有名称 <codeph>onMetaData</codeph> 的回调函数，例如：
<codeblock>
 public function onMetaData(info:Object):void {
    trace("width: " + info.width);
    trace("height: " + info.height);
 }
</codeblock></example><example conref="examples\NetStream.send.4.as">  下面的示例说明如何在服务器上创建播放列表：
<codeblock>
 // Create a NetStream for playing
 var my_ns:NetStream = new NetStream(my_nc);
 my_video.attachNetStream(my_ns);
 
 // Play the stream record1
 my_ns.play("record1", 0, -1, true);
 
 // Switch to the stream live1 and play for 5 seconds.  
 // Since reset is false, live1 will start to play after record1 is done.
 my_ns.play("live1", -1 , 5, false);
</codeblock></example><example conref="examples\NetStream.send.5.as">  如果录制的视频文件只包含数据消息，您可以按最初录制视频文件时的速度进行播放，也可以同时获取所有数据消息。
<codeblock>
 //To play at normal speed
 var my_ns:NetStream = new NetStream(my_nc);
 my_ns.play("log", 0, -1);
 
 //To get the data messages all at once
 my_ns.play("log", 0, -1, 3);
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:setDRMAuthenticationCredentials"><apiName>setDRMAuthenticationCredentials</apiName><shortdesc>
     设置查看基础加密内容所需要的 DRM 身份验证凭据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, setDRMAuthenticationCredentials
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>userName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>有效的用户名凭据。
     </apiDesc></apiParam><apiParam><apiItemName>password</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>与提供的用户名对应的密码凭据。
     </apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>一个字符串，指定提供哪种类型的身份验证凭据。有效值为<codeph>“drm”</codeph>和<codeph>“proxy”</codeph>。默认值为<codeph>“drm”</codeph>。
     <ul>
     <li>使用<codeph>“drm”</codeph>身份验证类型时，提供的凭据将针对 Flash Media Rights Management Server (FMRMS) 进行身份验证。</li>
     <li>使用<codeph>“proxy”</codeph>身份验证类型时，提供的凭据将针对代理服务器进行身份验证且必须与代理服务器所需的凭据相匹配。例如，<codeph>“proxy”</codeph>选项允许应用程序针对代理服务器进行身份验证（如果企业要求用户通过此步骤后才能访问 Internet）。除非使用匿名身份验证，否则在代理身份验证之后，用户仍需要针对 FMRMS 进行身份验证才能获取凭证并播放内容。您可以再次与<codeph>“drm”</codeph>选项一起使用 <codeph>setDRMAuthenticationcredentials()</codeph> 以针对 FMRMS 进行身份验证。</li>
     </ul>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     设置查看基础加密内容所需要的 DRM 身份验证凭据。
     <p>
     <codeph>setDRMAuthenticationCredentials()</codeph> 方法提供的凭据与内容提供程序或代理服务器已知并接受的凭据相匹配。这些凭据与用户获取权限以查看内容时使用的凭据相同。
     </p>
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#DRMAuthenticateEvent"><linktext>flash.events.DRMAuthenticateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:togglePause"><apiName>togglePause</apiName><shortdesc>
	 暂停或恢复流的回放。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.resume, resume
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 暂停或恢复流的回放。第一次调用此方法时，将暂停播放；下一次调用此方法时，将恢复播放。您可以使用此方法，允许用户通过按某个按钮来暂停或恢复回放。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/resume()"><linktext>resume()</linktext></link></related-links></apiOperation><apiValue id="flash.net:NetStream:CONNECT_TO_FMS"><apiName>CONNECT_TO_FMS</apiName><shortdesc>
     一个静态对象，用作 NetStream 实例的构造函数的参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>connectToFMS</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     一个静态对象，用作 NetStream 实例的构造函数的参数。它是 NetStream 构造函数中的第二个参数的默认值；对于渐进式媒体播放，应用程序将不使用默认值。若使用此参数，则会导致构造函数建立与 Flash Media Server 实例的连接。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:DIRECT_CONNECTIONS"><apiName>DIRECT_CONNECTIONS</apiName><shortdesc>
     创建同级对同级发行者连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>directConnections</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     创建同级对同级发行者连接。将第二个（可选）参数的此字符串传递给 NetStream 实例的构造函数。利用此字符串，应用程序可以出于向客户端发布音频和视频的目的而创建 NetStream 连接。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:bufferLength:get"><apiName>bufferLength</apiName><shortdesc>
	 数据当前存在于缓冲区中的秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bufferLength, bufferLength
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 数据当前存在于缓冲区中的秒数。您可以将此属性与 <codeph>bufferTime</codeph> 属性一起使用，以评估缓冲区将近填满的程度；例如，向正等待数据加载到缓冲区中的用户显示反馈。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bufferTime:set"><apiName>bufferTime</apiName><shortdesc>
	 指定在开始显示流之前需要多长时间将消息存入缓冲区。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.setBufferTime, setBufferTime
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定在开始显示流之前需要多长时间将消息存入缓冲区。例如，要确保流的最初 15 秒无中断播放，请将 <codeph>bufferTime</codeph> 设置为 15；应用程序将在把 15 秒的数据存入缓冲区后才开始播放该流。
	 
	 <p>默认值是 0.1（十分之一秒）。要确定当前位于缓冲区中的秒数，请使用 <codeph>bufferLength</codeph> 属性。</p>
	 
     <p><b>注意：</b>为了避免在对预先录制的（非实时）内容进行流处理时发生扭曲，不要将 <codeph>Netstream.bufferTime</codeph> 为 0。对于预先录制的内容，默认情况下应用程序将使用输入缓冲区对媒体数据进行排队并正确播放媒体。对于预先录制的内容，请使用默认设置或延长缓冲时间。</p>
     
     <p>从 Flash Player 9.0.115.0 开始，在调用 <codeph>NetStream.pause()</codeph> 时，Flash Player 不再清除缓冲区。在 Flash Player 9.0.115.0 之前，恢复播放之前 Flash Player 将等待缓冲区填满，这通常会导致延迟。</p>
     	 
     	 <p>对于一次暂停，<codeph>NetStream.bufferLength</codeph> 属性的限值为 60 秒或二倍的 <codeph>NetStream.bufferTime</codeph> 值（取二者之中的较大值）。例如，如果 <codeph>bufferTime</codeph> 为 20 秒，在 <codeph>NetStream.bufferLength</codeph> 为较大值 20~~2 (40) 或 60 之前，Flash Player 将一直进行缓冲，因此在本例中，在 <codeph>bufferLength</codeph> 为 60 之前，Flash Player 将一直进行缓冲。如果 <codeph>bufferTime</codeph> 为 40 秒，在 <codeph>bufferLength</codeph> 为较大值 40~~2 (80) 或 60 之前，则 Flash Player 将一直进行缓冲，因此在本例中，在 <codeph>bufferLength</codeph> 为 80 秒之前，Flash Player 将一直进行缓冲。</p>
     	 
     	 <p><codeph>bufferLength</codeph> 属性还有一个绝对限制。如果对 <codeph>pause()</codeph> 的任何调用导致 <codeph>bufferLength</codeph> 增大到 600 秒以上或 <codeph>bufferTime</codeph> ~~ 2 的值（取二者中的较大值），Flash Player 将刷新缓冲区并将 <codeph>bufferLength</codeph> 重置为 0。例如，如果 <codeph>bufferTime</codeph> 为 120 秒，当 <codeph>bufferLength</codeph> 达到 600 秒时，Flash Player 将刷新缓冲区；如果 <codeph>bufferTime</codeph> 为 360 秒，当 <codeph>bufferLength</codeph> 达到 720 秒时，Flash Player 将刷新缓冲区。</p>
     	 
     	 <p><b>提示</b>：例如，在查看器监视商用版的同时，可以在代码中使用 <codeph>NetStream.pause()</codeph> 来缓冲数据，然后在开始播放主视频时取消暂停。</p>
     	 
     	 <p>有关新的暂停行为的详细信息，请参阅 <xref href="http://www.adobe.com/go/learn_fms_smartpause_en" scope="external">http://www.adobe.com/go/learn_fms_smartpause_en</xref>。</p>
     <p>
     <b>Flash Media Server</b>。缓冲行为取决于缓冲时间是在发布流还是订阅流中设置的。对于发布流，<codeph>bufferTime</codeph> 指定在应用程序开始删除帧之前传出缓冲区可以增长多长时间。在高速连接上，不必担心缓冲时间问题；发送数据的速度几乎与应用程序将数据存入缓冲区一样快。但在速度较慢的连接上，应用程序将数据存入缓冲区与将数据发送到客户端的速度可能会有很大差异。 
     </p>
     
     <p>
     对于订阅流，<codeph>bufferTime</codeph> 指定在开始显示流之前需要花多长时间将传入数据存入缓冲区。例如，如果要确保流的最初 15 秒在播放时不会出现中断，请将 <codeph>bufferTime</codeph> 设置为 15；Flash 在将 15 秒的数据存入缓冲区后才开始播放该流。
     </p>
     
     <p>
     在播放录制流时，如果 <codeph>bufferTime</codeph> 为 0，Flash 会将其设置为较小的值（大约为 10 毫秒）。如果以后播放实时流（例如，从播放列表中），则会永久保留此缓冲时间。即，流的 <codeph>bufferTime</codeph> 始终为非零值。 
     </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.net.xml#bufferTime/bufferLength"><linktext>bufferLength</linktext></link><link href="" invalidHref="flash.net.xml#bufferTime/time"><linktext>time</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 已加载到应用程序中的数据的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bytesLoaded, bytesLoaded
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 已加载到应用程序中的数据的字节数。您可以将此属性与 <codeph>bytesTotal</codeph> 属性一起使用，以评估缓冲区将近填满的程度；例如，向正等待数据加载到缓冲区中的用户显示反馈。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bytesTotal"><linktext>bytesTotal</linktext></link><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 正加载到应用程序中的文件的总大小（以字节为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bytesTotal, bytesTotal
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 正加载到应用程序中的文件的总大小（以字节为单位）。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:checkPolicyFile:get"><apiName>checkPolicyFile</apiName><shortdesc>
	 指定应用程序在开始加载视频文件之前，是否应尝试从所加载视频文件的服务器中下载跨域策略文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>: please review at same time: checkPolicyFile property in LoaderContext
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 指定应用程序在开始加载视频文件之前，是否应尝试从所加载视频文件的服务器中下载跨域策略文件。如果对渐进式视频下载（独立的文件）使用 NetStream 对象，或者加载的文件位于进行调用的 文件所在的域外部，则应用此属性。当使用 NetStream 对象获取 RTMP 资源时，忽略此属性。
	 
     <p>如果从执行调用的 SWF 文件所在的域外部加载视频文件，而且需要使用 <codeph>BitmapData.draw()</codeph> 方法对视频进行像素级访问，则将此属性设置为 <codeph>true</codeph>。在加载时未将 <codeph>checkPolicyFile</codeph> 属性设置为 <codeph>true</codeph> 的情况下，如果调用 <codeph>BitmapData.draw()</codeph>，可能会收到一个 <codeph>SecurityError</codeph> 异常，因为没有下载所需的策略文件。</p>
	 
	 <p>如果不需要对正在加载的视频进行像素级访问，则不要将 <codeph>checkPolicyFile</codeph> 设置为 <codeph>true</codeph>。检查策略文件会占用网络带宽，并可能延迟下载的开始时间。</p>
	 
	 <p>如果将 <codeph>checkPolicyFile</codeph> 设置为 <codeph>true</codeph>，则调用 <codeph>NetStream.play()</codeph> 方法时，<ph platform="actionscript">Flash Player 或 </ph>AIR 运行时必须成功下载一个相关的跨域策略文件，或者必须先确定在开始下载对象（在对 <codeph>NetStream.play()</codeph> 的调用中指定）之前，不存在这种策略文件。为了确认是否存在策略文件，<ph platform="actionscript">Flash Player 或 </ph>AIR 运行时将执行以下操作，具体顺序如下：</p>
	 
	 <ol>
	 
     <li>应用程序考虑已经下载的策略文件。</li>
	 
	 <li>应用程序尝试下载在 <codeph>Security.loadPolicyFile()</codeph> 方法调用中指定的任何未处理的策略文件。</li>
	 
	 <li>应用程序尝试从与传递给 <codeph>NetStream.play()</codeph> 的 URL 相对应的默认位置下载策略文件，在与该 URL 所在的同一台服务器上，该默认位置为 <codeph>/crossdomain.xml</codeph>。</li>
	 
	 </ol>
	 
	 <p>无论哪种情况，<ph platform="actionscript">Flash Player 或 </ph>AIR 运行时都要求视频服务器上存在一个正确的策略文件，该文件可以提供对传递给 <codeph>play()</codeph> 的 URL 处（根据该策略文件的位置）的对象的访问，并允许执行调用代码的文件所在的域通过一个或多个 <codeph>&lt;allow-access-from></codeph> 标签来访问视频。</p>
	 
	 <p>如果将 <codeph>checkPolicyFile</codeph> 设置为 <codeph>true</codeph>，则应用程序会等到策略文件确认完毕才下载视频。等待对视频数据执行任何像素级操作（如调用 <codeph>BitmapData.draw()</codeph>），直至从 NetStream 对象收到 <codeph>onMetaData</codeph> 或 <codeph>NetStatus</codeph> 事件。</p>
	 
	 <p>如果将 <codeph>checkPolicyFile</codeph> 设置为 <codeph>true</codeph>，但未找到相关的策略文件，则您只有执行需要策略文件的操作时，才会接收到错误，然后应用程序会引发 SecurityError 异常。</p>
	 
	 <p>如果从使用服务器端 HTTP 重定向的 URL 中下载文件，请谨慎使用 <codeph>checkPolicyFile</codeph>。应用程序尝试检索与您在 <codeph>NetStream.play()</codeph> 中指定的初始 URL 相对应的策略文件。如果最终文件由于 HTTP 重定向而来自不同的 URL，则最初下载的策略文件可能不适用于该文件的最终 URL，该 URL 对安全决策至关重要。</p>
	 
	 <p>有关策略文件的详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“Flash Player 安全性”一章。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link><link href="flash.net.xml#NetStream/event:netStatus"><linktext>netStatus</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:client:get"><apiName>client</apiName><shortdesc>
     指定对其调用回调方法以处理流或 FLV 文件数据的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>必须将 <codeph>client</codeph> 属性设置为非空对象。
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     指定对其调用回调方法以处理流或 FLV 文件数据的对象。默认对象为 <codeph>this</codeph>，将创建 NetStream 对象。如果将 <codeph>client</codeph> 属性设置为另一个对象，则将对该对象调用回调方法。<codeph>NetStream.client</codeph> 对象可以调用以下函数并接收关联的数据对象：<codeph>onCuePoint()</codeph>、<codeph>onImageData()</codeph>、<codeph>onMetaData()</codeph>、<codeph>onPlayStatus()</codeph>、<codeph>onTextData()</codeph> 和 <codeph>onXMPData()</codeph>。
     <p><b>将 <codeph>client</codeph> 属性与事件处理函数相关联：</b></p>
     <p><ol><li>创建一个对象并将其分配给 NetStream 对象的 <codeph>client</codeph> 属性：
     <codeblock>
     var customClient:Object = new Object();
     my_netstream.client = customClient;
     </codeblock>
     </li>
     <li>为所需数据事件分配一个处理函数作为客户端对象的属性：
     <codeblock>
     customClient.onImageData = onImageDataHandler;           
     </codeblock>
     </li>
     <li>编写处理函数以接收数据事件对象，比如：
     <codeblock>
      public function onImageDataHandler(imageData:Object):void {
              trace("imageData length: " + imageData.data.length);
      }
     </codeblock></li>
     </ol></p>
     <p>当数据经过流或在回放过程中传递时，将用该数据填充数据事件对象（本例中为 <codeph>imageData</codeph> 对象）。请参阅 <codeph>onImageData</codeph> 的描述，其中包括一个分配给 <codeph>client</codeph> 属性的对象的完整示例。</p>
     <p><b>将 <codeph>client</codeph> 属性与子类相关联：</b></p>
     <p><ol><li>用处理函数创建一个子类以接收数据事件对象：
     <codeblock>
     class CustomClient {
        public function onMetaData(info:Object):void {
            trace("metadata: duration=" + info.duration + " framerate=" + info.framerate);
     }
     </codeblock>
     </li>
     <li>将子类的实例分配给 NetStream 对象的 <codeph>client</codeph> 属性：
     <codeblock>
     my_netstream.client = new CustomClient();
     </codeblock>
     </li>
     </ol></p>     
     <p>当数据经过流或在回放过程中传递时，将用该数据填充数据事件对象（本例中为 <codeph>info</codeph> 对象）。请参阅 NetStream 类末尾的类示例，该示例演示了将一个子类实例分配给 <codeph>client</codeph> 属性的过程。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/event:onPlayStatus"><linktext>onPlayStatus</linktext></link><link href="flash.net.xml#NetStream/event:onTextData"><linktext>onTextData</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:currentFPS:get"><apiName>currentFPS</apiName><shortdesc>
	 每秒显示的帧的数目。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.currentFPS, currentFPS
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 每秒显示的帧的数目。如果要导出视频文件以在多个系统上回放，您可以在测试期间检查该值，以帮助确定在导出该文件时应用的压缩量。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:farID:get"><apiName>farID</apiName><shortdesc>
     连接到此 NetStream 实例的远端的标识符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     连接到此 <codeph>NetStream</codeph> 实例的远端的标识符。仅为 RTMFP 连接定义此属性。
     
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:farNonce:get"><apiName>farNonce</apiName><shortdesc>
     由此流的另一端实际选择的值，对于此连接唯一。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     由此流的另一端实际选择的值，对于此连接唯一。此值出现在流的另一端作为其 <codeph>nearNonce</codeph> 值。仅为 RTMFP 连接定义此属性。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:info:get"><apiName>info</apiName><shortdesc>
     返回一个 NetStreamInfo 对象，其属性包含有关服务质量的统计信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.net:NetStreamInfo</apiValueClassifier></apiValueDef><apiDesc>
     返回一个 NetStreamInfo 对象，其属性包含有关服务质量的统计信息。此对象是当前状态的快照。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo"><linktext>NetStreamInfo</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:liveDelay:get"><apiName>liveDelay</apiName><shortdesc>
	 在实时（未缓冲的）模式下，数据在订阅流的缓冲区中停留的秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Property
	 
	 </category></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 在实时（未缓冲的）模式下，数据在订阅流的缓冲区中停留的秒数。此属性指定当前的网络传输延迟（延迟时间）。
	 
	 <p>此属性主要用于服务器（如 Flash Media Server）；有关详细信息，请参阅类说明。</p>
	 
	 <p>您可以获取此属性的值来粗略估量流的传输质量，并将其传达给用户。 </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:maxPauseBufferTime:set"><apiName>maxPauseBufferTime</apiName><shortdesc>
     指定在暂停模式下需要多长时间（以秒为单位）将消息存入缓冲区。</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指定在暂停模式下需要多长时间（以秒为单位）将消息存入缓冲区。可以使用此属性来限制暂停模式下进行的缓冲程度。<codeph>NetStream.bufferLength</codeph> 的值一旦到达此限制，就会停止缓冲。如果未设置此值，则将默认值限制为 60 秒或每个暂停的 <codeph>NetStream.bufferTime</codeph> 值的两倍，以较大的值为准。
     </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.net.xml#maxPauseBufferTime/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:nearNonce:get"><apiName>nearNonce</apiName><shortdesc>
     由流的这一端实际选择的值，对于此连接唯一。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     由流的这一端实际选择的值，对于此连接唯一。此值出现在流的另一端作为其 <codeph>farNonce</codeph> 值。仅为 RTMFP 连接定义此属性。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
	 此 NetStream 对象的对象编码（AMF 版本）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 此 NetStream 对象的对象编码（AMF 版本）。NetStream 对象从关联的 NetConnection 对象继承了它的 <codeph>objectEncoding</codeph> 值。如果 ActionScript 3.0 SWF 文件需要与在 Flash Player 9 之前发布的服务器进行通信，则了解此属性非常重要。有关详细信息，请参阅 NetConnection 类中 <codeph>objectEncoding</codeph> 属性的描述。
	 
	 <p>此属性的值取决于流是本地还是远程的。本地流返回 <codeph>NetConnection.defaultObjectEncoding</codeph> 的值。在这些流上，<codeph>null</codeph> 被传递给 <codeph>NetConnection.connect()</codeph> 方法。远程流返回与服务器建立的连接的对象编码。通过远程流连接到服务器。</p>
	 
	 <p>如果您在未连接时就尝试读取此属性，或者尝试更改此属性，则应用程序将引发一个异常。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>NetConnection.objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:peerStreams:get"><apiName>peerStreams</apiName><shortdesc>
	 
     一个对象，其中容纳了侦听此发布方 NetStream 实例的所有订阅方 NetStream 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 
     一个对象，其中容纳了侦听此发布方 NetStream 实例的所有订阅方 NetStream 实例。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 在此 NetStream 对象中控制声音。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 在此 NetStream 对象中控制声音。有关详细信息，请参阅 SoundTransform 类。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:time:get"><apiName>time</apiName><shortdesc>
	 播放头的位置（以秒为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.time, time
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 播放头的位置（以秒为单位）。
	 <p>
	 <b>Flash Media Server</b> 对于订阅流，是指流已播放的秒数。对于发布流，是指流已发布的秒数。此数字精确到千分位；将其乘以 1000 可得出流已播放的毫秒数。
	 </p>
	 <p>
	 对于订阅流，如果服务器停止发送数据，但流保持打开，则 <codeph>time</codeph> 属性的值将停止增加。当服务器重新开始发送数据时，该值将继续增加，起始位置为上次停止处（服务器停止发送数据时）。 
	 </p>
	 <p>
     当流从一个播放列表元素切换到另一个播放列表元素时，<codeph>time</codeph> 的值将继续增加。如果调用 <codeph>NetStream.play()</codeph> 并将 <codeph>reset</codeph> 设置为 <codeph>1</codeph> 或 <codeph>true</codeph>，或者调用 <codeph>NetStream.close()</codeph>，则会将此属性设置为 0。 
	 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:LocalConnection"><apiName>LocalConnection</apiName><shortdesc>
 使用 LocalConnection 类可以创建调用另一个 LocalConnection 对象中的方法的 LocalConnection 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 LocalConnection 类可以创建调用另一个 LocalConnection 对象中的方法的 LocalConnection 对象。通信可以通过以下方式进行：
 
 <ul>
 		<li>在一个 SWF 文件内</li>
 		<li>在多个 SWF 文件之间</li>
 		<li>在 AIR 应用程序的内容（基于 SWF 或基于 HTML）之间</li>
		<li>在 AIR 应用程序的内容（基于 SWF 或基于 HTML）和运行于浏览器中的 SWF 内容之间</li>
 </ul>
 
 <p>通过本地连接，可以在 SWF 文件之间进行这种通信，而不用使用 <codeph>fscommand()</codeph> 或 JavaScript。LocalConnection 对象只能在运行于同一台客户端计算机上的文件之间进行通信，但这些文件可以在不同的应用程序中运行。例如，浏览器中运行的文件和 Adobe AIR 中运行的 SWF 文件。 </p>
 
 <p platform="actionscript">ActionScript 3.0 中创建的 LocalConnection 对象可以与 ActionScript 1.0 或 2.0 中创建的 LocalConnection 对象通信。反之亦然：ActionScript 1.0 或 2.0 中创建的 LocalConnection 对象可以与 ActionScript 3.0 中创建的 LocalConnection 对象通信。Flash Player 可自动处理不同版本 LocalConnection 对象间的通信。</p>
 
 <p>为了了解如何使用 LocalConnection 对象在两个文件之间进行通信，了解每个文件中使用的命令非常有用。一个 文件被称为<i>发送方</i> 文件；此文件包含要调用的方法。发送方 文件必须包含一个 LocalConnection 对象和对 <codeph>send()</codeph> 方法的调用。另一个 文件被称为<i>接收方</i> 文件；此文件为调用方法的文件。接收方 文件必须包含另一个 LocalConnection 对象和对 <codeph>connect()</codeph> 方法的调用。</p>
 
 <p><codeph>send()</codeph> 和 <codeph>connect()</codeph> 的使用将有所不同，这取决于 文件是在同一个域中、在具有可预知域名的不同域中还是在具有不可预知域名（即动态域名）的不同域中。下文将说明这三种不同的情况，并针对每种情况分别提供代码示例。</p>
 
 <p><b>同一个域</b>。这是使用 LocalConnection 对象最简单的情况，它只允许在位于同一个域中的 LocalConnection 对象间通信，这是因为默认情况下，应用程序允许同域通信。当同一个域中的两个 文件通信时，无需实施任何特殊的安全措施，而只需将 <codeph>connectionName</codeph> 参数的同一个值传递给 <codeph>connect()</codeph> 和 <codeph>send()</codeph> 方法。</p>
 
 <p><adobeimage alt="从相同的域中加载" href="../../images/localconnection_samedomains.gif"/></p>
 
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.connect('myConnection');

// sendingLC is in http://www.domain.com/sending.swf
// myMethod() is defined in sending.swf
sendingLC.send('myConnection', 'myMethod');
</codeblock>
 <p><b>具有可预知域名的不同域</b>。当不同域中的两个 SWF 文件通信时，需要通过调用 <codeph>allowDomain()</codeph> 方法来允许在这两个不同域之间进行通信。还需要在 <codeph>send()</codeph> 方法中使用接收方 LocalConnection 对象的域名限定连接名：</p>
 
 <p><adobeimage alt="从不同的域中加载" href="../../images/localconnection_differentdomains.gif"/></p>
 
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.allowDomain('www.anotherdomain.com');
receivingLC.connect('myConnection');

// sendingLC is in http://www.anotherdomain.com/sending.swf
sendingLC.send('www.domain.com:myConnection', 'myMethod');
</codeblock>
 
 <p><b>具有不可预知域名的不同域</b>。有时候，可能希望具有接收方 LocalConnection 对象的 文件在域之间具有更好的可移植性。为了避免在 <codeph>send()</codeph> 方法中指定域名，但要指出接收方和发送方 LocalConnection 对象不在同一个域中，可在 <codeph>connect()</codeph> 和 <codeph>send()</codeph> 调用中的连接名称之前加一个下划线 (_)。要允许在这两个不同域之间通信，请调用 <codeph>allowDomain()</codeph> 方法并传递您希望允许 LocalConnection 调用的域。或者，也可以传递通配符 (~~) 参数来允许从所有域调用：</p>
 
 <p><adobeimage alt="从未知域名中加载" href="../../images/localconnection_unknowndomains.gif"/></p>
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.allowDomain('~~');
receivingLC.connect('_myConnection');

// sendingLC is in http://www.anotherdomain.com/sending.swf
sendingLC.send('_myConnection', 'myMethod');
</codeblock>
 
 <p>可以使用 LocalConnection 对象发送和接收单个 文件中的数据，但这不是通常的用法。</p>
 
 <p>有关 <codeph>send()</codeph> 和 <codeph>connect()</codeph> 方法的详细信息，请参阅 <codeph>LocalConnection.send()</codeph> 和 <codeph>LocalConnection.connect()</codeph> 条目中对 <codeph>connectionName</codeph> 参数的讨论。此外，请参阅 <codeph>allowDomain()</codeph> 和 <codeph>domain</codeph> 条目。</p>
 
 </apiDesc><example conref="examples\LocalConnectionSenderExample.as"> 下例包含两个 ActionScript 类，这两个类应当编译到两个单独的 SWF 文件中：
 
 <p>在 LocalConnectionSenderExample SWF 文件中，将创建 LocalConnection 实例，并且当按下按钮时使用 <codeph>call()</codeph> 方法通过名为“myConnection”的连接调用 SWF 文件中名为 <codeph>lcHandler</codeph> 的方法，调用时将 TextField 的内容作为参数传递。</p>
 
 <p>在 LocalConnectionReceiverExample SWF 文件中，将创建 LocalConnection 实例并调用 <codeph>connect()</codeph> 方法，将此 SWF 文件指定为发送到名为“myConnection”的连接的消息的接收方。此外，此类还包括一个名为 <codeph>lcHandler()</codeph> 的公共方法，此方法就是 LocalConnectionSenderExample SWF 文件调用的方法。调用时，作为参数传入的文本将被追加到舞台的 TextField 中。</p>
 
 <p><b>注意：</b>为了测试此示例，必须将两个 SWF 文件同时加载到同一台计算机上。</p>
<codeblock>

// Code in LocalConnectionSenderExample.as
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.net.LocalConnection;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.events.StatusEvent;
    import flash.text.TextFieldAutoSize;

    public class LocalConnectionSenderExample extends Sprite {
        private var conn:LocalConnection;
        
        // UI elements
        private var messageLabel:TextField;
        private var message:TextField;
        private var sendBtn:Sprite;
        
        public function LocalConnectionSenderExample() {
            buildUI();
            sendBtn.addEventListener(MouseEvent.CLICK, sendMessage);
            conn = new LocalConnection();
            conn.addEventListener(StatusEvent.STATUS, onStatus);
        }
        
        private function sendMessage(event:MouseEvent):void {
            conn.send("myConnection", "lcHandler", message.text);
        }
        
        private function onStatus(event:StatusEvent):void {
            switch (event.level) {
                case "status":
                    trace("LocalConnection.send() succeeded");
                    break;
                case "error":
                    trace("LocalConnection.send() failed");
                    break;
            }
        }
        
        private function buildUI():void {
            const hPadding:uint = 5;
            // messageLabel
            messageLabel = new TextField();
            messageLabel.x = 10;
            messageLabel.y = 10;
            messageLabel.text = "Text to send:";
            messageLabel.autoSize = TextFieldAutoSize.LEFT;
            addChild(messageLabel);
            
            // message
            message = new TextField();
            message.x = messageLabel.x + messageLabel.width + hPadding;
            message.y = 10;
            message.width = 120;
            message.height = 20;
            message.background = true;
            message.border = true;
            message.type = TextFieldType.INPUT;
            addChild(message);
            
            // sendBtn
            sendBtn = new Sprite();
            sendBtn.x = message.x + message.width + hPadding;
            sendBtn.y = 10;
            var sendLbl:TextField = new TextField();
            sendLbl.x = 1 + hPadding;
            sendLbl.y = 1;
            sendLbl.selectable = false;
            sendLbl.autoSize = TextFieldAutoSize.LEFT;
            sendLbl.text = "Send";
            sendBtn.addChild(sendLbl);
            sendBtn.graphics.lineStyle(1);
            sendBtn.graphics.beginFill(0xcccccc);
            sendBtn.graphics.drawRoundRect(0, 0, (sendLbl.width + 2 + hPadding + hPadding), (sendLbl.height + 2), 5, 5);
            sendBtn.graphics.endFill();
            addChild(sendBtn);
        }
    }
}
</codeblock></example><example conref="examples\LocalConnectionReceiverExample.as"><codeblock>
// Code in LocalConnectionReceiverExample.as
package {
    import flash.display.Sprite;
    import flash.net.LocalConnection;
    import flash.text.TextField;

    public class LocalConnectionReceiverExample extends Sprite {
        private var conn:LocalConnection;
        private var output:TextField;
        
        public function LocalConnectionReceiverExample()     {
            buildUI();
            
            conn = new LocalConnection();
            conn.client = this;
            try {
                conn.connect("myConnection");
            } catch (error:ArgumentError) {
                trace("Can't connect...the connection name is already being used by another SWF");
            }
        }
        
        public function lcHandler(msg:String):void {
            output.appendText(msg + "\n");
        }
        
        private function buildUI():void {
            output = new TextField();
            output.background = true;
            output.border = true;
            output.wordWrap = true;
            addChild(output);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links><adobeApiEvent id="flash.net:LocalConnection_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 在 LocalConnection 对象报告其状态时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 LocalConnection 对象报告其状态时分派。如果 <codeph>LocalConnection.send()</codeph> 成功，则 <codeph>status</codeph> 事件对象的 <codeph>level</codeph> 属性的值为 <codeph>"status"</codeph>；如果调用失败，则 <codeph>level</codeph> 属性为 <codeph>"error"</codeph>。如果接收方 文件拒绝连接，则调用失败，并且不会通知发送方 文件。 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>LocalConnection.send()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 若对 LocalConnection.send() 的调用尝试向另一个安全沙箱发送数据，则进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 若对 <codeph>LocalConnection.send()</codeph> 的调用尝试向另一个安全沙箱发送数据，则进行分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>send()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 在异步引发异常（即来自本机异步代码）时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在异步引发异常（即来自本机异步代码）时分派。 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:LocalConnection:LocalConnection"><apiName>LocalConnection</apiName><shortdesc>
	 创建 LocalConnection 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how receiving and sending files create LocalConnnection objects. 
	 The two files can use the same name or different names for their respective LocalConnection objects. 
	 In this example they use different names.
	 
	 <listing>
	 // Code in the receiving file
	 this.createTextField("result_txt", 1, 10, 10, 100, 22);
	 result_txt.border = true;
	 var receiving_lc:LocalConnection = new LocalConnection();
	 receiving_lc.methodToExecute = function(param1:Number, param2:Number) {
	   result_txt.text = param1+param2;
	 };
	 receiving_lc.connect("lc_name");
	 </listing>
	 
	 <p>The following file sends the request to the first file.</p>
	 
	 <listing>
	 // Code in the sending file
	 var sending_lc:LocalConnection = new LocalConnection();
	 sending_lc.send("lc_name", "methodToExecute", 5, 7);
	 </listing>
	 
	 </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 创建 LocalConnection 对象。可以使用 LocalConnection 对象启用在同一客户端计算机上运行的不同文件之间的通信。
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:LocalConnection:allowDomain"><apiName>allowDomain</apiName><shortdesc>
	 指定一个或多个可以将 LocalConnection 调用发送到此 LocalConnection 实例的域。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Change the first example in the listing.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>所有指定的参数都必须为非空字符串。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>对您在其上允许 LocalConnection 调用的域进行命名的一个或多个字符串。此参数有两种特殊用法：
	 
	 <ul>
	   <li>可以指定通配符“~~”，以允许从所有域调用。</li>
	 
	   <li>您可以指定字符串“<codeph>localhost</codeph>”允许从本地安装的 文件调用此 文件。<ph platform="actionscript">Flash Player 8 对本地 文件引入了安全限制。默认情况下，在 Flash Player 中运行并允许访问 Internet 的 SWF 文件不能同时访问本地文件系统。在 Flash Player 中，如果指定了“<codeph>localhost</codeph>”，则任何本地 SWF 文件都可以访问此 SWF 文件。</ph> </li>
	 
	 </ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定一个或多个可以将 LocalConnection 调用发送到此 LocalConnection 实例的域。
	 
	 <p>您无法使用此方法允许使用安全协议 (HTTPS) 承载的文件由使用非安全协议承载的文件进行访问；必须改用 <codeph>allowInsecureDomain()</codeph> 方法。</p> 
	 
	 <p>您可能想要使用此方法，以便在不知道来自于不同域的子级文件究竟来自哪个最终域的情况下，使该子级文件能够对父级文件进行 LocalConnection 调用。例如，当您使用负载平衡重定向或第三方服务器时就可能发生这种情况。在这种情况下，您可以使用用于加载的 LoaderInfo 对象的 <codeph>url</codeph> 属性，以获取要与 <codeph>allowDomain()</codeph> 方法配合使用的域。例如，如果使用 Loader 对象加载子级文件，则您可以在文件加载后检查 Loader 对象的 <codeph>contentLoaderInfo.url</codeph> 属性，并从完整的 URL 字符串中解析出域。如果您这样做的话，请务必等待文件加载完毕，因为只有在该文件完全加载后，<codeph>contentLoaderInfo.url</codeph> 属性才会具有其最终的正确值。 </p> 
	 
	 <p>也可能出现相反的情况：您可能创建了一个子级文件，用以接受来自父级的 LocalConnection 调用，但却不知道其父级的域。在这种情况下，可以通过检查域参数是否与已加载的 文件中 <codeph>loaderInfo.url</codeph> 属性的域相匹配来实现此方法。同样，您必须从 <codeph>loaderInfo.url</codeph> 的完整 URL 中解析出该域。在这种情况下，您不必等待父级 文件加载；加载子级时，父级已经加载完毕。</p> 
	 
	 <p platform="actionscript">使用此方法时，请考虑 Flash Player 安全模型。默认情况下，LocalConnection 对象与创建它的 文件的沙箱相关联，并且不允许对 LocalConnection 对象进行跨域调用，除非在接收方 文件中调用 <codeph>LocalConnection.allowDomain()</codeph> 方法。但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
	 
	 <p platform="actionscript">有关详细信息，请参阅以下部分：</p>
	 
     <ul platform="actionscript">
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
     </ul>
     
	 <p platform="actionscript"><b>注意</b>：<codeph>allowDomain()</codeph> 方法的格式已更改，与其在 ActionScript 1.0 和 2.0 中的格式不同。在这两个早期版本中，<codeph>allowDomain</codeph> 是可以实现的回调方法。在 ActionScript 3.0 中，<codeph>allowDomain()</codeph> 是调用的 LocalConnection 的内置方法。由于这种更改，<codeph>allowDomain()</codeph> 的用法与 <codeph>flash.system.Security.allowDomain()</codeph> 基本相同。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowInsecureDomain()"><linktext>flash.net.LocalConnection.allowInsecureDomain()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:allowInsecureDomain"><apiName>allowInsecureDomain</apiName><shortdesc>
	 指定一个或多个可以将 LocalConnection 调用发送到此 LocalConnection 对象的域。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Seems like a security note is in order here.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>所有指定的参数都必须为非空字符串。
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>对您在其上允许 LocalConnection 调用的域进行命名的一个或多个字符串。此参数有两种特殊用法：
	 <ul>
	   <li>可以指定通配符“~~”，以允许从所有域调用。指定“~~”将不包括本地主机。</li>
	   <li>您可以指定字符串“<codeph>localhost</codeph>”允许从本地安装的 SWF 文件调用此 SWF 文件。Flash Player 8 对本地 SWF 文件引入了安全限制。可以访问 Internet 的 SWF 文件还不能访问本地文件系统。若指定“<codeph>localhost</codeph>”，则任何本地 SWF 文件都可以访问此 SWF 文件。请记住，处于编辑状态时还必须将执行调用的 SWF 文件指定为只能与远程内容交互的 SWF 文件。</li>
	 </ul>
	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定一个或多个可以将 LocalConnection 调用发送到此 LocalConnection 对象的域。  
	 
	 <p><codeph>allowInsecureDomain()</codeph> 方法的用法与 <codeph>allowDomain()</codeph> 方法相似，不同之处是 <codeph>allowInsecureDomain()</codeph> 方法允许非 HTTPS 来源的文件将 LocalConnection 调用发送至 HTTPS 来源的 SWF 文件。仅当您在使用 HTTPS 加载的文件中调用 <codeph>allowInsecureDomain()</codeph> 方法时，才能体现这种不同。即使在同一个域中跨越非 HTTPS/HTTPS 边界，也必须调用 <codeph>allowInsecureDomain()</codeph> 方法；默认情况下，即使在同一个域中，也不允许从非 HTTPS 文件到 HTTPS 文件进行 LocalConnection 调用。</p>
	 
	 <p>不建议调用 <codeph>allowInsecureDomain()</codeph>，因为这可能会削弱 HTTPS 提供的安全性。通过 HTTPS 加载文件时，您可以确信在通过网络传输文件时，文件不会被篡改。如果随后允许非 HTTPS 文件对 HTTPS 文件进行 LocalConnection 调用，则要接受来自可能在传输过程中已被篡改的 文件的调用。这通常需要格外小心，因为您无法确保到达 HTTPS 文件的 LocalConnection 调用的真实性。</p>
	 
	 <p>默认情况下，使用 HTTPS 协议承载的文件只能被其它使用 HTTPS 协议承载的文件访问。这种实现保持了 HTTPS 协议所提供的完整性。</p>
	 
	 <p>不建议使用此方法覆盖默认行为，因为这样做会削弱 HTTPS 安全性。但在某些情况下您可能需要这样做；例如，需要允许从为 Flash Player 6 或更早版本发布的 HTTP SWF 文件访问为 Flash Player 9 或更高版本发布的 HTTPS SWF 文件。</p>
	 
	 <p>有关安全性的详细信息，请参阅以下部分：</p>
	 
     <ul>
     
     <li class="flexonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
     </ul>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:close"><apiName>close</apiName><shortdesc>
	 关闭（断开连接）LocalConnection 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.close, close
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>未连接 LocalConnection 实例，因而无法将其关闭。
	 
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 关闭（断开连接）LocalConnection 对象。在您不再需要该对象来接受命令时（例如，当您要在另一个 SWF 文件中使用相同的 <codeph>connectionName</codeph> 参数发出 <codeph>connect()</codeph> 命令时）发出此命令。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:connect"><apiName>connect</apiName><shortdesc>
	 准备一个 LocalConnection 对象，以接收来自 send() 命令（称为发送方 LocalConnection 对象）的命令。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.connect, connect
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>传递给 <codeph>connectionName</codeph> 参数的值必须为非空值。
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>出现此错误有以下三种原因：1) 传递给 <codeph>connectionName</codeph> 参数的字符串值为空。请传递非空值。2) 传递给 <codeph>connectionName</codeph> 参数的值包含冒号 (:)。冒号用作一种特殊字符，在 <codeph>send()</codeph> 方法（而非 <codeph>connect()</codeph> 方法）中用于分隔超级域和 <codeph>connectionName</codeph> 字符串。3) 已连接 LocalConnection 实例。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>connectionName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>一个字符串，对应于要与接收方 LocalConnection 对象进行通信的 <codeph>send()</codeph> 命令中指定的连接名称。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 准备一个 LocalConnection 对象，以接收来自 <codeph>send()</codeph> 命令（名为<i>发送方 LocalConnection 对象</i>）的命令。与此命令一起使用的对象称作<i>接收方 LocalConnection 对象</i>。接收方和发送方对象必须运行于同一台客户端计算机上。
	 
	 <p>要避免出现竞争状况，请在调用附加到接收方 LocalConnection 对象的方法之前先定义这些方法，如 LocalConnection 类示例所示。 </p>
	 
	 <p>默认情况下，<codeph>connectionName</codeph> 将解析为值<codeph>“<i>superdomain</i>:connectionName”</codeph>，其中 <codeph><i>superdomain</i></codeph> 是包含 <codeph>connect()</codeph> 命令的文件的超级域。例如，如果包含接收方 LocalConnection 对象的 文件位于 www.someDomain.com，则 <codeph>connectionName</codeph> 解析为 <codeph>"someDomain.com:connectionName"</codeph>。（如果 Flash Player 中运行的文件位于客户端计算机上，则分配给 <codeph>superdomain</codeph> 的值为<codeph>“localhost”</codeph>。）</p>
	 
	 <p>在运行于 Adobe AIR 的 <codeph>application</codeph> 安全沙箱的内容（使用 AIR 应用程序安装的内容）中，运行时将使用字符串 <codeph>app#</codeph> 后跟 AIR 应用程序的应用程序 ID（在应用程序描述符文件中定义）来代替该超级域。例如，应用程序 ID 为 <codeph>com.example.air.MyApp</codeph> <codeph>connectionName</codeph> 的应用程序的 <codeph>connectionName</codeph> 将解析为 <codeph>"app#com.example.air.MyApp:connectionName"</codeph>。</p>
	 
	 <p>此外，在默认情况下，Flash Player 只允许接收方 LocalConnection 对象从连接名称也解析为值 <codeph>"</codeph><codeph><i>superdomain</i></codeph><codeph>:connectionName"</codeph> 的发送方 LocalConnection 对象接受命令。这样，Flash Player 就使得位于同一个域中的文件可以很容易地相互通信。</p>
	 
	 <p>如果您仅在同一个域中的 文件之间实现通讯，请为 <codeph>connectionName</codeph> 指定一个不以下划线 (_) 开头且不指定域名的字符串（例如 <codeph>"myDomain:connectionName"</codeph>）。在 <codeph>connect(connectionName)</codeph> 方法中使用同一个字符串。</p>
	 
	 <p>如果要使位于不同域中的 文件之间实现通信，则为 <codeph>connectionName</codeph> 指定一个以下划线 (_) 开头的字符串，这样就会使具有接收方 LocalConnection 对象的 文件在域之间具有更好的可移植性。下面是两种可能的情形：</p>
	 
	 <ul>
	 
	   <li>如果 <codeph>connectionName</codeph> 字符串不以下划线 (_) 开头，则会添加一个超级域前缀和一个冒号（例如<codeph>“myDomain:connectionName”</codeph>）。虽然这可以确保您的连接不会与其它域中具有同一名称的连接相互冲突，但任何发送方 LocalConnection 对象都必须指定此超级域（例如 <codeph>"myDomain:connectionName"</codeph>）。如果具有接收方 LocalConnection 对象的 文件被移动到另一个域中，则播放器会更改该前缀，以反映新的超级域（例如 <codeph>"anotherDomain:connectionName"</codeph>）。所有发送方 LocalConnection 对象必须进行手动编辑，以指向这个新超级域。</li>
	 
	   <li>如果 <codeph>connectionName</codeph> 字符串以下划线开头（例如<codeph>“_connectionName”</codeph>），则不会向该字符串添加前缀。这意味着接收方和发送方 LocalConnection 对象都将使用相同的 <codeph>connectionName</codeph> 字符串。如果接收方对象使用 <codeph>allowDomain()</codeph> 来指定可以接受来自任何域的连接，则具有接收方 LocalConnection 对象的 文件可以移动到另一个域，而无需更改任何发送方 LocalConnection 对象。</li>
	 </ul>
	 
	 <p>有关详细信息，请参阅类概述中的讨论和 <codeph>send()</codeph> 中对 <codeph>connectionName</codeph> 的讨论以及 <codeph>allowDomain()</codeph> 和 <codeph>domain</codeph> 条目。</p>
	 
	 <p><b>注意：</b>冒号用作一种特殊字符，以分隔 <codeph>connectionName</codeph> 超级域和字符串。包含冒号的 <codeph>connectionName</codeph> 字符串无效。</p>
	 
	 <p>当在应用程序安全沙箱以外的<ph platform="javascript">安全沙箱的内容中使用此方法时</ph>，请考虑 <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR</ph> 安全模型。默认情况下，LocalConnection 对象与创建它的 文件的沙箱相关联，并且不允许对 LocalConnection 对象进行跨域调用，除非在接收方 文件中调用 <codeph>LocalConnection.allowDomain()</codeph> 方法。<ph platform="actionscript">可以在包含 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数，防止 SWF 文件使用此方法。</ph>但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
	 
	 <p>有关详细信息，请参阅以下部分：</p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
     </ul>
     
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:send"><apiName>send</apiName><shortdesc>
	 在使用 connect(connectionName) 方法打开的连接（接收方 LocalConnection 对象）上调用名为 methodName 的方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.send, send
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>connectionName</codeph> 或 <codeph>methodName</codeph> 的值为空。请将非空值传递给这些参数。
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>出现此错误是由于以下某种原因：1) <codeph>connectionName</codeph> 或 <codeph>methodName</codeph> 的值为空字符串。请将有效字符串传递给这些参数。2) <codeph>methodName</codeph> 中指定的方法受限。3) 正在发送的序列化消息过大（超过 40K）。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>connectionName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>对应于要与发送方 LocalConnection 对象进行通信的 <codeph>connect()</codeph> 命令中指定的连接名称。 	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>methodName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要在接收方 LocalConnection 对象中调用的方法的名称。以下方法名会导致命令失败：<codeph>send</codeph>、<codeph>connect</codeph>、<codeph>close</codeph>、<codeph>allowDomain</codeph>、<codeph>allowInsecureDomain</codeph>、<codeph>client</codeph> 和 <codeph>domain</codeph>。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>要传递给指定方法的附加可选参数。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在使用 <codeph>connect(</codeph><codeph>connectionName</codeph><codeph>)</codeph> 方法打开的连接（接收方 LocalConnection 对象）上调用名为 <codeph>methodName</codeph> 的方法。与此命令一起使用的对象称作<i>发送方 LocalConnection 对象</i>。包含发送方对象的 SWF 文件和包含接收方对象的 SWF 文件必须在同一台客户端计算机上运行。
	 
	 <p>您能够以参数形式传递给此命令的数据量限制为 40 千字节。如果 <codeph>send()</codeph> 引发 <codeph>ArgumentError</codeph>，但是您的语法是正确的，请尝试将 <codeph>send()</codeph> 请求分为多个命令，每个命令的数据量不超过 40K。</p>
	 
	 <p>如 <codeph>connect()</codeph> 条目中所述，默认情况下，会将当前超级域添加到 <codeph>connectionName</codeph>。如果您要在不同的域之间实现通讯，则在发送方和接收方 LocalConnection 对象中都需要定义 <codeph>connectionName</codeph>，这样当前超级域就不会添加到 <codeph>connectionName</codeph>。您可以使用以下两种方法中的一种实现这一目的：</p>
	 
	 <ul>
	   <li>在发送方 LocalConnection 对象和接收方 LocalConnection 对象中 <codeph>connectionName</codeph> 的开头使用下划线 (_)。在包含接收方对象的 文件中，使用 <codeph>LocalConnection.allowDomain()</codeph> 指定将接受来自任何域的连接。这一实现使您可以在任何域中存储发送方 文件和接收方 SWF 文件。</li>
	 
	   <li>在发送方 LocalConnection 对象中包含 <codeph>connectionName</codeph> 中的超级域，例如 <codeph>myDomain.com:myConnectionName</codeph>。在接收方对象中，使用 <codeph>LocalConnection.allowDomain()</codeph> 指定将接受来自指定超级域的连接（本例中为 myDomain.com），或者接受来自任何域的连接。</li>
	 </ul>
	 
	 <p><b>注意：</b>不能在接收方 LocalConnection 对象的 <codeph>connectionName</codeph> 中指定超级域，只能在发送方 LocalConnection 对象中指定。</p>
	 
	 <p>当在应用程序安全沙箱以外的<ph platform="javascript">安全沙箱的内容中使用此方法时</ph>，请考虑 <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR</ph> 安全模型。默认情况下，LocalConnection 对象与创建它的 文件的沙箱相关联，并且不允许对 LocalConnection 对象进行跨域调用，除非在接收方 文件中调用 <codeph>LocalConnection.allowDomain()</codeph> 方法。对于在浏览器中运行的 SWF 内容，通过在包含 SWF 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数，可以防止文件使用此方法。但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p> 
	 
	 <p>有关详细信息，请参阅以下部分：</p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
     </ul>
	 
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links><adobeApiEvent id="flash.net:LocalConnection:send_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc><codeph>LocalConnection.send() </codeph>尝试与执行调用的代码不能访问的安全沙箱中的 SWF 文件通信。在接收方的 <codeph>LocalConnection.allowDomain()</codeph> 实现中可以避免此问题。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>LocalConnection.send() 尝试与执行调用的代码不能访问的安全沙箱中的 SWF 文件通信。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection:send_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>如果 <codeph>level</codeph> 属性的值为 <codeph>"status"</codeph>，则调用成功；如果值为 <codeph>"error"</codeph>，则调用失败。如果接收方 SWF 文件拒绝连接，则调用失败。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>如果 level 属性的值为“status”，则调用成功；如果值为“error”，则调用失败。</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:LocalConnection:client:get"><apiName>client</apiName><shortdesc>
	 指示对其调用回调方法的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>必须将 <codeph>client</codeph> 属性设置为非空对象。 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 指示对其调用回调方法的对象。默认对象为 <codeph>this</codeph>，将创建本地连接。您可以将设置 <codeph>client</codeph> 属性设置为另一个对象，并对此对象调用回调方法。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:LocalConnection:domain:get"><apiName>domain</apiName><shortdesc>
	 一个字符串，它表示当前 文件所在位置的域。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.domain, domain
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 一个字符串，它表示当前 文件所在位置的域。 
	 
	 <p>在运行于 Adobe AIR 的 <codeph>application</codeph> 安全沙箱的内容（使用 AIR 应用程序安装的内容）中，运行时将使用字符串 <codeph>app#</codeph> 后跟 AIR 应用程序的应用程序 ID（在应用程序描述符文件中定义）来代替该超级域。例如，应用程序 ID 为 <codeph>com.example.air.MyApp</codeph> <codeph>connectionName</codeph> 的应用程序的 <codeph>connectionName</codeph> 将解析为 <codeph>"app#com.example.air.MyApp:connectionName"</codeph>。</p>
	 
	 <p>在为 Flash Player 9 或更高版本发布的 SWF 文件中，返回的字符串就是文件所在的域并包括子域。例如，如果 文件位于 www.adobe.com，则此命令将返回 <codeph>"www.adobe.com"</codeph>。 </p>
	 
	 <p>如果当前文件是在 Flash Player 中运行并驻留在客户端计算机上的本地文件，则此命令将返回<codeph>“localhost”</codeph>。</p>
	 
	 <p>此属性最常见的用法是，将发送方 LocalConnection 对象的域名作为要在接收方 LocalConnection 对象中调用的方法的参数包括在内，或者与 <codeph>LocalConnection.allowDomain()</codeph> 一起使用以接受来自指定域的命令。如果仅启用位于同一个域的 LocalConnection 对象之间的通信，则可能不需要使用此属性。</p>
	 
 	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link></related-links></apiValue><apiValue id="flash.net:LocalConnection:isPerUser:get"><apiName>isPerUser</apiName><shortdesc>  
     指示 LocalConnection 对象是仅限当前用户访问 (true) 还是计算机上的所有用户全都可以访问它 (false)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
     </apiDefaultValue></apiValueDef><apiDesc>  
     指示 LocalConnection 对象是仅限当前用户访问 (<codeph>true</codeph>) 还是计算机上的所有用户全都可以访问它 (<codeph>false</codeph>)。此属性只影响在 Mac OS X 中运行的内容；其他平台忽略此参数。Windows 和 Linux 操作系统上的连接授权始终是每用户授权。在 Flash Player 10.0.22 和 AIR 1.5.1 以及它们的早期版本中，Mac OS X 上的所有 LocalConnection 对象都具有全局作用域。始终将此属性设置为 <codeph>true</codeph>，除非您需要保留与早期版本的兼容性。在将来发布的版本中，此属性的默认值可能更改为 <codeph>true</codeph>。
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamInfo"><apiName>NetStreamInfo</apiName><shortdesc>
 
 NetStreamInfo 类指定与 NetStream 对象以及视频、音频和数据的基础流缓冲区相关的各种服务质量 (QOS) 统计数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 NetStreamInfo 类指定与 NetStream 对象以及视频、音频和数据的基础流缓冲区相关的各种服务质量 (QOS) 统计数据。在响应 <codeph>NetStream.info</codeph> 调用时将返回 NetStreamInfo 对象，该调用获取当前 QOS 状态的快照并通过 NetStreamInfo 属性提供 QOS 统计数据。
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:NetStreamInfo:NetStreamInfo"><apiName>NetStreamInfo</apiName><shortdesc>
    仅供内部使用；不推荐使用。</shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>curBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>byteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>maxBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>playbackBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>droppedFrames</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>srtt</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioLossRate</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam></apiConstructorDef><apiDesc>
    仅供内部使用；不推荐使用。仅运行时可创建 NetStreamInfo 对象。
    </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.net:NetStreamInfo:toString"><apiName>toString</apiName><shortdesc>
     返回列出 NetStreamInfo 对象属性的文本值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个字符串，它包含 NetStreamInfo 对象的属性值
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>返回列出此 NetStreamInfo 对象属性的文本值。
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     返回列出 NetStreamInfo 对象属性的文本值。
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:NetStreamInfo:SRTT:get"><apiName>SRTT</apiName><shortdesc>
	 指定 NetStream 会话的平滑往返行程时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定 NetStream 会话的平滑往返行程时间。此值仅对 RTMFP 流返回有效值，而对 RTMP 流返回 0。有关详细信息，请参阅 Flash Media Server 文档。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioBufferByteLength:get"><apiName>audioBufferByteLength</apiName><shortdesc>
	 提供 NetStream 音频缓冲区大小，以字节为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 提供 NetStream 音频缓冲区大小，以字节为单位。它指定用于实时流和录制流媒体中的音频数据的缓冲区大小。此属性类似于 <codeph>Netstream.bytesLoaded</codeph>，后者用于渐进式下载。 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioBufferLength:get"><apiName>audioBufferLength</apiName><shortdesc>
	 提供 NetStream 音频缓冲区大小，以秒为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 提供 NetStream 音频缓冲区大小，以秒为单位。此属性扩展 <codeph>NetStream.bufferLength</codeph> 属性并特别针对音频数据提供以时间表示的缓冲区长度。 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioByteCount:get"><apiName>audioByteCount</apiName><shortdesc>
	 指定已到达队列的音频字节总数，这与已播放或已刷新的字节数无关。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定已到达队列的音频字节总数，这与已播放或已刷新的字节数无关。可使用此值计算传入音频数据的速率（使用您选择的度量单位），方法是创建一个计时器并计算连续计时器调用之间的值差异。或者使用 <codeph>audioBytesPerSecond</codeph>。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/audioBytesPerSecond"><linktext>audioBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:audioBytesPerSecond:get"><apiName>audioBytesPerSecond</apiName><shortdesc>
	 指定填充 NetStream 音频缓冲区的速率，以每秒字节数为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定填充 NetStream 音频缓冲区的速率，以每秒字节数为单位。作为最后一秒内接收的音频数据的平均值计算该值。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioLossRate:get"><apiName>audioLossRate</apiName><shortdesc>
	 指定 NetStream 会话的音频丢失。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定 NetStream 会话的音频丢失。此值仅对 RTMFP 流返回有效值，对 RTMP 流返回 0。丢失率是指丢失的消息数与总消息数的比率。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:byteCount:get"><apiName>byteCount</apiName><shortdesc>
	 指定已到达队列的总字节数，这与已播放或已刷新的字节数无关。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定已到达队列的总字节数，这与已播放或已刷新的字节数无关。可使用此值计算传入数据的速率（使用您选择的度量单位），方法是创建一个计时器并计算连续计时器调用之间的值差异。或者使用 <codeph>currentBytesPerSecond</codeph>。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/currentBytesPerSecond"><linktext>currentBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:currentBytesPerSecond:get"><apiName>currentBytesPerSecond</apiName><shortdesc>
	 指定填充 NetStream 缓冲区的速率，以每秒字节数为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定填充 NetStream 缓冲区的速率，以每秒字节数为单位。作为最后一秒内接收的总数据的平均值计算该值。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataBufferByteLength:get"><apiName>dataBufferByteLength</apiName><shortdesc>
	 提供 NetStream 数据缓冲区大小，以字节为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 提供 NetStream 数据缓冲区大小，以字节为单位。它指定用于实时流和录制流媒体中的数据消息的缓冲区大小。此属性类似于 <codeph>Netstream.bytesLoaded</codeph>，后者用于渐进式下载。 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataBufferLength:get"><apiName>dataBufferLength</apiName><shortdesc>
	 提供 NetStream 数据缓冲区大小，以秒为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 提供 NetStream 数据缓冲区大小，以秒为单位。此属性扩展 <codeph>NetStream.bufferLength</codeph> 属性，并提供专用于数据消息的以时间表示的缓冲区长度。  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataByteCount:get"><apiName>dataByteCount</apiName><shortdesc>
	 指定已到达队列的数据消息的字节总数，这与已播放或已刷新的字节数无关。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定已到达队列的数据消息的字节总数，这与已播放或已刷新的字节数无关。可使用此值计算传入数据消息的速率（使用您选择的度量单位），方法是创建一个计时器并计算连续计时器调用之间的值差异。或者使用 <codeph>dataBytesPerSecond</codeph>。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/dataBytesPerSecond"><linktext>dataBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:dataBytesPerSecond:get"><apiName>dataBytesPerSecond</apiName><shortdesc>
	 指定填充 NetStream 数据缓冲区的速率，以每秒字节数为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定填充 NetStream 数据缓冲区的速率，以每秒字节数为单位。作为最后一秒内接收的数据消息的平均值计算该值。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:droppedFrames:get"><apiName>droppedFrames</apiName><shortdesc>
	 返回在当前 NetStream 播放会话中放弃的视频帧数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 返回在当前 NetStream 播放会话中放弃的视频帧数。 
	 <p>在录制的流式或渐进式下载中，如果视频是高品质或高分辨率高比特率的视频，则在没有足够的系统 CPU 资源时，解码器会在解码所需的每秒帧数时发生滞后。在实时流中，如果滞后时间过长，缓冲区会放弃一些视频帧。此属性指定已放弃的和未正常显示的帧数。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:maxBytesPerSecond:get"><apiName>maxBytesPerSecond</apiName><shortdesc>
	 指定填充 NetStream 缓冲区的最大速率，以每秒字节数为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定填充 NetStream 缓冲区的最大速率，以每秒字节数为单位。此值根据 <codeph>NetStream</codeph> 对象最后接收到的消息提供有关客户端网络容量的信息。根据 <codeph>NetStream.bufferTime</codeph> 中指定的缓冲区大小和客户端上的可用带宽，Flash Media Server 会突发填充缓冲区。此属性提供填充客户端缓冲区的最大速率。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:playbackBytesPerSecond:get"><apiName>playbackBytesPerSecond</apiName><shortdesc>
	 返回流的播放速率，以每秒字节数为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 返回流的播放速率，以每秒字节数为单位。播放缓冲区可以包含各种播放列表的内容。此属性提供的播放速率与当前播放的流的比特率非常接近。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoBufferByteLength:get"><apiName>videoBufferByteLength</apiName><shortdesc>
	 提供 NetStream 视频缓冲区大小，以字节为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 提供 NetStream 视频缓冲区大小，以字节为单位。它指定用于实时流和录制流媒体中的视频数据的缓冲区大小。此属性类似于 <codeph>Netstream.bytesLoaded</codeph>，后者用于渐进式下载。 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoBufferLength:get"><apiName>videoBufferLength</apiName><shortdesc>
	 提供 NetStream 视频缓冲区大小，以秒为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 提供 NetStream 视频缓冲区大小，以秒为单位。此属性扩展 <codeph>NetStream.bufferLength</codeph> 属性并特别针对视频数据提供以时间表示的缓冲区长度。 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoByteCount:get"><apiName>videoByteCount</apiName><shortdesc>
	 指定已到达队列的视频字节总数，这与已播放或已刷新的字节数无关。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定已到达队列的视频字节总数，这与已播放或已刷新的字节数无关。可使用此值计算传入视频数据的速率（使用您选择的度量单位），方法是创建一个计时器并计算连续计时器调用之间的值差异。或者使用 <codeph>videoBytesPerSecond</codeph>。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/videoBytesPerSecond"><linktext>videoBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:videoBytesPerSecond:get"><apiName>videoBytesPerSecond</apiName><shortdesc>
	 指定填充 NetStream 视频缓冲区的速率，以每秒字节数为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 指定填充 NetStream 视频缓冲区的速率，以每秒字节数为单位。作为最后一秒内接收的视频数据的平均值计算该值。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLStream"><apiName>URLStream</apiName><shortdesc>
 URLStream 类提供对下载 URL 的低级访问。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 URLStream 类提供对下载 URL 的低级访问。数据一下载，便可随即为应用程序使用，这和使用 URLLoader 时需要等到整个文件下载完不同。并且 URLStream 类还允许在完成下载前关闭流。已下载文件的内容将作为原始二进制数据提供。
 
 <p>在 URLStream 中的读取操作是非阻塞模式的。这意味着您在读取数据之前必须使用 <codeph>bytesAvailable</codeph> 属性来确定是否能够获得足够的数据。如果不能获得足够的数据，将引发 <codeph>EOFError</codeph> 异常。</p>
 
 <p>在默认情况下，所有二进制数据都是以 Big-endian 格式编码的，并且最高位字节于第一位。</p>
 
 <p>适用于通过 URLStream 类进行 URL 下载的安全规则与适用于 URLLoader 对象的规则相同。如有需要也可以下载策略文件。将强制执行本地文件安全规则，并根据需要发出安全警告。</p>

 
 </apiDesc><example conref="examples\URLStreamExample.as"> 下例加载一个 SWF 文件，并解析其标头的开始部分以指明压缩和版本号信息。 
 <p>为了运行该示例，请在与 SWF 文件相同的目录中放置一个名为 URLStreamExample.swf 的文件。</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.errors.*;
    import flash.events.*;
    import flash.net.URLRequest;
    import flash.net.URLStream;

    public class URLStreamExample extends Sprite {
        private static const ZLIB_CODE:String = "CWS";
        private var stream:URLStream;

        public function URLStreamExample() {
            stream = new URLStream();
            var request:URLRequest = new URLRequest("URLStreamExample.swf");
            configureListeners(stream);
            try {
                stream.load(request);
            } catch (error:Error) {
                trace("Unable to load requested URL.");
            }
        }

        private function configureListeners(dispatcher:EventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        }

        private function parseHeader():void {
            trace("parseHeader");
            trace("isCompressed: " + isCompressed());
            trace("version: " + stream.readByte());
        }

        private function isCompressed():Boolean {
            return (stream.readUTFBytes(3) == ZLIB_CODE);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
            parseHeader();
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:Event):void {
            trace("progressHandler: " + event);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link></related-links><adobeApiEvent id="flash.net:URLStream_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 在下载操作过程中收到数据时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在下载操作过程中收到数据时分派。可以使用 URLStream 类方法立即读取已接收的数据。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 在加载操作开始时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在加载操作开始时分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 在出现输入/输出错误并由此导致加载操作失败时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在出现输入/输出错误并由此导致加载操作失败时分派。 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
 在 URLStream.load() 方法调用尝试通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 <codeph>URLStream.load()</codeph> 方法调用尝试通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。 
 
 <p>如果为 <codeph>httpStatusEvent</codeph> 事件注册了 URLStream 对象，则在传输错误响应时会将其视为内容。因此，在将错误数据加载到 URLStream 中时，URLStream 将分派 <codeph>progress</codeph> 和 <codeph>complete</codeph> 事件，而不分派 <codeph>ioError</codeph> 事件。</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 在 URLStream.load() 调用尝试通过 HTTP 访问数据，并且 Flash Player 或 Adobe AIR 可以检测并返回请求的状态代码时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 <codeph>URLStream.load()</codeph> 调用尝试通过 HTTP 访问数据，并且 <ph platform="actionscript">Flash Player 或 </ph>Adobe AIR 可以检测并返回请求的状态代码时分派。（有些浏览器环境可能无法提供此信息。）请注意，在发送任何 <codeph>complete</codeph> 或 <codeph>error</codeph> 事件之前还将发送 <codeph>httpStatus</codeph>（如果有）。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 若对 URLStream.load() 的调用尝试从安全沙箱外部的服务器加载数据，则进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 若对 <codeph>URLStream.load()</codeph> 的调用尝试从安全沙箱外部的服务器加载数据，则进行分派。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 成功加载数据后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 成功加载数据后分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.net:URLStream:close"><apiName>close</apiName><shortdesc>
     立即关闭该流并取消下载操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>无法关闭该流，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     立即关闭该流并取消下载操作。无法在调用 <codeph>close()</codeph> 方法后从该流中读取数据。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:load"><apiName>load</apiName><shortdesc>
     开始下载 request 参数中指定的 URL。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>URLRequest.requestHeader</codeph> 对象不能包含某些被禁用的 HTTP 请求标头。有关详细信息，请参阅 URLRequestHeader 类的描述。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>此错误可能由以下原因引起：
     
     <ol>
     
     <li>Flash Player 或 Adobe AIR 无法将 <codeph>URLRequest.data</codeph> 参数从 UTF8 转换为 MBCS。若传递给 <codeph>load()</codeph> 的 URLRequest 对象设置为执行 <codeph>GET</codeph> 操作并且 <codeph>System.useCodePage</codeph> 设置为 <codeph>true</codeph>，就会发生该错误。</li>
     
     <li>Flash Player 或 Adobe AIR 无法为 <codeph>POST</codeph> 数据分配内存。如果传递给 load 的 URLRequest 对象设置为执行 <codeph>POST</codeph> 操作，将发生该错误。</li></ol>
     
     </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>本地不受信任的 SWF 文件可能无法与 Internet 进行通信。可通过将此 SWF 文件重新分类为只能与远程内容交互或受信任来解决此问题。
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果尝试连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>一个 URLRequest 对象，指定要下载的 URL。如果此参数的值或所传递的 URLRequest 对象的 <codeph>URLRequest.url</codeph> 属性为 <codeph>null</codeph>，则应用程序会引发空指针错误。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     开始下载 <codeph>request</codeph> 参数中指定的 URL。
     
     <p><b>注意</b>：如果要加载的文件包含非 ASCII 字符（在许多非英语的语言中出现），则建议使用 UTF-8 或 UTF-16 编码（而不是 ASCII 等非 Unicode 格式）来保存文件。</p>
     
     <p>如果加载操作很快失败，将引发描述失败情况的 IOError 或 SecurityError（包括本地文件安全错误）异常。否则，如果 URL 下载开始成功下载，将分派 <codeph>open</codeph> 事件；如果发生错误，将分派错误事件。</p>
     
     <p>默认情况下，执行调用的 SWF 文件和加载的 URL 必须在同一域中。例如，位于 www.adobe.com 的 SWF 文件只能从同样位于 www.adobe.com 的源中加载数据。要从不同的域中加载数据，请在承载数据的服务器上放置一个 URL 策略文件。</p>
     
      <p platform="actionscript">在 Flash Player 中，无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_cn" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_cn" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。</p>
     
     <p platform="actionscript">在 Flash Player 中，可以通过在包含 SWF 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数来禁止 SWF 文件使用此方法。</p>
     
     <p platform="actionscript"> 在 Flash Player 10 和更高版本中以及在 AIR 1.5 和更高版本中，如果使用包含上载（由 POST 正文内“content-disposition”标头中的“filename”参数所指）的 multipart Content-Type（例如“multipart/form-data”），则 POST 操作受应用于上载的安全规则的约束：</p>
	 <ul platform="actionscript">
	 <li>必须执行 POST 操作以响应用户启动的操作（如鼠标单击或按键）。</li>
	 <li>如果 POST 操作是跨域的（POST 目标与发送 POST 请求的 SWF 文件不在同一台服务器上），则目标服务器必须提供一个允许跨域访问的 URL 策略文件。</li>
	 </ul>
     <p platform="actionscript">另外，对于任何 multipart Content-Type，语法必须有效（根据 RFC2046 标准）。如果语法无效，则 POST 操作受应用于上载的安全规则约束。</p>
     
     <p platform="actionscript">这些规则同样适用于非应用程序沙箱中的 AIR 内容。但在 Adobe AIR 中，应用程序沙箱中的内容（随 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
     
     <p platform="actionscript">有关安全性的详细信息，请参阅以下部分：</p>
     <ul platform="actionscript">
     
     <li product="flex">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li product="flash">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
     
     <li><i>Developing AIR Applications</i>（《开发 AIR 应用程序》）一书的“Getting started with Adobe AIR”（Adobe AIR 入门）一章中的“Understanding AIR Security”（了解 AIR 安全性）一节。</li>
     
     </ul>
     
     <p>在 AIR 中，URLRequest 对象可以注册 <codeph>httpResponse</codeph> 状态事件。与 <codeph>httpStatus</codeph> 事件不同，<codeph>httpResponseStatus</codeph> 事件在传送任何响应数据之前传送。此外，<codeph>httpResponseStatus</codeph> 事件还包括 <codeph>responseHeaders</codeph> 和 <codeph>responseURL</codeph> 属性的值（对于 <codeph>httpStatus</codeph>，这些属性未定义）。请注意，在发送任何 <codeph>complete</codeph> 或 <codeph>error</codeph> 事件之前还将发送 <codeph>httpResponseStatus</codeph>（如果有）。 
     </p>
     
     
     <p>如果<i>有</i> <codeph>httpResponseStatus</codeph> 事件侦听器，则<i>始终</i> 将发送响应消息的正文；而 HTTP 状态代码响应始终将产生 <codeph>complete</codeph> 事件。无论 HTTP 响应状态代码指示成功还是错误，这种情况都适用。</p> 
     
     <p><ph platform="actionscript">在 AIR 中，</ph><ph platform="javascript">如果</ph><i>没有</i> <codeph>httpResponseStatus</codeph> 事件侦听器，则根据 <ph platform="actionscript">SWF</ph> <ph platform="javascript">AIR</ph> 的版本，行为会有所不同：</p>
     
     <ul>
     
         <li><ph platform="actionscript">适用于 SWF 9 内容</ph><ph platform="javascript">在应用程序描述符指定 AIR 1.0 或 1.1 作为运行时版本的 AIR 文件中</ph>，<i>只有</i> 在 HTTP 响应状态代码指示成功时才会发送 HTTP 响应消息的正文。否则（如果有错误），将不发送正文，且 URLRequest 对象将分派一个 IOError 事件。</li>
     
         <li><ph platform="actionscript">适用于 SWF 10 内容</ph><ph platform="javascript">在应用程序描述符指定 AIR 1.5 作为运行时版本的 AIR 文件中</ph>，将<i>始终</i> 发送 HTTP 响应消息的正文。如果有错误，则 URLRequest 对象将分派一个 IOError 事件。</li>
     
     </ul>
     
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.net:URLStream:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在成功加载数据后分派。如果有 <codeph>httpResponseStatus</codeph> 事件侦听器，则 URLRequest 对象还会分派一个 <codeph>complete</codeph> 事件，无论 HTTP 响应状态代码指示成功<i>还是</i>错误。
     
	 </apiDesc></adobeApiEventDetail><shortdesc>在成功加载数据后分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>如果通过 HTTP 进行访问，<ph platform="actionscript">并且当前环境支持获取状态代码</ph>，则除了 <codeph>complete</codeph> 或 <codeph>error</codeph> 事件之外，还可以接收这些事件。
     
	 </apiDesc></adobeApiEventDetail><shortdesc>如果通过 HTTP 进行访问，并且当前环境支持获取状态代码，则除了 complete 或 error 事件之外，还可以接收这些事件。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在对 <codeph>load()</codeph> 方法的调用试图通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。 
	 
     </apiDesc></adobeApiEventDetail><shortdesc>在对 load() 方法的调用试图通过 HTTP 访问数据，并且 Adobe AIR 可以检测并返回请求的状态代码时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法完成加载操作。
     
     </apiDesc></adobeApiEventDetail><shortdesc>无法完成加载操作。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在加载操作开始时分派。
     
     </apiDesc></adobeApiEventDetail><shortdesc>在加载操作开始时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>加载操作尝试从调用方安全沙箱外部的服务器检索数据。可以通过在服务器上使用策略文件来解决此问题。
     </apiDesc></adobeApiEventDetail><shortdesc>加载操作尝试从调用方安全沙箱外部的服务器检索数据。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:URLStream:readBoolean"><apiName>readBoolean</apiName><shortdesc>
     从该流读取一个布尔值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果字节不为零，则返回 <codeph>True</codeph>；否则返回 <codeph>false</codeph>。
     
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个布尔值。读取单个字节，如果字节非零，则返回 <codeph>true</codeph>，否则返回 <codeph>false</codeph>。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readByte"><apiName>readByte</apiName><shortdesc>
     从该流读取一个带符号字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>值的范围为 -128...127。
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个带符号字节。
     <p>返回值在 -128...127 之间。</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readBytes"><apiName>readBytes</apiName><shortdesc>
     从该流读取 length 字节的数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>要将数据读入的 ByteArray 对象。
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>在 <codeph>bytes</codeph> 中的偏移量，即数据读取的起始位置。默认值为 0。
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>要读取的字节数。默认值 0 将导致读取所有可用的数据。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     从该流读取 <codeph>length</codeph> 字节的数据。这些字节会被读取到由 <codeph>bytes</codeph> 指定的 ByteArray 对象中，其起始位置是在 ByteArray 对象中偏移 <codeph>offset</codeph> 字节处。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readDouble"><apiName>readDouble</apiName><shortdesc>
     从该流读取一个 IEEE 754 双精度浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>流中的一个 IEEE 754 双精度浮点数。
     
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个 IEEE 754 双精度浮点数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readFloat"><apiName>readFloat</apiName><shortdesc>
     从该流读取一个 IEEE 754 单精度浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>流中的一个 IEEE 754 单精度浮点数。
     
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个 IEEE 754 单精度浮点数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readInt"><apiName>readInt</apiName><shortdesc>
     从该流读取一个带符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>值的范围为 -2147483648...2147483647。
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个带符号的 32 位整数。
     <p>返回值在 -2147483648...2147483647 之间。</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
     使用指定的字符集从字节流中读取指定长度的多字节字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLStream, URLStream.readMultiByte, readMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>UTF-8 编码的字符串。
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要从字节流中读取的字节数。
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>表示用于解释字节的字符集的字符串。可能的字符集字符串包括 <codeph>"shift_jis"</codeph>、<codeph>"CN-GB"</codeph>、<codeph>"iso-8859-1"</codeph>”等。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character </xref>。    
	 
     <p><b>注意：</b>如果当前系统无法识别 <codeph>charSet</codeph> 参数的值，则应用程序将使用系统的默认代码页作为字符集。例如，<codeph>charSet</codeph> 参数的值（如在 <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> 中，使用 <codeph>01</codeph> 而不是 <codeph>1</codeph>）可能在您的开发计算机上起作用，但在其它计算机上可能不起作用。在其它计算机上，应用程序将使用系统的默认代码页。</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     使用指定的字符集从字节流中读取指定长度的多字节字符串。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readObject"><apiName>readObject</apiName><shortdesc>
     从以 Action Message Format (AMF) 编码的套接字读取一个对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>反序列化的对象。
     </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
     从以 Action Message Format (AMF) 编码的套接字读取一个对象。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link></related-links></apiOperation><apiOperation id="flash.net:URLStream:readShort"><apiName>readShort</apiName><shortdesc>
     从该流读取一个带符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>值的范围为 -32768...32767。
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个带符号的 16 位整数。
     <p>返回值在 -32768...32767 之间。</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUTF"><apiName>readUTF</apiName><shortdesc>
     从该流读取一个 UTF-8 字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>UTF-8 字符串。
     
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个 UTF-8 字符串。假定字符串的前缀是无符号的短整型（以字节表示长度）。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
     从该流读取长度为 length 的 UTF-8 字节序列，并返回一个字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>由指定长度字符的字节表示形式生成的 UTF-8 字符串。
     
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个 UTF-8 字节序列。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     从该流读取长度为 <codeph>length</codeph> 的 UTF-8 字节序列，并返回一个字符串。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
     从该流读取一个无符号字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>

     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>值的范围为 0...255。
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个无符号字节。
     <p>返回值在 0...255 之间。 </p>     
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
     从该流读取一个无符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>值的范围为 0...4294967295。
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个无符号的 32 位整数。
     <p>返回值在 0...4294967295 之间。 </p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
     从该流读取一个无符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">可读取的数据不足。若本地 SWF 文件触发了安全警告，则 Flash Player 会阻止将 URLStream 数据用于 ActionScript。当发生这种情况时，即使收到了数据，<codeph>bytesAvailable</codeph> 属性也将返回 0，而且任何读方法都将引发 EOFError 异常。</ph> <ph platform="javascript">此错误适用于 SWF 内容，AIR 中运行的 JavaScript 代码中不会发生此错误。</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>该流发生了 I/O 错误，或者该流未打开。
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>值的范围为 0...65535。
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     从该流读取一个无符号的 16 位整数。
     <p>返回值在 0...65535 之间。 </p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:URLStream:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
     返回可在输入缓冲区中读取的数据的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     返回可在输入缓冲区中读取的数据的字节数。您的代码必须调用 <codeph>bytesAvailable</codeph> 属性，以确保尝试使用其中一种 <codeph>read</codeph> 方法读取前有足够可用的数据。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLStream:connected:get"><apiName>connected</apiName><shortdesc>
     指示此 URLStream 对象目前是否已连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指示此 URLStream 对象目前是否已连接。如果已连接 URLStream 对象，则调用该属性会返回值 <codeph>true</codeph>，否则会返回值 <codeph>false</codeph>。     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLStream:endian:get"><apiName>endian</apiName><shortdesc>
     指示数据的字节顺序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>Endian.BIG_ENDIAN
     </apiDefaultValue></apiValueDef><apiDesc>
     指示数据的字节顺序。可能的值为 <codeph>Endian.BIG_ENDIAN</codeph> 或 <codeph>Endian.LITTLE_ENDIAN</codeph>。
     </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>flash.utils.Endian</linktext></link></related-links></apiValue><apiValue id="flash.net:URLStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     在写入或读取对象时，控制所使用的 Action Message Format (AMF) 的版本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     在写入或读取对象时，控制所使用的 Action Message Format (AMF) 的版本。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLStream/readObject()"><linktext>readObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding 类</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:SharedObject"><apiName>SharedObject</apiName><shortdesc>
 SharedObject 类用于在用户计算机或服务器上读取和存储有限的数据量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, shared object, constructor
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 SharedObject 类用于在用户计算机或服务器上读取和存储有限的数据量。使用共享对象，可在永久贮存在本地计算机或远程服务器上的多个客户端 SWF 文件和对象之间实现实时数据共享。本地共享对象类似于浏览器 Cookie，远程共享对象类似于实时数据传输设备。为了使用远程共享对象，您需要 Adobe Flash Media Server。
 
 <p>可使用共享对象执行以下操作：</p>
 
 <ul>
 
 <li><b>保持本地永久性</b>。这是使用共享对象的最简单方法，并且无需使用 Flash Media Server。例如，可以调用 <codeph>SharedObject.getLocal()</codeph> 以在应用程序中创建共享对象，如带记忆功能的计算器。用户关闭计算器时，Flash Player 将在用户计算机的共享对象中保存最后一个值。计算器下一次运行时，将包含先前所拥有的值。或者，在计算器应用程序关闭之前，如果将共享对象的属性设置为 <codeph>null</codeph>，下次运行该应用程序时，它在打开时不包含任何值。维护本地永久性的另一示例就是跟踪用户首选项或复杂网站的其它数据，如用户在新闻网站上所阅读文章的记录。跟踪此信息将允许您以不同方式分别显示已经阅读的文章和新的未读文章。在用户计算机上存储此信息可减小服务器负载。</li>
 
 <li><b>在 Flash Media Server 上存储并共享数据</b>。共享对象可以在服务器上存储数据以供其它客户端进行检索。例如，调用 <codeph>SharedObject.getRemote()</codeph> 以创建一个在服务器上永久保留的远程共享对象，如电话簿。每次客户端对共享对象进行更改时，修改后的数据可供当前或以后连接到该对象的所有客户端使用。如果还在本地永久保留了该对象，并且客户端在未连接到服务器时更改了数据，下次客户端连接到远程共享对象时，则会将数据复制到该对象。</li>
 
 <li><b>实时共享数据</b>。共享对象可以实现多个客户端的实时数据共享。例如，您可以打开一个存储连接到聊天室的用户列表的远程共享对象，连接到该对象的所有客户端都能看到此列表。当用户进入或离开聊天室时，将更新该对象，连接到该对象的所有客户端都能看到修改的聊天室用户列表。</li>
 
 </ul>
 
 <p> 要创建本地共享对象，请调用 <codeph>SharedObject.getLocal()</codeph>。要创建远程共享对象，请调用 <codeph>SharedObject.getRemote()</codeph>。</p> 
 
 <p> 当应用程序关闭时，将会<i>刷新</i>共享对象或将其写入磁盘。也可以调用 <codeph>flush()</codeph> 方法以显式地将数据写入磁盘。</p>
 
 <p><b>本地磁盘空间注意事项。</b>本地共享对象具有一些限制，这些限制很重要，您在设计应用程序时要予以考虑。有时可能不允许 SWF 文件写入本地共享对象，有时可能会在您不知情的情况下删除在本地共享对象中存储的数据。Flash Player 用户可以管理对单个域或所有域可用的磁盘空间。当用户减少可用磁盘空间时，一些本地共享对象可能会被删除。Flash Player 用户还具有隐私控制能力，它们可防止第三方域（当前浏览器地址栏中域之外的域）读取或写入本地共享对象。</p>
 
 <p><b>注意：</b>在本地计算机（而不是远程服务器）上存储和运行的 SWF 文件始终可以将第三方共享对象写入磁盘。有关第三方共享对象的详细信息，请参阅“Flash Player 帮助”中的<xref href="http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager03.html" scope="external">“全局存储设置”面板</xref>。</p>
 
 <p>最好检查与磁盘空间数量和用户隐私控制有关的故障。在调用 <codeph>getLocal()</codeph> 和 <codeph>flush()</codeph> 时执行这些检查：
 
 <ul>
 <li><codeph>SharedObject.getLocal()</codeph> -- 调用此方法失败时（如用户禁用了第三方共享对象，并且您的 SWF 文件的域与浏览器地址栏中的域不匹配），Flash Player 将引发异常。</li>
 
 <li><codeph>SharedObject.flush()</codeph> -- 调用此方法失败时，Flash Player 将引发异常。调用成功时，将返回 <codeph>SharedObjectFlushStatus.FLUSHED</codeph>。需要额外存储空间时，将返回 <codeph>SharedObjectFlushStatus.PENDING</codeph>。Flash Player 提示用户增加本地保存信息的存储空间。随后，对 <codeph>netStatus</codeph> 事件进行分派，同时信息对象将指示刷新是否成功。</li>
 </ul></p>
 
 <p>如果您的 SWF 文件尝试创建或修改本地共享对象，请确保 SWF 文件的宽度至少为 215 像素，高度至少为 138 像素，这是用于显示提示用户增加其本地共享对象存储限制的对话框的最小尺寸。如果您的 SWF 文件小于这些尺寸，且需要增加存储限制，则 <codeph>SharedObject.flush()</codeph> 失败，返回 <codeph>SharedObjectFlushedStatus.PENDING</codeph>，并分派 <codeph>netStatus</codeph> 事件。</p>
 
 <p>
 <b>远程共享对象。</b>如果使用 Flash Media Server，您可以创建并使用远程共享对象，这些对象是由连接到应用程序的所有客户端实时共享的。在一个客户端更改远程共享对象的属性时，也会为所有连接的客户端更改此属性。您可以使用远程共享对象同步客户端，例如，在玩多人游戏的用户。
 </p>
 
 <p>
 每个远程共享对象具有一个 <codeph>data</codeph> 属性，此对象包含存储数据的属性。可以调用 <codeph>setProperty()</codeph> 以更改数据对象的属性。服务器将更新这些属性，分派 <codeph>sync</codeph> 事件，并将这些属性发回到连接的客户端。 
 </p>
 
 <p>
 您可以选择将远程共享对象永久保留在客户端和/或服务器上。默认情况下，Flash Player 最多在本地永久保存 100K 的远程共享对象。在尝试保存较大的对象时，Flash Player 将显示一个“本地存储”对话框，用户可以在其中允许或拒绝共享对象的本地存储。请确保舞台大小至少为 215 x 138 像素；这是 Flash 显示该对话框所需的最小大小。
 </p>
 <p>
 如果用户选择“允许”，服务器将保存共享对象并分派 <codeph>netStatus</codeph>事件，<codeph>code</codeph> 属性值为 <codeph>SharedObject.Flush.Success</codeph>。如果用户选择“拒绝”，服务器不会保存共享对象并分派 <codeph>netStatus</codeph> 事件，<codeph>code</codeph> 属性值为 <codeph>SharedObject.Flush.Failed</codeph>。
 </p>
 
 </apiDesc><example conref="examples\SharedObjectExample.as"> 以下代码使用 ID <codeph>"application-name"</codeph> 创建（并在后续执行过程中检索）一个共享对象： 单击“保存”按钮时，<codeph>saveValue()</codeph> 方法尝试将一个名为 <codeph>savedValue</codeph> 的属性保存到 SharedObject 对象的 <codeph>data</codeph> 的属性。如果 Flash Player 要求提供保存数据的权限，当用户授予或拒绝授予权限时，将调用 <codeph>onFlushStatus()</codeph> 方法。单击“清除”按钮时，<codeph>clearValue()</codeph> 方法将删除 <codeph>savedValue</codeph> 中保存的值；下次加载 SWF 文件时，所检索的值为 <codeph>undefined</codeph>。
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.events.NetStatusEvent;
    import flash.net.SharedObject;
    import flash.net.SharedObjectFlushStatus;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFieldType;
    
    public class SharedObjectExample extends Sprite {
        
        private var mySo:SharedObject;
        
        public function SharedObjectExample() {
            buildUI();
            saveBtn.addEventListener(MouseEvent.CLICK, saveValue);
            clearBtn.addEventListener(MouseEvent.CLICK, clearValue);
            
            mySo = SharedObject.getLocal("application-name");
            output.appendText("SharedObject loaded...\n");
            output.appendText("loaded value: " + mySo.data.savedValue + "\n\n");
        }

         private function saveValue(event:MouseEvent):void {
            output.appendText("saving value...\n");
            mySo.data.savedValue = input.text;
            
            var flushStatus:String = null;
            try {
                flushStatus = mySo.flush(10000);
            } catch (error:Error) {
                output.appendText("Error...Could not write SharedObject to disk\n");
            }
            if (flushStatus != null) {
                switch (flushStatus) {
                    case SharedObjectFlushStatus.PENDING:
                        output.appendText("Requesting permission to save object...\n");
                        mySo.addEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);
                        break;
                    case SharedObjectFlushStatus.FLUSHED:
                        output.appendText("Value flushed to disk.\n");
                        break;
                }
            }
            output.appendText("\n");
        }
        
        private function clearValue(event:MouseEvent):void {
            output.appendText("Cleared saved value...Reload SWF and the value should be \"undefined\".\n\n");
            delete mySo.data.savedValue;
        }
        
        private function onFlushStatus(event:NetStatusEvent):void {
            output.appendText("User closed permission dialog...\n");
            switch (event.info.code) {
                case "SharedObject.Flush.Success":
                    output.appendText("User granted permission -- value saved.\n");
                    break;
                case "SharedObject.Flush.Failed":
                    output.appendText("User denied permission -- value not saved.\n");
                    break;
            }
            output.appendText("\n");

            mySo.removeEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);
        }
        
        // UI elements
        private var inputLbl:TextField;
        private var input:TextField;
        private var output:TextField;
        private var saveBtn:Sprite;
        private var clearBtn:Sprite;
    
        private function buildUI():void {
            // input label
            inputLbl = new TextField();
            addChild(inputLbl);
            inputLbl.x = 10;
            inputLbl.y = 10;
            inputLbl.text = "Value to save:";
            
            // input TextField
            input = new TextField();
            addChild(input);
            input.x = 80;
            input.y = 10;
            input.width = 100;
            input.height = 20;
            input.border = true;
            input.background = true;
            input.type = TextFieldType.INPUT;
            
            // output TextField
            output = new TextField();
            addChild(output);
            output.x = 10;
            output.y = 35;
            output.width = 250;
            output.height = 250;
            output.multiline = true;
            output.wordWrap = true;
            output.border = true;
            output.background = true;
            
            // Save button
            saveBtn = new Sprite();
            addChild(saveBtn);
            saveBtn.x = 190;
            saveBtn.y = 10;
            saveBtn.useHandCursor = true;
            saveBtn.graphics.lineStyle(1);
            saveBtn.graphics.beginFill(0xcccccc);
            saveBtn.graphics.drawRoundRect(0, 0, 30, 20, 5, 5);
            var saveLbl:TextField = new TextField();
            saveBtn.addChild(saveLbl);
            saveLbl.text = "Save";
            saveLbl.selectable = false;
            
            // Clear button
            clearBtn = new Sprite();
            addChild(clearBtn);
            clearBtn.x = 230;
            clearBtn.y = 10;
            clearBtn.useHandCursor = true;
            clearBtn.graphics.lineStyle(1);
            clearBtn.graphics.beginFill(0xcccccc);
            clearBtn.graphics.drawRoundRect(0, 0, 30, 20, 5, 5);
            var clearLbl:TextField = new TextField();
            clearBtn.addChild(clearLbl);
            clearLbl.text = "Clear";
            clearLbl.selectable = false;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>flush()</linktext></link><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link><link href="flash.net.xml#SharedObject/event:netStatus"><linktext>netStatus</linktext></link></related-links><adobeApiEvent id="flash.net:SharedObject_flash.events.SyncEvent.SYNC_sync"><apiName>sync</apiName><shortdesc>
 在服务器更新了远程共享对象后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SyncEvent.SYNC</apiEventType><adobeApiEventClassifier>flash.events.SyncEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在服务器更新了远程共享对象后分派。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#SharedObject/getRemote()"><linktext>getRemote()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:SharedObject_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 在 SharedObject 实例报告其状态或错误条件时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 SharedObject 实例报告其状态或错误条件时分派。<codeph>netStatus</codeph> 事件包含 <codeph>info</codeph> 属性，该属性为包含事件特定信息（例如，连接尝试是否成功或共享对象是否被成功写入本地磁盘）的信息对象。 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:SharedObject_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 在异步引发异常（即来自本机异步代码）时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在异步引发异常（即来自本机异步代码）时分派。 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.net:SharedObject:clear"><apiName>clear</apiName><shortdesc>
     对于本地共享对象，清除所有数据并从磁盘删除共享对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.clear, clear
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     对于本地共享对象，清除所有数据并从磁盘删除共享对象。对共享对象的引用仍然处于活动状态，但其数据属性被删除。
     
     <p>
     对于用于 Flash Media Server 的远程共享对象，<codeph>clear()</codeph> 将断开该对象并清除所有数据。如果在本地永久保留了共享对象，此方法还会从磁盘中删除该共享对象。对共享对象的引用仍然处于活动状态，但其数据属性被删除。
     </p>
      
     
     </apiDesc><example conref="examples\SharedObject_clear.as"> 以下代码使用值为 <codeph>hostName</codeph> 的 ID 创建（并在后续执行过程中检索）一个 SharedObject 对象。将名为 <codeph>username</codeph> 的属性添加到 SharedObject 对象的数据属性中。最后调用 <codeph>clear()</codeph> 方法，以清除添加到数据对象的所有信息（在本例中是一个名为 <codeph>username</codeph> 属性）。
<codeblock>

package {
    import flash.net.SharedObject;

    public class SharedObject_clear {
        private var hostName:String = "yourDomain";
        private var username:String = "yourUsername";

        public function SharedObject_clear() {
            var mySo:SharedObject = SharedObject.getLocal(hostName);
            if(mySo.data.username == null) {
                mySo.data.username = username;
                trace("set: " + mySo.data.username); // yourUsername
            }
            else {
                mySo.clear();
                trace("cleared: " + mySo.data.username); // undefined
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:close"><apiName>close</apiName><shortdesc>
     关闭远程共享对象和服务器间的连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: This info is relevant for Flash Media Server, but not Flex Data Services.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     关闭远程共享对象和服务器间的连接。如果一个远程共享对象永久储存在本地，那么在此方法被调用后，用户可以对该对象的本地副本进行更改。对本地对象的任何更改都将在用户下一次连接到远程共享对象时发送给服务器。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:connect"><apiName>connect</apiName><shortdesc>
     通过指定的 NetConnection 对象连接到服务器上的远程共享对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: On FMS, can connect to a shared object, but cannot pass a message as a second param.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Flash Player 无法连接到指定的远程共享对象。确认 NetConnection 实例有效并已连接，且已在服务器上成功创建远程共享对象。
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>myConnection</apiItemName><apiOperationClassifier>flash.net:NetConnection</apiOperationClassifier><apiDesc>使用实时消息传递协议 (RTMP) 的 NetConnection 对象，如用于与 Flash Media Server 进行通信的 NetConnection 对象。
     
     </apiDesc></apiParam><apiParam><apiItemName>params</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>一个字符串，用于定义将传递给服务器上的远程共享对象的消息。不能用于 Flash Media Server。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     通过指定的 NetConnection 对象连接到服务器上的远程共享对象。应在调用 <codeph>getRemote()</codeph> 后使用此方法。在连接成功时，将分派 <codeph>sync</codeph> 事件。
     
     <p>在尝试使用远程共享对象时，应先使用 <codeph>try..catch..finally</codeph> 语句。接着，侦听并处理 <codeph>sync</codeph> 事件，然后再对共享对象进行更改。在分派 <codeph>sync</codeph> 事件之前，进行的任何本地更改可能会丢失。
     </p>
     
     <p>
     可以调用 <codeph>connect()</codeph> 方法以连接到远程共享对象，例如：
     </p>
     
	 <codeblock platform="actionscript">
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", myNC.uri, false);
     myRemoteSO.connect(myNC);
     </codeblock>
     
	 <codeblock platform="javascript">
	 var myRemoteSO = air.SharedObject.getRemote("mo", myNC.uri, false);
	 myRemoteSO.connect(myNC);
	 </codeblock>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/getRemote()"><linktext>getRemote()</linktext></link><link href="flash.net.xml#SharedObject/event:sync"><linktext>sync</linktext></link><link href="../../statements.html#try..catch..finally"><linktext>try..catch..finally</linktext></link><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:flush"><apiName>flush</apiName><shortdesc>
     将本地永久共享对象立即写入本地文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.flush, flush
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Flash Player 不能将共享对象写入磁盘。如果用户已永久禁止对来自该域的对象进行本地信息存储，则可能出现此错误。
      
     
     <p><b>注意</b>：本地内容始终可以将来自第三方域（当前浏览器地址栏中的域以外的域）的共享对象写入磁盘，即使禁止将第三方共享对象写入磁盘。</p>
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>下列任一值：
     <ul>
     <li><codeph>SharedObjectFlushStatus.PENDING</codeph>：用户允许来自此域的对象进行本地信息存储，但所分配的空间量不足以存储该对象。Flash Player 将提示用户留出更多空间。要留出空间以满足共享对象在保存时的增长需要，从而避免返回值 <codeph>SharedObjectFlushStatus.PENDING</codeph>，请为 <codeph>minDiskSpace</codeph> 传递一个值。
     </li>
     
     <li><codeph>SharedObjectFlushStatus.FLUSHED</codeph>：共享对象已成功写入本地磁盘上的文件。</li>
     </ul>
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>minDiskSpace</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>必须分配给此对象的最小磁盘空间（以字节为单位）。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将本地永久共享对象立即写入本地文件。如果不使用此方法，则 Flash Player 会在共享对象会话结束时（也就是说，在 SWF 文件关闭时，在由于不再有对共享对象的任何引用而将其作为垃圾回收时，或者在调用 <codeph>SharedObject.clear()</codeph> 或 <codeph>SharedObject.close()</codeph> 时），将共享对象写入文件。 
     
     <p>如果此方法返回 <codeph>SharedObjectFlushStatus.PENDING</codeph>，则 Flash Player 将显示一个对话框，要求用户增加磁盘空间量以供此域中的对象使用。要允许将来保存共享对象时其空间能够增长，从而避免返回值 <codeph>PENDING</codeph>，请为 <codeph>minDiskSpace</codeph> 传递一个值。当 Flash Player 尝试写入文件时，它将查找传递给 <codeph>minDiskSpace</codeph> 的字节数，而不是查找足够的空间以共享对象的当前大小来保存共享对象。 </p>
     
     <p>例如，如果预期共享对象增长到最大为 500 个字节，则即使它开始时要小得多，也为 <codeph>minDiskSpace</codeph> 传递 500。如果 Flash 要求用户为该共享对象分配磁盘空间，它将要求 500 个字节。在用户分配了请求的空间量之后，当以后尝试对齐该对象时（只要其大小不超过 500 个字节），Flash 将无需要求更多的空间。 </p>
     
     <p>在用户响应此对话框后，则会再次调用此方法。将分派 <codeph>netStatus</codeph> 事件，<codeph>code</codeph> 属性值为 <codeph>SharedObject.Flush.Success</codeph> 或 <codeph>SharedObject.Flush.Failed</codeph>。
     </p>
     
     </apiDesc><example conref="examples\SharedObject_flush.as"> 以下代码使用值为 <codeph>hostName</codeph> 的 ID 创建（并在后续执行过程中检索）一个 SharedObject 对象。将名为 <codeph>username</codeph> 的属性添加到 SharedObject 对象的数据属性中。然后调用 <codeph>flush()</codeph> 方法，并检查以确定返回的是字符串 <codeph>pending</codeph> 还是 <codeph>true</codeph> 或 <codeph>false</codeph> 的布尔值。务必注意：打开的所有 SharedObject 实例都将在 Flash Player 的当前实例关闭时自动刷新。
<codeblock>
package {
    import flash.net.SharedObject;

    public class SharedObject_flush {
        private var hostName:String = "yourDomain";
        private var username:String = "yourUsername";

        public function SharedObject_flush() {
            var mySo:SharedObject = SharedObject.getLocal(hostName);
            mySo.data.username = username;
            var flushResult:Object = mySo.flush();
            trace("flushResult: " + flushResult);
            trace(mySo.data.username); // yourUsername
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/clear()"><linktext>clear()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:getLocal"><apiName>getLocal</apiName><shortdesc>
  返回对本地永久保留的共享对象的引用，该对象只能用于当前客户端。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, constructor, SharedObject.getLocal, getLocal, get
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>不论什么原因，Flash Player 均不能创建共享对象。如果禁止第三方 Flash 内容创建或存储永久共享对象，将出现此错误。用户可以在“设置管理器”的“全局存储设置”面板上禁止第三方永久共享对象，相关设置请参阅 <xref href="http://www.adobe.com/support/documentation/cn/flashplayer/help/settings_manager03.html" scope="external">http://www.adobe.com/support/documentation/cn/flashplayer/help/settings_manager03.html</xref>。
  
  </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>一个对共享对象的引用，该共享对象永久贮存在本地并且只可用于当前客户端。如果 Flash Player 无法创建或找到共享对象（例如，指定了 <codeph>localPath</codeph> 但不存在此目录时），此方法将引发异常。
  
  </apiDesc><apiOperationClassifier>flash.net:SharedObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>对象的名称。该名称可以包含正斜杠 (<codeph>/</codeph>)；例如，<codeph>work/addresses</codeph> 是合法名称。共享对象名称中不允许使用空格，也不允许使用以下字符：   
  <pre>
  ~ % &amp; \ ; : " ' , &lt; > ? # 
  </pre>
  
  </apiDesc></apiParam><apiParam><apiItemName>localPath</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>创建了共享对象的 SWF 文件的完整路径或部分路径，这将确定共享对象的本地存储位置。如果未指定此参数，则使用完整路径。 
   
  </apiDesc></apiParam><apiParam><apiItemName>secure</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>确定对此共享对象的访问是否只限于通过 HTTPS 连接传递的 SWF 文件。如果 SWF 文件通过 HTTPS 传递，则此参数值具有以下效果：
  <ul>
  <li>如果此参数设置为 <codeph>true</codeph>，则 Flash Player 将创建一个新的安全共享对象或获取一个对现有安全共享对象的引用。只可由通过 HTTPS 传递的 SWF 文件对此安全共享对象进行读取或写入，而该 HTTPS 调用 <codeph>SharedObject.getLocal()</codeph> 并将 <codeph>secure</codeph> 参数设置为 <codeph>true</codeph>。</li>
  <li>如果此参数设置为 <codeph>false</codeph>，则 Flash Player 将创建一个新的共享对象或获取一个对现有共享对象的引用，可以通过非 HTTPS 连接传递的 SWF 文件对此共享对象或现有共享对象的引用进行读取或写入。</li>
  </ul>
  <p>如果您的 SWF 文件是通过非 HTTPS 连接传递的，并且您尝试将此参数设置为 <codeph>true</codeph>，将无法创建新的共享对象（或访问以前创建的安全共享对象），并且返回 <codeph>null</codeph>。无论此参数为何值，创建的共享对象的数量都接近域所允许的磁盘空间的总量。</p>
  
  <p>下面的图示说明了 <codeph>secure</codeph> 参数的用途：</p>
  <p><adobeimage alt="安全共享对象图" href="../../images/secureParam.jpg"/></p>
  
  </apiDesc></apiParam></apiOperationDef><apiDesc>
  返回对本地永久保留的共享对象的引用，该对象只能用于当前客户端。如果尚不存在共享对象，则此方法将创建一个共享对象。如果传递给 <codeph>getLocal()</codeph> 的任何值均无效，或如果调用失败，Flash Player 将引发异常。
  
  <p>以下代码显示如何将返回的共享对象引用赋给变量：</p>
  <p><codeph>var so:SharedObject = SharedObject.getLocal("savedData");</codeph></p>
  
  <p><b>注意：</b>如果用户已选择了从不允许此域进行本地存储，则即使指定了 <codeph>localPath</codeph> 的值，对象也不会在本地保存。本地内容不遵循此规则。本地内容始终可以将第三方域（当前浏览器地址栏中域之外的域）中的共享对象写入磁盘，即使禁止将第三方共享对象写入磁盘。
  </p>
  
  <p>为了避免名称冲突，Flash 会考虑创建共享对象的 SWF 文件的位置。例如，如果位于 www.myCompany.com/apps/stockwatcher.swf 的 SWF 文件创建了一个名为 <codeph>portfolio</codeph> 的共享对象，则该共享对象不会与位于 www.yourCompany.com/photoshoot.swf 的 SWF 文件所创建的另一个名为 <codeph>portfolio</codeph> 的对象冲突，这是因为这两个 SWF 文件源于不同的目录。 </p>
  
  <p>虽然 <codeph>localPath</codeph> 参数是可选的，但是您应该考虑该参数的用途，特别是其它 SWF 文件需要访问共享对象时。如果共享对象中的数据特定于一个不会移动到其它位置的 SWF 文件，则使用默认值将会解决问题。如果其它 SWF 文件需要访问共享对象，或如果创建共享对象的 SWF 文件以后将发生移动，则此参数的值将影响共享对象的可访问性。例如，如果在 <codeph>localPath</codeph> 设置为等于 SWF 文件完整路径的默认值时创建一个共享对象，那么其它任何 SWF 文件都将无法访问该共享对象。如果您以后将原始的 SWF 文件移动到另一个位置，那么，即便是该 SWF 文件也将无法访问已经存储在共享对象中的数据。</p>
  
  <p>为避免意外限制对共享对象的访问，请使用 <codeph>localpath</codeph> 参数。允许级别最高的方法是将 <codeph>localPath</codeph> 设置为 <codeph>/</codeph>（斜杠），这样做可使域中的所有 SWF 文件都可访问该共享对象，但会增加与域中其它共享对象发生名称冲突的可能性。限制级别较高的方法是向 <codeph>localPath</codeph> 追加 SWF 文件完整路径中的文件夹名。例如，对于位于 www.myCompany.com/apps/stockwatcher.swf 的 SWF 文件创建的 <codeph>portfolio</codeph> 共享对象，可以将 <codeph>localPath</codeph> 参数设置为<codeph>/</codeph>、<codeph>/apps</codeph> 或 <codeph>/apps/stockwatcher.swf</codeph>。您必须确定哪种方法能为您的应用程序提供最佳的灵活性。</p>
  
  <p platform="actionscript">在使用此方法时，请考虑以下安全模型：
  
  <ul>
  
    <li>无法跨沙箱边界访问共享对象。</li>
    <li>用户可通过使用“Flash Player 设置”对话框或“设置管理器”来限制共享对象访问。默认情况下，应用程序可在每个域创建高达 100 KB 数据的共享对象。管理员和用户还可限制写入文件系统的能力。</li>
  </ul></p>
  
  <p platform="actionscript">假定您将要回放的 SWF 文件内容发布为本地文件（本地安装的 SWF 文件或 EXE 文件）而且，您需要从多个本地 SWF 文件访问某个特定的共享对象。在这种情况下，请注意：对于本地文件而言，可能会使用两个不同位置来存储共享对象。所用的域取决于为创建该共享对象的本地文件授予的安全权限。本地文件可以具有三种不同级别的权限：
  
  <ol>
    <li>仅能访问本地文件系统。</li>
    <li>仅能访问网络。</li>
    <li>既能访问网络，也能访问本地文件系统。</li>
  </ol></p>
  
  <p platform="actionscript">可以访问本地文件系统（1 级或 3 级）的本地文件将其共享对象存储在一个位置。无法访问本地文件系统（2 级）的本地文件将其共享对象存储在另一位置。</p>
  
  <p platform="actionscript">可以在包含 SWF 内容的 HTML 页中设置 <codeph>allowNetworking</codeph> 参数（<codeph>object</codeph> 和 <codeph>embed</codeph> 标签），防止 SWF 文件使用此方法。</p>
  
  <p platform="actionscript">有关详细信息，请参阅以下部分：
  
  <ul>
    <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
    <li product="flash">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
    <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
  </ul></p>
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:getRemote"><apiName>getRemote</apiName><shortdesc>
     返回对 Flash Media Server 上可由多个客户端访问的共享对象的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: This info is relevant for Flash Media Server, but not Flex Data Services.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Flash Player 无法创建或找到共享对象。如果为 <codeph>remotePath</codeph> 和 <codeph>persistence</codeph> 参数指定不存在的路径，则将出现这种情况。
     
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>对可在多个客户端间共享的对象的引用。
     
     </apiDesc><apiOperationClassifier>flash.net:SharedObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>远程共享对象的名称。该名称可以包含正斜杠 (/)；例如，work/addresses 是合法名称。共享对象名称中不允许使用空格，也不允许使用以下字符：
     <pre>    ~ % &amp; \ ; :  " ' , > ? ? #</pre>
     
     </apiDesc></apiParam><apiParam><apiItemName>remotePath</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>将存储共享对象的服务器的 URI。此 URI 必须与传递给 <codeph>connect()</codeph> 方法的 NetConnection 对象的 URI 相同。 
     
     </apiDesc></apiParam><apiParam><apiItemName>persistence</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>false</apiData><apiDesc>指定共享对象的数据属性的特性是本地永久储存还是远程永久储存，或者是同时进行本地永久储存和远程永久储存。此参数还可指定共享对象的本地存储位置。可接受的值包括：
     <ul><li><codeph>false</codeph>，指定客户端或服务器上的共享对象不是永久性的。</li>
     <li><codeph>true</codeph>，指定只有服务器上的共享对象是永久性的。</li>
     <li>共享对象的完整路径或部分路径，指定客户端和服务器上的共享对象都是永久性的。客户端的共享对象存储在指定路径中，而服务器中的共享对象则存储在应用程序目录中的子目录内。</li>
     </ul>
     
     <p><b>注意：</b>如果用户已选择了从不允许此域的本地存储，则即使将本地路径指定为永久性，对象也不会在本地保存。有关详细信息，请参阅类的描述。</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>secure</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>确定对此共享对象的访问是否只限于通过 HTTPS 连接传递的 SWF 文件。有关详细信息，请参阅对 <codeph>secure</codeph> 参数的描述（<codeph>getLocal</codeph> 方法条目中）。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回对 Flash Media Server 上可由多个客户端访问的共享对象的引用。如果远程共享对象尚不存在，此方法将创建一个共享对象。 
     
     <p>
     要创建远程共享对象，请调用 <codeph>getRemote()</codeph>，然后调用 <codeph>connect()</codeph> 以将远程共享对象连接到服务器，如下所示：</p>
     
	 <codeblock platform="actionscript">
     var nc:NetConnection = new NetConnection();
     nc.connect("rtmp://somedomain.com/applicationName");
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", nc.uri, false);
     myRemoteSO.connect(nc);
     </codeblock>
     
	 <codeblock platform="javascript">
     var nc = new air.NetConnection();
     nc.connect("rtmp://somedomain.com/applicationName");
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", nc.uri, false);
     myRemoteSO.connect(nc);
     </codeblock>
	 
     <p>
     要确认共享对象的本地副本和远程副本是否已同步，请侦听并处理 <codeph>sync</codeph> 事件。希望共享此对象的所有客户端必须为 <codeph>name</codeph> 和 <codeph>remotePath</codeph> 参数传递相同的值。 
     </p> 
     
     <p>要创建只能用于当前客户端的共享对象，请使用 <codeph>SharedObject.getLocal()</codeph>。
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/connect()"><linktext>connect()</linktext></link><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:send"><apiName>send</apiName><shortdesc>
     向连接到远程共享对象的所有客户端广播一条消息（包括发送该消息的客户端）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Needs better documentation, examples.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>一个或多个参数：标识消息的字符串、附加到共享对象的一个或多个处理函数的名称以及任意类型可选参数。处理函数的名称只能为单级形式（即不能是父/子级形式）并相对于共享对象。这些参数已进行序列化处理并通过连接进行发送，而接收处理函数按相同的顺序接收它们。若某个参数为循环对象（例如：循环的链表），则序列化函数会正确地处理引用。
     
     <p><b>注意</b>：函数名称切勿使用保留术语。例如，<codeph>myRemoteSO.send("close")</codeph> 将失败。</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     向连接到远程共享对象的所有客户端广播一条消息（包括发送该消息的客户端）。要处理并响应该消息，请创建一个附加到共享对象的回调函数。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:setDirty"><apiName>setDirty</apiName><shortdesc>
     通知服务器共享对象中的属性值已更改。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The AS2 player automatically marks properties dirty as they are changed.
          The FMS server, however, requires an explicit setProperty() call to indicate when a property
          of data has changed.
     
          AS3 does not support auto-dirtying the properties, so we are introducing setDirty() to explicitly
          indicate when a property has changed, and setProperty() to match the method provided with the server.
     
          It's probably best to read the FMS Actionscript reference (search for SharedObject.setProperty at
          www.adobe.com) before writing this documentation, as the details should be similar.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>已更改的属性名称。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     通知服务器共享对象中的属性值已更改。此方法将属性标记为 <i>dirty</i>，这表明属性已更改。
     
     <p>
     可以调用 <codeph>SharedObject.setProperty()</codeph> 为共享对象创建属性。 
     </p>
      
     <p>
     <codeph>SharedObject.setProperty()</codeph> 方法实现了 <codeph>setDirty()</codeph>。大多数情况下，例如，当属性的值为 String 或 Number 等原始类型时，您可以调用 <codeph>setProperty()</codeph> 而不是调用 <codeph>setDirty()</codeph>。然而，如果属性值是一个包含其自己的属性的对象，则调用 <codeph>setDirty()</codeph> 以指示该对象中的值的更改时间。
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/data"><linktext>SharedObject.data (client-side property)</linktext></link><link href="flash.net.xml#SharedObject/setProperty()"><linktext>setProperty()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:setProperty"><apiName>setProperty</apiName><shortdesc>
     更新共享对象中某个属性的值，并通知服务器该属性的值已更改。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>共享对象中属性的名称。
     </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>属性值（一个 ActionScript 对象），如果为 <codeph>null</codeph> 则删除属性。 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     更新共享对象中某个属性的值，并通知服务器该属性的值已更改。<codeph>setProperty()</codeph> 方法显式地将属性标签为已更改或 dirty。
     
     <p>有关远程共享对象的详细信息，请参阅 <xref href="http://www.adobe.com/go/learn_fms_docs_en">Flash Media Server 文档</xref>。</p>
     
     <p><b>注意：</b><codeph>SharedObject.setProperty()</codeph> 方法实现了 <codeph>setDirty()</codeph> 方法。大多数情况下，例如当属性的值为 String 或 Number 等原始类型时，应使用 <codeph>setProperty()</codeph>，而不使用 <codeph>setDirty</codeph>。然而，当某个属性的值是一个包含其自身属性的对象时，则使用 <codeph>setDirty()</codeph> 来指示该对象中的值的更改时间。通常，最好调用 <codeph>setProperty()</codeph> 而不要调用 <codeph>setDirty()</codeph>，因为 <codeph>setProperty()</codeph> 只在值被更改的时候更新属性值，而 <codeph>setDirty()</codeph> 则强制所有订阅客户端进行同步。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/data"><linktext>SharedObject.data (client-side property)</linktext></link></related-links></apiOperation><apiValue id="flash.net:SharedObject:client:get"><apiName>client</apiName><shortdesc>
     指示对其调用回调方法的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>必须将 <codeph>client</codeph> 属性设置为非空对象。
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     指示对其调用回调方法的对象。默认对象为 <codeph>this</codeph>。您可以将此客户端属性设置为其它对象，并对此对象调用回调方法。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:SharedObject:data:get"><apiName>data</apiName><shortdesc>
     赋给对象的 data 属性 (property) 的属性 (attribute) 集合；可以共享和存储这些属性 (attribute)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.data, data
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     赋给对象的 <codeph>data</codeph> 属性 (property) 的属性 (attribute) 集合；可以共享和存储这些属性 (attribute)。每个特性都可以是任何 ActionScript 或 JavaScript 类型的对象（数组、数字、布尔值、字节数组、XML，等等）。例如，下面几行将值赋给共享对象的不同方面：
     
	 <codeblock platform="actionscript">
     var items_array:Array = new Array(101, 346, 483);
     var currentUserIsAdmin:Boolean = true;
     var currentUserName:String = "Ramona";
     
     var my_so:SharedObject = SharedObject.getLocal("superfoo");
     my_so.data.itemNumbers = items_array;
     my_so.data.adminPrivileges = currentUserIsAdmin;
     my_so.data.userName = currentUserName;
     
     for (var prop in my_so.data) {
       trace(prop+": "+my_so.data[prop]);
     }
     </codeblock>
     
	 <codeblock platform="javascript">
	 var items_array = new Array(101, 346, 483);
	 var currentUserIsAdmin = true;
	 var currentUserName = "Ramona";
	 
	 var my_so = air.SharedObject.getLocal("superfoo");
	 my_so.data.itemNumbers = items_array;
	 my_so.data.adminPrivileges = currentUserIsAdmin;
	 my_so.data.userName = currentUserName;
	 
	 for (var prop in my_so.data) {
	   trace(prop+": "+my_so.data[prop]);
	 }
	 </codeblock>
     
     <p>如果对象是永久的，将保存共享对象的 <codeph>data</codeph> 属性 (property) 的所有属性 (attribute)，共享对象包含以下信息：</p>
     
     <codeblock>
     userName: Ramona
     adminPrivileges: true
     itemNumbers: 101,346,483
     </codeblock>
     
     <p><b>注意：</b>切勿将值直接赋给共享对象的 <codeph>data</codeph> 属性，如同在 <codeph>so.data = someValue</codeph> 中一样；Flash Player 将忽略这些赋值。</p>
     
     <p>要删除本地共享对象的属性，请使用诸如 <codeph>delete so.data.attributeName</codeph> 这样的代码；将本地共享对象的属性设置为 <codeph>null</codeph> 或 <codeph>undefined</codeph> 不会删除该属性。</p>
     
     <p>要为共享对象创建<i>私有</i> 值（该对象正在使用时只有客户端实例才可以使用该值，并且该值在对象关闭时不与该对象存储在一起），请创建名称不是 <codeph>data</codeph> 的属性来存储它们，如下例所示：</p>
     
	 <codeblock platform="actionscript">
     var my_so:SharedObject = SharedObject.getLocal("superfoo");
     my_so.favoriteColor = "blue";
     my_so.favoriteNightClub = "The Bluenote Tavern";
     my_so.favoriteSong = "My World is Blue";
     
     for (var prop in my_so) {
       trace(prop+": "+my_so[prop]);
     }
     </codeblock>
     
	 <codeblock platform="javascript">
	 var my_so = air.SharedObject.getLocal("superfoo");
	 my_so.favoriteColor = "blue";
	 my_so.favoriteNightClub = "The Bluenote Tavern";
	 my_so.favoriteSong = "My World is Blue";
	 
	 for (var prop in my_so) {
	   trace(prop+": "+my_so[prop]);
	 }
	 </codeblock>
     
     <p>共享对象包含以下数据：</p>
     <codeblock>
     favoriteSong: My World is Blue
     favoriteNightClub: The Bluenote Tavern
     favoriteColor: blue
     data: [object Object]
     </codeblock>
     
     <p>
     对于用于服务器的远程共享对象，<codeph>data</codeph> 属性 (property) 的所有属性 (attribute) 可供连接到共享对象的所有客户端使用；如果永久保留这些对象，则会保存所有属性 (attribute)。如果一个客户端更改了属性的值，所有客户端可以立即看到新的值。
     </p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
     在 SWF 文件中创建的所有本地共享对象的默认对象编码（AMF 版本）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     在 SWF 文件中创建的所有本地共享对象的默认对象编码（AMF 版本）。在将本地共享对象写入磁盘时，<codeph>SharedObject.defaultObjectEncoding</codeph> 属性将指示应使用的 Action Message Format 的版本：ActionScript 3.0 格式 (AMF3)、ActionScript 1.0 还是 2.0 格式 (AMF0)。
     
     <p>关于对象编码的详细信息（包括本地和远程共享对象编码的差异），请参阅 <codeph>objectEncoding</codeph> 属性的描述。</p>
     
     <p><codeph>SharedObject.defaultObjectEncoding</codeph> 的默认值设置为使用 ActionScript 3.0 格式 (AMF3)。如果要创建 ActionScript 2.0 或 1.0 SWF 文件可以读取的本地共享对象，则应在创建任何本地共享对象之前，在脚本起始处将 <codeph>SharedObject.defaultObjectEncoding</codeph> 设置为使用 ActionScript 1.0 或 ActionScript 2.0 格式 (<codeph>flash.net.ObjectEncoding.AMF0</codeph>)。随后创建的所有本地共享对象都将使用 AMF0 编码，并可与旧内容交互。本地共享对象创建后，将无法更改现有本地共享对象的 <codeph>objectEncoding</codeph> 值，通过设置 <codeph>SharedObject.defaultObjectEncoding</codeph>。</p>
     
     <p>为了以每个对象为基础设置对象编码，而不是为 SWF 文件创建的所有共享对象设置对象编码，则应设置本地共享对象的 <codeph>objectEncoding</codeph> 属性。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/objectEncoding"><linktext>objectEncoding 属性</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding 类</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     此共享对象的对象编码（AMF 版本）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>您尝试为某个远程共享对象设置 <codeph>objectEncoding</codeph> 属性值。对于远程共享对象而言，此属性为只读，因为其值由关联的 NetConnection 实例决定。
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     此共享对象的对象编码（AMF 版本）。在将本地共享对象写入磁盘时，<codeph>objectEncoding</codeph> 属性将指示应使用的 Action Message Format 的版本：ActionScript 3.0 格式 (AMF3)、ActionScript 1.0 还是 2.0 格式 (AMF0)。 
     
     <p>根据共享对象是本地还是远程来执行不同的对象编码操作。</p>
     <ul>
     <li><b>本地共享对象</b>。您可以为本地共享对象获取或设置 <codeph>objectEncoding</codeph> 属性值。<codeph>objectEncoding</codeph> 的值影响在<i>写入</i> 此本地共享对象时使用的格式设置。如果此本地共享对象必须能被 ActionScript 2.0 或 1.0 SWF 文件读取，则应将 <codeph>objectEncoding</codeph> 设置为 <codeph>ObjectEncoding.AMF0</codeph>。即便对象编码设置为写入 AMF3，Flash Player 仍然能够读取 AMF0 本地共享对象。也就是说，如果使用此属性的默认值，即 <codeph>ObjectEncoding.AMF3</codeph>，则您的 SWF 文件仍然能够读取由 ActionScript 2.0 或 1.0 SWF 文件创建的共享对象。
     </li>
     
     <li><b>远程共享对象</b>。连接到服务器时，远程共享对象从关联的 NetConnection 实例（此实例用于连接到远程共享对象）继承其 <codeph>objectEncoding</codeph> 设置。未连接到服务器时，远程共享对象从关联的 NetConnection 实例继承 <codeph>defaultObjectEncoding</codeph> 设置。因为远程共享对象的 <codeph>objectEncoding</codeph> 属性值由 NetConnection 实例决定，所以此属性对远程共享对象为只读。
     </li>
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/defaultObjectEncoding"><linktext>defaultObjectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:size:get"><apiName>size</apiName><shortdesc>
     共享对象的当前大小（以字节为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.getSize, getSize
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     共享对象的当前大小（以字节为单位）。
     
     <p>Flash 通过逐一计算共享对象的每个数据属性计算该对象的大小；对象具有的数据属性越多，评估其大小所花的时间就越长。评估对象大小可能要耗费相当长的处理时间，因此，除非您对它具有特定的需要，否则您可能希望避免使用此方法。</p>
     
     </apiDesc><example conref="examples\SharedObject.size.1.as"> 以下代码使用 ID <codeph>"thehobbit"</codeph> 创建 SharedObject 对象。将名为 <codeph>username</codeph> 的属性添加到 SharedObject 对象的数据属性中。然后跟踪 <codeph>size</codeph> 属性，这将返回指示的值。
<codeblock>

import flash.net.SharedObject;

// if these get copied or not
var mySo:SharedObject = SharedObject.getLocal("thehobbit");
mySo.data.username = "bilbobaggins";
trace(mySo.size); // 55
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.net:SharedObject:fps:set"><apiName>fps</apiName><shortdesc>
     指定每秒钟客户端对共享对象所做的更改被发送到服务器的次数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: The info is relevant for Flash Media Server, but not Flex.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指定每秒钟客户端对共享对象所做的更改被发送到服务器的次数。 
     
     <p>如果希望控制客户端与服务器之间的通信量，可以使用此方法。例如，如果客户端与服务器之间的连接相对较慢，可以将 <codeph>fps</codeph> 设置为一个相对较小的值。相反，如果客户端连接到一个对时间具有高要求的多用户应用程序，可能需要将 <codeph>fps</codeph> 设置为一个相对较大的值。</p>
     
     <p>设置 <codeph>fps</codeph> 将触发 <codeph>sync</codeph> 事件并更新对服务器的所有更改。如果只想手动更新服务器，可将 <codeph>fps</codeph> 为 0。</p>
     
     <p>在分派 <codeph>sync</codeph> 事件之前，不会将更改发送给服务器。也就是说，如果服务器的响应时间较慢，向服务器发送更新的频率则可能小于此属性中的指定值。 </p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLLoaderDataFormat"><apiName>URLLoaderDataFormat</apiName><shortdesc>
 URLLoaderDataFormat 类提供了一些用于指定如何接收已下载数据的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 URLLoaderDataFormat 类提供了一些用于指定如何接收已下载数据的值。
 
 </apiDesc><example conref="examples\URLLoaderDataFormatExample.as"> 下例使用 URLLoaderDataFormatExample 类显示在运行时加载的文件的数据格式和状态信息。这是使用以下步骤完成的：
 <ol>
  <li>类构造函数创建一个名为 <codeph>loader</codeph> 的 URLLoader 和一个名为 <codeph>request</codeph> 的 URLRequest 实例，后者为要加载的文件的位置和名称。</li>
  <li><codeph>loader</codeph> 对象被传递给 <codeph>configureListeners()</codeph> 方法，该方法可为每个受支持的 URLLoader 事件添加侦听器：
  <ul>
      <li><codeph>completeHandler()</codeph>：侦听 <codeph>complete</codeph> 事件，在成功加载 TextFile.txt 后分派该事件。</li>
      <li><codeph>openHandler()</codeph>：侦听 <codeph>open</codeph> 事件，开始下载 TextFile.txt（至播放器）时分派该事件。</li>
      <li><codeph>progressHandler()</codeph>：侦听 <codeph>progress</codeph> 事件，在下载操作过程中收到数据时分派该事件。</li>
      <li><codeph>securityErrorHandler()</codeph>：侦听 <codeph>securityError</codeph> 事件，如果访问文本文件时使用了错误的本地回放安全设置，则分派该事件。</li>  
      <li><codeph>httpStatusHandler()</codeph>：侦听 <codeph>httpStatusHandler</codeph> 事件，在此示例不分派该事件，因为 TextFile.txt 是本地文件。</li>
      <li><codeph>ioErrorHandler()</codeph>：侦听 <codeph>ioError</codeph> 事件，仅当文件出现严重问题（如文件丢失）时才发生该事件。</li>  
  </ul></li>
  <li>随后 <codeph>request</codeph> 对象被传递给 <codeph>loader.load()</codeph> 方法，该方法会使用 <codeph>DisplayObject</codeph> 对象将文本文件加载到内存中。</li>
 </ol>
 <p> <b>注意：</b>
 <ul>
  <li>您需要编译 SWF 文件，将“本地回放安全性”设置为“只访问本地文件”。
  </li>
  <li>该示例要求名为 TextFile.txt 的文件与 SWF 文件放在同一目录中。如果希望该示例识别二进制或 URL 编码数据文件，则需要用适当的数据格式来提供该文件，并将 TextFile.txt 更改为新文件的名称和位置。</li>
  </ul>
 </p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLLoaderDataFormatExample extends Sprite {
        private var source:String = "TextFile.txt";
        private var dataFormat:String = URLLoaderDataFormat.TEXT;
        
        public function URLLoaderDataFormatExample () {
            var loader:URLLoader = new URLLoader();
            loader.dataFormat = dataFormat;
            configureListeners(loader);
            var request:URLRequest = new URLRequest(source);
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Error loading requested document: " + source);
            }
        }

        private function configureListeners(dispatcher:URLLoader):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            switch(loader.dataFormat) {
                case URLLoaderDataFormat.TEXT :
                    trace("completeHandler (text): " + loader.data);
                    break;
                case URLLoaderDataFormat.BINARY :
                    trace("completeHandler (binary): " + loader.data);
                    break;
                case URLLoaderDataFormat.VARIABLES :
                    trace("completeHandler (variables): " + loader.data);
                    break;
            }
        }

        private function httpStatusHandler(event:Event):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiValue id="flash.net:URLLoaderDataFormat:BINARY"><apiName>BINARY</apiName><shortdesc>
	 指定以原始二进制数据形式接收下载的数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>binary</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指定以原始二进制数据形式接收下载的数据。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoaderDataFormat:TEXT"><apiName>TEXT</apiName><shortdesc>
	 指定以文本形式接收已下载的数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>text</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指定以文本形式接收已下载的数据。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoaderDataFormat:VARIABLES"><apiName>VARIABLES</apiName><shortdesc>
	 指定以 URL 编码变量形式接收下载的数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>variables</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指定以 URL 编码变量形式接收下载的数据。
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamPlayTransitions"><apiName>NetStreamPlayTransitions</apiName><shortdesc>
 
 NetStreamPlayTransitions 类指定可与 NetStreamPlayOptions.transition 属性一起使用的有效字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 NetStreamPlayTransitions 类指定可与 NetStreamPlayOptions.transition 属性一起使用的有效字符串。这些字符串可控制用于过渡到新流或播放流的行为，具体取决于使用的过渡模式。
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions"><linktext>NetStreamPlayOptions</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links><apiValue id="flash.net:NetStreamPlayTransitions:APPEND"><apiName>APPEND</apiName><shortdesc>
	 
	 向播放列表中添加流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>append</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 向播放列表中添加流。此模式与 <codeph>NetStream.play()</codeph> 方法（将 <codeph>reset</codeph> 标志设置为 <codeph>false</codeph>）具有相同的功能。
	 
	 <p>在此模式下，Flash Media Server 将对 <codeph>NetStreamPlayOptions.streamName</codeph> 中指定的流在播放列表的末尾进行排队，并忽略 <codeph>NetStreamPlayOptions.oldStreamName</codeph> 参数。</p> 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:RESET"><apiName>RESET</apiName><shortdesc>
	 
	 清除任何以前的播放调用，并立即播放指定的流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reset</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 清除任何以前的播放调用，并立即播放指定的流。此模式与将 <codeph>reset</codeph> 标志设置为 <codeph>true</codeph>（<codeph>NetStream.play()</codeph> 的默认行为）的 <codeph>NetStream.play()</codeph> 方法具有相同的功能。
	 
	 <p>在此模式下，将刷新当前播放的流，并开始播放 <codeph>NetStreamPlayOptions.streamName</codeph> 中指定的流。<codeph>NetStreamPlayOptions.oldStreamName</codeph> 参数将被忽略。</p> 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:STOP"><apiName>STOP</apiName><shortdesc>
	 
	 停止播放播放列表中的流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>stop</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 停止播放播放列表中的流。此模式与调用 <codeph>NetStream.play(false)</codeph> 具有相同的功能。它将停止并重置播放列表。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:SWAP"><apiName>SWAP</apiName><shortdesc>
	 将一个内容流替换为其它内容流，并保留播放列表的其余部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>swap</apiData><apiType value=""/></apiValueDef><apiDesc>
	 将一个内容流替换为其它内容流，并保留播放列表的其余部分。
	 
	 <p>与 <codeph>SWITCH</codeph> 类似，此模式将 <codeph>NetStreamPlayOptions.oldStreamName</codeph> 中指定的流替换为 <codeph>NetStreamPlayOptions.streamName</codeph> 中指定的流。播放列表的其余部分将被保留。在此模式下，Flash Media Server 将不对流的内容做出假设，而是将它们视为不同的内容。如果 <codeph>oldStreamName</codeph> 尚未发送，则服务器将在流边界执行切换，并从头开始发送 <codeph>streamName</codeph> 的位。如果服务器已经开始发送 <codeph>oldStreamName</codeph> 的位，则不会切换到 <codeph>streamName</codeph> 并将分派一个 <codeph>NetStream.Play.Failed</codeph> 事件。</p>
	 
	 <p>如果要切换的各个流互不相关，并且这些流具有不同的内容和长度，请使用此模式。例如，基于用户跟踪和以前的商用版查看统计数据来交换商用版和其它版本。</p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:SWITCH"><apiName>SWITCH</apiName><shortdesc>
	 从播放一个流切换为播放另一个流（通常使用具有相同内容的流）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>switch</apiData><apiType value=""/></apiValueDef><apiDesc>
	 从播放一个流切换为播放另一个流（通常使用具有相同内容的流）。在 <codeph>NetStreamPlayOptions.oldStreamName</codeph> 和 <codeph>NetStreamPlayOptions.streamName</codeph> 中指定要切换的流。 
	 
	 <p>要切换到具有相同内容但以不同比特率或分辨率进行编码的流，请使用此模式。例如，当应用程序在播放列表中对流进行排队或以特定比特率播放单个流，然后通过计算可用带宽或 CPU 处理能力是低于或高于流要求时，请使用此模式。然后，应用程序可以使用更高或更低的比特率更新这些流。</p>
	 
	 <p>在此模式下，Flash Media Server 对 <codeph>oldStreamName</codeph> 和 <codeph>streamName</codeph> 流之间的关系进行一些假设。服务器假设这些流具有相同的内容和相同的关键帧间隔，但其分辨率或比特率不同。</p>
	 
	 <p>当播放列表已进行排队并且 <codeph>oldStreamName</codeph> 是播放列表中的一个流或者当前正在播放时，<codeph>oldStreamName</codeph> 将被替换为 <codeph>streamName</codeph>。</p>
	 
	 <p>如果 <codeph>oldStreamName</codeph> 为 null 或未定义，或者未在播放列表中，则服务器会在下一个逻辑点切换到 <codeph>streamName</codeph>，以确保进行平滑切换。</p>
	 
	 <p>要从一个流切换到包含不同内容的另一个流，请改用 <codeph>RESET</codeph> 模式。</p>
	 
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetConnection"><apiName>NetConnection</apiName><shortdesc>
 NetConnection 类在 Flash Player 或 AIR 应用程序和 Flash Media Server 应用程序之间或在 Flash Player 或 AIR 应用程序和运行 Flash Remoting 的应用程序服务器之间创建双向连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetConnection, Video, Responder
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 NetConnection 类在 <ph platform="actionscript">Flash Player 或 AIR</ph> <ph platform="javascript">AIR</ph> 应用程序和 Flash Media Server 应用程序之间或在 <ph platform="actionscript">Flash Player 或 AIR</ph> <ph platform="javascript">AIR</ph> 应用程序和运行 Flash Remoting 的应用程序服务器之间创建双向连接。NetConnection 对象如同客户端与服务器之间的管道。可使用 NetStream 对象通过此管道发送流。 
 <p>创建 Responder 对象并将其作为 <codeph>NetConnection.call()</codeph> 的一个参数传递，以处理从特定操作在其上成功实现或失败的服务器返回的值。</p>  
 <p>
 如果未使用 Flash Media Server，您可以使用 NetConnection 类从本地文件系统或 Web 服务器中播放视频和 MP3 文件。
 </p>
 
 <p>
 有关支持的编解码器和文件格式的信息，请参阅 <xref href="http://www.adobe.com/go/hardware_scaling_cn" scope="external">http://www.adobe.com/go/hardware_scaling_cn</xref> 和 <xref href="http://www.adobe.com/support/documentation" scope="external">Flash Media Server 文档</xref>。
 </p>
 
 <p>在使用 NetConnection 类时，请考虑以下安全模型：</p>
 
 <ul>
 <li>如果执行调用的 文件在网络沙箱中并且要加载的声音文件是本地的，则不允许加载和播放音频或视频文件。</li>
 
 	<li>默认情况下，如果调用文件是本地文件并且试图加载和播放远程文件，则不允许加载和播放音频或视频文件。用户必须授予明确许可以允许该操作。</li>
 </ul>
 
 <p>但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
 
 <p>有关详细信息，请参阅以下部分：</p>
 
 <ul>
 
 <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
 
 <li product="flash">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 
 <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li> 
 </ul>
 
 
 <p platform="actionscript"><b>注意</b>：该类在 ActionScript 2.0 中是动态的，但现已将该类密封。为了为该类编写回调方法，可以扩展该类，然后在子类中定义回调方法，也可以使用 <codeph>client</codeph> 属性引用一个对象，然后对该对象定义回调方法。</p>
 
 </apiDesc><example conref="examples\NetConnectionExample.as"> 以下示例将 Video 对象与 NetConnection 和 NetStream 类一同使用，以加载和播放 FLV 文件。为了运行此示例，需要一个 FLV 文件，其名称和位置与传递给 <codeph>videoURL</codeph> 的变量匹配，在本例中，名为 Video.flv 的 FLV 文件与 SWF 文件在同一个目录中。
 <p>在本例中，创建 Video 和 NetStream 对象并调用 <codeph>Video.attachNetStream()</codeph> 和 <codeph>NetStream.play()</codeph> 方法的代码放在处理函数中。仅当连接到 NetConnection 对象的尝试取得成功时才调用处理函数，即，当 <codeph>netStatus</codeph> 事件返回 <codeph>info</codeph> 对象（带有一个表示成功的 <codeph>code</codeph> 属性）时，才调用该处理函数。建议您在调用 <codeph>NetStream.play()</codeph> 之前，等待连接成功。 </p>
 <codeblock>

package {
    import flash.display.Sprite;
    import flash.events.NetStatusEvent;
    import flash.events.SecurityErrorEvent;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.Event;

    public class NetConnectionExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function NetConnectionExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Stream not found: " + videoURL);
                    break;
            }
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.client = new CustomClient();
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
    }
}

class CustomClient {
    public function onMetaData(info:Object):void {
        trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate);
    }
    public function onCuePoint(info:Object):void {
        trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#NetConnection/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream"><linktext>NetStream</linktext></link><link href="flash.net.xml#NetConnection/connect()"><linktext>connect()</linktext></link><link href="flash.net.xml#Responder"><linktext>flash.net.Responder</linktext></link></related-links><adobeApiEvent id="flash.net:NetConnection_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 在 NetConnection 对象报告其状态或错误条件时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在 NetConnection 对象报告其状态或错误条件时分派。<codeph>netStatus</codeph> 事件包含一个 <codeph>info</codeph> 属性，该属性是一个包含事件特定信息（例如，连接尝试成功还是失败）的信息对象。 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 若对 NetConnection.call() 的调用尝试连接到调用方安全沙箱外部的服务器，则进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 若对 <codeph>NetConnection.call()</codeph> 的调用尝试连接到调用方安全沙箱外部的服务器，则进行分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection/call()"><linktext>NetConnection.call()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 在出现输入或输出错误并导致网络操作失败时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在出现输入或输出错误并导致网络操作失败时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 在异步引发异常（即来自本机异步代码）时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在异步引发异常（即来自本机异步代码）时分派。 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:NetConnection:NetConnection"><apiName>NetConnection</apiName><shortdesc>
     创建一个 NetConnection 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>See the example for <code>connect()</code>.
     
     </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     创建一个 NetConnection 对象。调用 <codeph>connect()</codeph> 以建立连接。
     
	 <p>如果应用程序需要与在 Flash Player 9 之前发布的服务器进行通信，则可能需要设置 NetConnection 对象的 <codeph>objectEncoding</codeph> 属性。</p>
     
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#NetConnection/connect()"><linktext>flash.net.NetConnection.connect()</linktext></link><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>objectEncoding</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:NetConnection:addHeader"><apiName>addHeader</apiName><shortdesc>
     将上下文标头添加到 Action Message Format (AMF) 数据包结构中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>IMD: This method can be used in the client Flash Player for Flash Remoting
     and Flex apps. It is also a server side method used by Flash Media Server apps.
     
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>标识标头和与之相关的 ActionScript 对象数据。
     
     </apiDesc></apiParam><apiParam><apiItemName>mustUnderstand</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>值为 <codeph>true</codeph> 表示服务器必须先了解和处理此标头再处理任一后续标头或消息。
     </apiDesc></apiParam><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>任一 ActionScript 对象。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将上下文标头添加到 Action Message Format (AMF) 数据包结构中。此标头将随以后的每个 AMF 数据包一起发送。如果使用相同的名称调用 <codeph>NetConnection.addHeader()</codeph>，则新标头将代替现有标头，并在 NetConnection 对象的持续时间内始终使用新标头。通过使用标头名称调用 <codeph>NetConnection.addHeader()</codeph> 以删除未定义的对象，可以删除标头。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetConnection:call"><apiName>call</apiName><shortdesc>
     在 Flash Media Server 或运行 Flash Remoting 的应用程序服务器上调用一个命令或方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>以 <codeph>[objectPath/]method</codeph> 的形式指定的方法。例如，<codeph>someObject/doSomething</codeph> 命令将通知远程服务器调用 <codeph>clientObject.someObject.doSomething()</codeph> 方法，并带有所有可选的 <codeph>... arguments</codeph> 参数。如果缺少对象路径，则将在远程服务器上调用 <codeph>clientObject.doSomething()</codeph>。
     <p>
     如果使用 Flash Media Server，<codeph>command</codeph> 是在应用程序的服务器端脚本中定义的函数的名称。如果将服务器端脚本放在应用程序目录的根级别，则不需要在 <codeph>command</codeph> 前面使用对象路径。
     </p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiDesc>可选对象，用于处理服务器的返回值。Responder 对象可以用两个定义的方法来处理返回的结果：<codeph>result</codeph> 和 <codeph>status</codeph>。如果返回的结果为错误，则将调用 <codeph>status</codeph>；否则，将调用 <codeph>result</codeph>。Responder 对象可以处理与特定操作有关的错误，而 NetConnection 对象则响应与连接状态有关的错误。
     
     </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>可选参数，可以为任一 ActionScript 类型，并包括对另一个 ActionScript 对象的引用。当在远程应用程序服务器上执行 <codeph>command</codeph> 参数中指定的方法时，这些参数将被传递给该方法。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     在 Flash Media Server 或运行 Flash Remoting 的应用程序服务器上调用一个命令或方法。在调用 <codeph>NetConnection.call()</codeph> 之前，必须先调用 <codeph>NetConnection.connect()</codeph> 以连接到服务器。必须创建要传递给此方法的服务器端函数。 
     
      <p>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Responder"><linktext>flash.net.Responder</linktext></link></related-links><adobeApiEvent id="flash.net:NetConnection:call_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>尝试与位于调用方安全沙箱外部的服务器进行通信的调用。可通过在服务器上使用策略文件来避免出现此问题。
     </apiDesc></adobeApiEventDetail><shortdesc>尝试与位于调用方安全沙箱外部的服务器进行通信的调用。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:NetConnection:close"><apiName>close</apiName><shortdesc>
     关闭本地打开的连接或到服务器的连接，并分派 code 属性值为 NetConnection.Connect.Closed 的 netStatus 事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: Documented this method with server-specific info in span tags. The
     info is relevant for Flex servers, as well as Flash Media Server.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     关闭本地打开的连接或到服务器的连接，并分派 <codeph>netStatus</codeph> 事件，<codeph>code</codeph> 属性值为 <codeph>NetConnection.Connect.Closed</codeph>。
     
     <p>
     此方法断开在此连接上运行的所有 NetStream 对象。队列中尚未发送的所有数据将被丢弃。（要终止本地或服务器流而不关闭连接，请使用 <codeph>NetStream.close()</codeph>。） 如果关闭连接，然后要创建一个新连接，则必须创建新的 NetConnection 对象并再次调用 <codeph>connect()</codeph> 方法。
     </p>
     
     <p><codeph>close()</codeph> 方法还会断开在此连接上运行的所有远程共享对象。不过，不必重新创建要重新连接的共享对象，您只需调用 <codeph>SharedObject.connect()</codeph> 以重新建立到共享对象的连接。此外，在发出 <codeph>NetConnection.close()</codeph> 时排在队列中的共享对象中的任何数据都将在重建与共享对象的连接之后发送。</p>
     
     <p>
     如果使用 Flash Media Server，最佳开发做法是在客户端不再需要到服务器的连接时调用 <codeph>close()</codeph>。调用 <codeph>close()</codeph> 是清除未使用的连接的最快捷方法。作为一种替代方法，您可以将服务器配置为自动关闭空闲连接。有关详细信息，请参阅 <i><xref href="http://www.adobe.com/support/documentation" scope="external">Flash Media Server Configuration and Administration Guide</xref></i>（《Flash Media Server 配置和管理指南》）。 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream"><linktext>NetStream</linktext></link><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetConnection:connect"><apiName>connect</apiName><shortdesc>
     在 Flash Player 或 AIR 应用程序和 Flash Media Server 应用程序之间创建双向连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetConnection.connect, connect
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>传递给 <codeph>command</codeph> 参数的 URI 格式不正确。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>连接失败。这可能是由于调用了 <codeph>connect()</codeph>（从 <codeph>netStatus</codeph> 事件处理函数中）而这是不允许的。
     
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>与本地文件系统内容交互的 SWF 文件无法与 Internet 进行通信。可通过将此 SWF 文件重新分类为只能与远程内容交互或受信任来避免出现这种问题。
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果尝试连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>如果要连接到本地计算机上的视频文件，请将此参数设置为 <codeph>null</codeph>。如果要连接到服务器，则将此参数设置为包含服务器上视频文件的应用程序的 URI。应使用以下语法（方括号中的项是可选的）：
     
     <p><codeph>protocol:[//host][:port]/appname[/instanceName]</codeph></p>
     
     <p>要连接到 Flash Media Server，请使用 <codeph>rtmp</codeph>、<codeph>rtmpe</codeph>、<codeph>rtmps</codeph>、<codeph>rtmpt</codeph>、<codeph>rtmpte</codeph> 或 <codeph>rtmfp</codeph> 作为协议。如果连接成功，则会返回 <codeph>netStatus</codeph> 事件，<codeph>code</codeph> 属性值为 <codeph>NetConnection.Connect.Success</codeph>。请参阅 <codeph>NetStatusEvent.info</codeph> 属性，获得有关为响应 <codeph>connect()</codeph> 调用而返回的所有事件代码的列表。
     </p>
     
     <p>如果 文件是从安装服务器的同一台主机中提供的，则可以省略 <codeph>host</codeph> 参数。如果省略 <codeph>instanceName</codeph> 参数，<ph platform="actionscript">Flash Player 或</ph> AIR 将连接到应用程序的默认实例。</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>要传递给 <codeph>command</codeph> 中指定的应用程序的任意类型可选参数。如果使用 Flash Media Server，会将额外的参数传递给应用程序服务器端代码中的 <codeph>application.onConnect()</codeph> 事件处理函数。您必须在 <codeph>onConnect()</codeph> 中定义并处理这些参数。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     在 <ph platform="actionscript">Flash Player 或 AIR</ph> <ph platform="javascript">AIR</ph> 应用程序和 Flash Media Server 应用程序之间创建双向连接。NetConnection 对象如同客户端与服务器之间的管道。可使用 NetStream 对象通过此管道发送流。有关 Flash Media Server 支持的编解码器和文件格式的信息，请参阅 <xref href="http://www.adobe.com/support/documentation" scope="external">Flash Media Server 文档</xref>。
     
     <p>
     如果未使用 Flash Media Server，请调用 <codeph>NetConnection.connect()</codeph>，以便从本地文件系统或 Web 服务器中播放视频和 MP3 文件。有关支持的编解码器和文件格式的信息，请参阅 <xref href="http://www.adobe.com/go/hardware_scaling_cn" scope="external">http://www.adobe.com/go/hardware_scaling_cn</xref>。
     </p>
     
     <p>
     在 <ph platform="actionscript">Flash Player 或 AIR</ph> <ph platform="javascript">AIR</ph> 应用程序和运行 Flash Remoting 服务的应用程序之间创建双向连接。可使用 NetServices 类通过 NetConnection 对象调用应用程序服务器函数，并返回结果。有关详细信息，请参阅 <xref href="http://www.adobe.com/support/documentation" scope="external">Flash Remoting 文档</xref>。 
     </p>
     
	 <p>在使用此方法时，请考虑以下安全模型：</p>
     
     <ul>
      <li>默认情况下，<ph platform="actionscript">Flash Player 或</ph> AIR 拒绝沙箱之间的访问。网站可通过使用 URL 策略文件来实现对资源的访问。 </li>
     
      <li>应用程序可以拒绝对服务器上的资源的访问。在 Flash Media Server 应用程序中，您需要添加服务器端代码以拒绝访问。有关详细信息，请参阅 Flash Media Server 文档。 </li> 
     
      <li>如果进行调用的 文件位于只能与本地文件系统内容交互的沙箱中，则无法使用 <codeph>NetConnection.connect()</codeph>。</li>
     
      <li>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。 </li>
     
     <li>可以在包含 SWF 内容的 HTML 页中设置 <codeph>allowNetworking</codeph> 参数（<codeph>object</codeph> 和 <codeph>embed</codeph> 标签的参数），防止 SWF 文件使用此方法。</li>
     
     </ul>
     
	 <p>但在 Adobe AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
	 
     <p>有关详细信息，请参阅以下部分：</p>
     
     <ul>
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
     <li product="flash">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
     </ul>
     
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></apiOperation><apiValue id="flash.net:NetConnection:client:get"><apiName>client</apiName><shortdesc>
     指示应对其调用回调方法的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>必须将 <codeph>client</codeph> 属性设置为非空对象。 
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     指示应对其调用回调方法的对象。默认值为此 NetConnection 实例。如果将 <codeph>client</codeph> 属性设置为另一个对象，则将对该对象调用回调方法。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:connected:get"><apiName>connected</apiName><shortdesc>
	 指示应用程序是否通过永久性的 RTMP 连接连接到服务器，如果是，则为 true，否则为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 指示应用程序是否通过永久性的 RTMP 连接连接到服务器，如果是，则为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。通过 HTTP 进行连接时，此属性为 <codeph>false</codeph>；除非是连接到应用程序服务器上的 Flash Remoting 服务，此时该属性为 <codeph>true</codeph>。 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:connectedProxyType:get"><apiName>connectedProxyType</apiName><shortdesc>
     用于对 Flash Media Server 进行成功 NetConnection.connect() 调用的代理类型：“none”、“HTTP”、“HTTPS”或“CONNECT”。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>This property is used in Breeze 5.5.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>已尝试在未连接 NetConnection 实例时访问此属性。 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     用于对 Flash Media Server 进行成功 <codeph>NetConnection.connect()</codeph> 调用的代理类型：“<codeph>none</codeph>”、“<codeph>HTTP</codeph>”、“<codeph>HTTPS</codeph>”或“<codeph>CONNECT</codeph>”。如果未使用隧道建立连接，则该值为“<codeph>none</codeph>”；如果使用隧道通过 HTTP 建立连接，则该值为“<codeph>HTTP</codeph>”；如果使用隧道通过 HTTPS 建立连接，则该值为“<codeph>HTTPS</codeph>”；如果使用隧道通过 HTTP CONNECT 方法建立连接，则该值为“<codeph>CONNECT</codeph>”。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
	 用于 NetConnection 对象的默认对象编码。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 用于 NetConnection 对象的默认对象编码。将对象写入到二进制数据中或从二进制数据中读取对象时，<codeph>defaultObjectEncoding</codeph> 属性将指示对数据进行序列化处理时使用的 Action Message Format (AMF) 版本：ActionScript 3.0 格式 (<codeph>ObjectEncoding.AMF3</codeph>) 或 ActionScript 1.0 和 ActionScript 2.0 格式 (<codeph>ObjectEncoding.AMF0</codeph>)。 
     
     <p>默认值是 <codeph>ObjectEncoding.AMF3</codeph>。更改 <codeph>NetConnection.defaultObjectEncoding</codeph> 不会影响现有 NetConnection 实例，只会影响随后创建的实例。</p>
     
     <p>要单独设置某个对象的编码（而非设置整个应用程序的对象编码），请改为设置 NetConnection 对象的 <codeph>objectEncoding</codeph> 属性。</p>
     
     <p>有关详细信息，请参阅关于 <codeph>objectEncoding</codeph> 属性的描述。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>NetConnection.objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:farID:get"><apiName>farID</apiName><shortdesc>
     与此 Flash Player 或 Adobe AIR 实例连接的 Flash Media Server 实例的标识符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     与此 Flash Player 或 Adobe AIR 实例连接的 Flash Media Server 实例的标识符。此属性仅对于 RTMFP 连接才有意义。此属性的值仅在建立 RTMFP 连接之后可用。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/nearID"><linktext>nearID</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:farNonce:get"><apiName>farNonce</apiName><shortdesc>
     由 Flash Media Server 实际选择的一个值，该值对此连接是唯一的。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     由 Flash Media Server 实际选择的一个值，该值对此连接是唯一的。此值对服务器显示为其 <codeph>client.nearNonce</codeph> 值。仅为 RTMFP、RTMPE 和 RTMPTE 连接定义此值。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:maxPeerConnections:get"><apiName>maxPeerConnections</apiName><shortdesc>
     Flash Player 或 Adobe AIR 的此实例允许的传入和传出同级连接的总数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Flash Player 或 Adobe AIR 的此实例允许的传入和传出同级连接的总数。默认值为 8。 
     <p>此值不区分发行者连接和订户连接。如果在出现同级连接时此值减小，则新值只会影响新的传入连接。不会删除现有连接。</p>
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:nearID:get"><apiName>nearID</apiName><shortdesc>
     用于此 NetConnection 实例的 Flash Player 或 Adobe AIR 实例的标识符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     用于此 NetConnection 实例的 Flash Player 或 Adobe AIR 实例的标识符。此属性仅对于 RTMFP 连接才有意义。
     
     <p>每个 NetConnection 实例均具有一个唯一的 <codeph>nearID</codeph> 属性。Flash Player 或 Adobe AIR 实例或 NetConnection 实例所具有的标识符各不相同。</p>
     
     <p>其它 Flash Player 或 Adobe AIR 实例将此标识符用作与此客户端的新 NetStream 连接的 <codeph>peerID</codeph>。随后，此标识符是连接到此实例的任何同级 NetStream 中的 <codeph>farID</codeph>。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/farID"><linktext>farID</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:nearNonce:get"><apiName>nearNonce</apiName><shortdesc>
     由此 Flash Player 或 Adobe AIR 实例实际选择的一个值，该值对此连接是唯一的。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     由此 Flash Player 或 Adobe AIR 实例实际选择的一个值，该值对此连接是唯一的。此值对服务器显示为其 <codeph>client.farNonce</codeph> 值。仅为 RTMFP、RTMPE 和 RTMPTE 连接定义此值。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     此 NetConnection 实例的对象编码。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>连接 NetConnection 实例时，会尝试设置 <codeph>objectEncoding</codeph> 属性值。
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiException><apiDesc>此属性被设置为 <codeph>ObjectEncoding.AMF0</codeph> 或 <codeph>ObjectEncoding.AMF3</codeph> 以外的值。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     此 NetConnection 实例的对象编码。
     
     <p>
     将对象写入到二进制数据中或从二进制数据中读取对象时，<codeph>defaultObjectEncoding</codeph> 属性将指示对数据进行序列化处理时应使用的 Action Message Format (AMF) 版本：ActionScript 3.0 格式 (<codeph>ObjectEncoding.AMF3</codeph>) 或 ActionScript 1.0 和 ActionScript 2.0 格式 (<codeph>ObjectEncoding.AMF0</codeph>)。可以设置 <codeph>objectEncoding</codeph> 属性，以便为 NetConnection 实例设置 AMF 版本。
     </p>
     
	 <p>如果应用程序需要与在 Flash Player 9 之前发布的服务器进行通信，则了解此属性非常重要。可能存在以下三种情况：
     </p>
     
     <ul>
	 <li>连接到支持 AMF3 的服务器（如 Flex Data Services 2 或 Flash Media Server 3）。<codeph>defaultObjectEncoding</codeph> 的默认值是 <codeph>ObjectEncoding.AMF3</codeph>。在此文件中创建的所有 NetConnection 实例均使用 AMF3 序列化，因此无需设置 <codeph>objectEncoding</codeph> 属性。</li>
       
     <li>连接到不支持 AMF3 的服务器（如 Flash Media Server 2）。在这种情况下，应将静态 <codeph>NetConnection.defaultObjectEncoding</codeph> 属性设置为 <codeph>ObjectEncoding.AMF0</codeph>。在此 SWF 文件中创建的所有 NetConnection 实例均使用 AMF0 序列化。因此不必设置 <codeph>objectEncoding</codeph> 属性。 </li>
     
     <li>连接到使用不同编码版本的多个服务器。不使用 <codeph>defaultObjectEncoding</codeph>，而是使用每个连接的 <codeph>objectEncoding</codeph> 属性设置每个连接的对象编码。要连接到使用 AMF0 编码的服务器（如 Flash Media Server 2），请将其设置为 <codeph>ObjectEncoding.AMF0</codeph>；要连接到使用 AMF3 编码的服务器（如 Flex Data Services 2），请将其设置为 <codeph>ObjectEncoding.AMF3</codeph>。</li>
     </ul>
     
     <p>在连接 NetConnection 实例后，其 <codeph>objectEncoding</codeph> 属性是只读的。</p>
     
	 <p>如果连接服务器时使用了错误的编码，则 NetConnection 对象将分派 <codeph>netStatus</codeph> 事件。<codeph>NetStatusEvent.info</codeph> 属性包含一个信息对象，此信息对象具有 <codeph>code</codeph> 属性，值为 <codeph>NetConnection.Connect.Failed</codeph>，并包含说明对象编码不正确的描述。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/defaultObjectEncoding"><linktext>defaultObjectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:protocol:get"><apiName>protocol</apiName><shortdesc>
     用于建立连接的协议。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>已尝试在未连接 NetConnection 实例时访问此属性。 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     用于建立连接的协议。在使用 Flash Media Server 时，此属性是相关的。可能值如下：
     <ul>
     <li><codeph>"rtmp"</codeph>：实时消息传递协议 (RTMP)</li>
     <li><codeph>"rtmpe"</codeph>：加密的 RTMP</li>
     <li><codeph>"rtmpt"</codeph>：HTTP 隧道 RTMP</li>
     <li><codeph>"rtmpte"</codeph>：HTTP 隧道加密的 RTMP</li>
     <li><codeph>"rtmps"</codeph>：基于 HTTPS 的 RTMP</li>
     <li><codeph>"rtmfp"</codeph>：实时媒体流协议 (RTMFP)</li>
     </ul>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:proxyType:get"><apiName>proxyType</apiName><shortdesc>
     确定到服务器的初始连接尝试失败后应使用的后备方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>This property is used in Breeze 5.5. In the Breeze Add-in, the default value is <code>"best"</code>; if this value
     is not changed, native SSL sockets are used by default, and a fallback
     to other methods is used if necessary. 
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     确定到服务器的初始连接尝试失败后应使用的后备方法。必须先设置 <codeph>proxyType</codeph> 属性，然后才能调用 <codeph>NetConnection.connect()</codeph> 方法。
     
     <p>可接受值为<codeph>“none”</codeph>、<codeph>“HTTP”</codeph>、<codeph>“CONNECT”</codeph>和<codeph>“best”</codeph>。</p>
     
	 <p>此属性的默认值为<codeph>“none”</codeph>；如果未更改此值，应用程序将对 RTMPS 使用 HTTPS 隧道。如果将此属性设置为<codeph>“best”</codeph>，客户端将尝试使用本机 SSL 进行连接。如果连接失败，客户端将尝试其它连接方法。如果将此属性设置为<codeph>“HTTP”</codeph>并且直接连接失败，则会使用 HTTP 隧道。如果将此属性设为<codeph>“CONNECT”</codeph>并且直接连接失败，则将使用隧道的 <codeph>CONNECT</codeph> 方法。如果后者也失败，连接不会使用备用的 HTTP 隧道方法。</p>
     
     <p>仅当使用 RTMP、RTMPS 或 RTMPT 时，此属性才可用。<codeph>CONNECT</codeph> 方法仅适用于通过代理服务器连接到网络上的用户。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:unconnectedPeerStreams:get"><apiName>unconnectedPeerStreams</apiName><shortdesc>
     
     一个对象，其中包含与发布方 NetStream 对象不相关的所有同级订户 NetStream 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     
     一个对象，其中包含与发布方 NetStream 对象不相关的所有同级订户 NetStream 对象。与发行方的 NetStream 对象关联的订户的 NetStream 对象位于 <codeph>NetStream.peerStreams</codeph> 数组中。
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/peerStreams"><linktext>NetStream.peerStreams</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:uri:get"><apiName>uri</apiName><shortdesc>
     传递给 NetConnection.connect() 方法的 URI。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: Documented this method with server-specific info in span tags. The
     info is relevant for Flex servers, as well as Flash Media Server.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     传递给 <codeph>NetConnection.connect()</codeph> 方法的 URI。如果尚未调用 <codeph>NetConnection.connect()</codeph> 或者未传递任何 URI，则此属性为 <codeph>undefined</codeph>。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:usingTLS:get"><apiName>usingTLS</apiName><shortdesc>
     指示是否已使用本机传输层安全 (TLS) 而不是 HTTPS 建立了一个安全连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>已尝试在未连接 NetConnection 实例时访问此属性。 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     指示是否已使用本机传输层安全 (TLS) 而不是 HTTPS 建立了一个安全连接。此属性仅在连接了 NetConnection 对象时有效。
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>