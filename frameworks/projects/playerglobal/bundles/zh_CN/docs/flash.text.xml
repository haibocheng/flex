<?xml version="1.0"?>
<apiPackage id="flash.text"><apiName>flash.text</apiName><apiDetail/><apiClassifier id="flash.text:TextExtent"><apiName>TextExtent</apiName><shortdesc>
 TextExtent 类包含有关文本字段中某些文本的范围的信息。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 TextExtent 类包含有关某些文本在文本字段中的范围的信息。此类的对象由 <codeph>TextFormat.getTextExtent</codeph> 方法返回。
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.text:TextExtent:TextExtent"><apiName>TextExtent</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>textFieldWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>textFieldHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>ascent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>descent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="flash.text:TextExtent:ascent"><apiName>ascent</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:descent"><apiName>descent</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:height"><apiName>height</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:textFieldHeight"><apiName>textFieldHeight</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:textFieldWidth"><apiName>textFieldWidth</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:width"><apiName>width</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:CSMSettings"><apiName>CSMSettings</apiName><shortdesc>
	 CSMSettings 类所包含的一些属性可与 TextRenderer.setAdvancedAntiAliasingTable() 方法配合使用以提供连续笔触调制 (CSM)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not functioning correctly. Bug report 193833
	 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 CSMSettings 类所包含的一些属性可与 <codeph>TextRenderer.setAdvancedAntiAliasingTable()</codeph> 方法配合使用以提供连续笔触调制 (CSM)。CSM 是笔触粗细和边缘清晰度的连续调制。
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links><apiConstructor id="flash.text:CSMSettings:CSMSettings"><apiName>CSMSettings</apiName><shortdesc>
     创建一个新的 CSMSettings 对象，它存储自定义消除锯齿设置的笔触值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>fontSize</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>设置所应用的大小，以像素为单位。
	 </apiDesc></apiParam><apiParam><apiItemName>insideCutoff</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>内侧截止值，高于该值时密度设置为最大密度值（如 255）。
	 </apiDesc></apiParam><apiParam><apiItemName>outsideCutoff</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>外侧截止值，低于该值时密度设置为 0。
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建一个新的 CSMSettings 对象，它存储自定义消除锯齿设置的笔触值。 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.text:CSMSettings:fontSize"><apiName>fontSize</apiName><shortdesc>
		 设置所应用的大小，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 设置所应用的大小，以像素为单位。
		 
		 <p>传递给 <codeph>setAdvancedAntiAliasingTable()</codeph> 方法的 <codeph>advancedAntiAliasingTable</codeph> 数组可以包含指定不同字体大小的 CSM 设置的多个条目。使用此属性，您可以指定其它设置所应用的字体大小。
		 </p>
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:CSMSettings:insideCutoff"><apiName>insideCutoff</apiName><shortdesc>
		 内侧截止值，高于该值时密度设置为最大密度值（如 255）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 内侧截止值，高于该值时密度设置为最大密度值（如 255）。
         
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:CSMSettings:outsideCutoff"><apiName>outsideCutoff</apiName><shortdesc>
		 外侧截止值，低于该值时密度设置为 0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 外侧截止值，低于该值时密度设置为 0。
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextColorType"><apiName>TextColorType</apiName><shortdesc>
TextColorType 类为 flash.text.TextRenderer 类提供颜色值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
TextColorType 类为 flash.text.TextRenderer 类提供颜色值。

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer"><linktext>flash.text.TextRenderer</linktext></link></related-links><apiValue id="flash.text:TextColorType:DARK_COLOR"><apiName>DARK_COLOR</apiName><shortdesc>
    用于 setAdvancedAntiAliasingTable() 方法中的 colorType 参数。</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>dark</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    用于 <codeph>setAdvancedAntiAliasingTable()</codeph> 方法中的 <codeph>colorType</codeph> 参数。使用语法 <codeph>TextColorType.DARK_COLOR</codeph>。
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextColorType:LIGHT_COLOR"><apiName>LIGHT_COLOR</apiName><shortdesc>
    用于 setAdvancedAntiAliasingTable() 方法中的 colorType 参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>light</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    用于 <codeph>setAdvancedAntiAliasingTable()</codeph> 方法中的 <codeph>colorType</codeph> 参数。使用语法 <codeph>TextColorType.LIGHT_COLOR</codeph>。	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:GridFitType"><apiName>GridFitType</apiName><shortdesc>
GridFitType 类定义 TextField 类中的网格固定值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
GridFitType 类定义 TextField 类中的网格固定值。

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiValue id="flash.text:GridFitType:NONE"><apiName>NONE</apiName><shortdesc> 
	不设置网格固定。</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	不设置网格固定。不强制根据像素网格调整字型中的水平线和垂直线。此常数用于设置 TextField 类的 <codeph>gridFitType</codeph> 属性。此设置通常适合动画或大号字。使用语法 <codeph>GridFitType.NONE</codeph>。
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue><apiValue id="flash.text:GridFitType:PIXEL"><apiName>PIXEL</apiName><shortdesc>
	使粗水平线和垂直线适合像素网格。</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pixel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	使粗水平线和垂直线适合像素网格。此常数用于设置 TextField 类的 <codeph>gridFitType</codeph> 属性。此设置只适用于左对齐文本字段，用作静态文本中的 <codeph>GridFitType.SUBPIXEL</codeph> 常数。此设置通常能为左对齐文本提供最佳可读性。使用语法 <codeph>GridFitType.PIXEL</codeph>。
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue><apiValue id="flash.text:GridFitType:SUBPIXEL"><apiName>SUBPIXEL</apiName><shortdesc>
	使粗水平线和垂直线适合 LCD 显示器中的子像素网格。</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subpixel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	使粗水平线和垂直线适合 LCD 显示器中的子像素网格。（红色、绿色和蓝色是 LCD 屏幕上的实际像素。）此设置通常适合右对齐或居中对齐的动态文本，有时，为了在动画与文本品质之间达到一种平衡，也可使用此设置。此常数用于设置 TextField 类的 <codeph>gridFitType</codeph> 属性。使用语法 <codeph>GridFitType.SUBPIXEL</codeph>。
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:StaticText"><apiName>StaticText</apiName><shortdesc>
 此类表示显示列表中的 StaticText 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 此类表示显示列表中的 StaticText 对象。无法使用 ActionScript 创建 StaticText 对象。只有创作工具可以创建 StaticText 对象。尝试创建新的 StaticText 对象会生成 <codeph>ArgumentError</codeph>。
 
 <p>要创建对 ActionScript 3.0 中的现有静态文本字段的引用，可以遍历显示列表中的项。例如，以下片段检查显示列表中是否包含静态文本字段并将该字段分配给变量：</p>
 
 <codeblock>
 var i:uint;
 for (i = 0; i &lt; this.numChildren; i++) {
     var displayitem:DisplayObject = this.getChildAt(i);
     if (displayitem instanceof StaticText) {
         trace("a static text field is item " + i + " on the display list");
         var myFieldLabel:StaticText = StaticText(displayitem);
         trace("and contains the text: " + myFieldLabel.text);
     }
 }
 </codeblock>
 </apiDesc></apiClassifierDetail><apiValue id="flash.text:StaticText:text:get"><apiName>text</apiName><shortdesc>
     返回静态文本字段的当前文本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     返回静态文本字段的当前文本。创作工具可能导出多个包含完整文本的文本字段对象。例如，对于垂直文本，创作工具将为每个字符创建一个文本字段。
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextField"><apiName>TextField</apiName><shortdesc>
 TextField 类用于创建显示对象以显示和输入文本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>TextField 类用于创建显示对象以显示和输入文本。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 TextField 类用于创建显示对象以显示和输入文本。SWF 文件中的所有动态文本字段和输入文本字段都是 TextField 类的实例。<ph outputclass="flexonly">可以使用 TextField 类执行低级文本呈现。但是，在 Flex 中，您通常使用 Label、Text、TextArea 和 TextInput 控件来处理文本。</ph> <ph outputclass="flashonly">可以在属性检查器中为文本字段指定实例名称，并且可以在 ActionScript 中使用 TextField 类的方法和属性对文本字段进行操作。TextField 实例名称显示在影片浏览器中以及“动作”面板的“插入目标路径”对话框中。</ph>
 
 <p>要动态创建文本字段，请使用 <codeph>TextField()</codeph> 构造函数。</p>
 
 <p>TextField 类的方法允许您设置、选择并操作在创作过程中或运行时创建的动态或输入文本字段中的文本。 </p>
 
 <p>ActionScript 提供了多种在运行时设置文本格式的方法。TextFormat 类允许您设置 TextField 对象的字符和段落格式。您可以使用 <codeph>TextField.styleSheet</codeph> 属性和 StyleSheet 类来对文本字段应用层叠样式表 (CSS) 样式。您可以使用 CSS 设置内置 HTML 标签的样式、定义新的格式设置标签或应用样式。可以将 HTML 格式的文本（该文本可以选择使用 CSS 样式）直接分配给文本字段。分配给文本字段的 HTML 文本可以包含嵌入的媒体（影片剪辑、SWF 文件、GIF 文件、PNG 文件和 JPEG 文件）。文本在嵌入的媒体旁自动换行，这与 Web 浏览器的文本在 HTML 文档中嵌入的媒体旁换行非常类似。 </p>
 
 <p>Flash Player 还支持部分 HTML 标签，可以使用这些 HTML 标签设置文本格式。要查看受支持 HTML 标签的列表，请参阅对 <xref href="flasht/text/TextField#htmlText">htmlText</xref> 属性的描述。</p>
 
 </apiDesc><example conref="examples\TextFieldExample.as"> 下例使用 <codeph>TextFieldExample</codeph> 类来显示文本消息。可通过以下步骤完成该操作：
 <ol>
  <li>创建 TextField 类型的 <codeph>label</codeph> 属性。</li>
  <li>类构造函数调用 <codeph>configureLabel()</codeph> 函数。</li>
  <li> <codeph>configureLabel()</codeph> 方法首先创建新的 TextField 对象并将其赋给 <codeph>label</codeph> 属性，然后设置其参数如下：
  <ul>
      <li>左对齐文本字段。</li>
      <li>启用背景填充。</li>
      <li>启用边框。</li>
  </ul>
  </li>
  <li><codeph>configureLabel()</codeph> 方法创建 <codeph>format</codeph> 变量并将该变量赋给新的 TextFormat 实例，同时如下设置其参数：
  <ul>
      <li>字体类型 = 宋体</li>
      <li>字体颜色 = 纯红色</li>
      <li>字体大小 = 10</li>
      <li>字体下划线 = true</li>
  </ul>
  </li>
  <li><codeph>label</codeph> 文本字段的 <codeph>defaultTextFormat</codeph> 属性设置为 <codeph>format</codeph>，<codeph>label</codeph> 实例将添加到显示列表中，此显示列表最初在舞台上显示不包含文本的文本字段。</li>
 
  <li>构造函数将 <codeph>label</codeph> 文本字段的文本设置为 <codeph>"Hello world and welcome to the show."</codeph> 采用方式是调用 <codeph>setLabel()</codeph> 方法。</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFormat;


    public class TextFieldExample extends Sprite {
        private var label:TextField;
        private var labelText:String = "Hello world and welcome to the show.";

        public function TextFieldExample() {
            configureLabel();
            setLabel(labelText);
        }

        public function setLabel(str:String):void {
            label.text = str;
        }

        private function configureLabel():void {
            label = new TextField();
            label.autoSize = TextFieldAutoSize.LEFT;
            label.background = true;
            label.border = true;

            var format:TextFormat = new TextFormat();
            format.font = "Verdana";
            format.color = 0xFF0000;
            format.size = 10;
            format.underline = true;

            label.defaultTextFormat = format;
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link></related-links><adobeApiEvent id="flash.text:TextField_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 用户输入一个或多个文本字符时，Flash Player 将分派 textInput 事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户输入一个或多个文本字符时，Flash Player 将分派 <codeph>textInput</codeph> 事件。各种文本输入法都可以生成此事件，包括标准键盘、输入法编辑器 (IME)、语音识别系统以及粘贴不带格式设置或样式信息的纯文本的行为。
 </apiDesc><example conref="examples\TextField_textInput.as"> 以下示例定义两个 TextField 对象：第一个 TextField 对象是一个输入文本字段，第二个 TextField 对象是一个动态文本字段。在第一个文本字段中输入文本字符时，将分派 <codeph>textInput</codeph> 事件，调用 <codeph>textInputHandler()</codeph> 处理函数，并在第二个文本字段中显示这些字符。在向该输入字段中粘贴一个文本块时，事件处理函数会将整个块复制到另一个字段中。
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.*;
    import flash.events.Event;
    import flash.events.TextEvent;
    import flash.events.MouseEvent;

    public class TextInputExample extends Sprite
    {
        private var myTextBox1:TextField = new TextField();
        private var myTextBox2:TextField = new TextField();

        public function TextInputExample()
        {
            myTextBox1.type = TextFieldType.INPUT;
            myTextBox1.width = 200;
            myTextBox1.height = 20;
            myTextBox1.background = true;
            myTextBox1.border = true;
            
            myTextBox2.x=220;

            addChild(myTextBox1);
            addChild(myTextBox2);
            myTextBox1.addEventListener(TextEvent.TEXT_INPUT,textInputHandler);
        }

        public function textInputHandler(event:TextEvent):void
        {
           myTextBox2.text=event.text;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.Event.SCROLL_scroll"><apiName>scroll</apiName><shortdesc>
 用户滚动后由 TextField 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SCROLL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户滚动<i>后</i> 由 TextField 对象分派。 
 </apiDesc><example conref="examples\TextField_scroll.as"> 下面的示例定义两个 TextField 对象。第一个 TextField 对象具有两个相关联的事件处理函数。在第一个文本字段中单击鼠标时，将分派 <codeph>mouseDown</codeph> 事件，并调用相关联的 <codeph>mouseDownScroll</codeph> 处理函数。<codeph>mouseDownScroll()</codeph> 处理函数会使该字段滚动。然后分派 <codeph>scroll</codeph> 事件，并且相关联的 <codeph>scrollHandler()</codeph> 处理函数将更新第二个文本字段以使其显示当前滚动位置。
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.*;
    import flash.events.Event;
    import flash.events.TextEvent;
    import flash.events.MouseEvent;

    public class TextScrollExample extends Sprite
    {
        private var myTextBox1:TextField = new TextField();
        private var myTextBox2:TextField = new TextField();
        private var myText:String = "Hello world and welcome to the show. It's really nice to meet you. Take your coat off and stay a while. OK, show is over. Hope you had fun. You can go home now. Don't forget to tip your waiter. There are mints in the bowl by the door. Thank you. Please come again.";

        public function TextScrollExample()
        {
            myTextBox1.text = myText;
            myTextBox1.width = 200;
            myTextBox1.height = 50;
            myTextBox1.multiline = true;
            myTextBox1.wordWrap = true;
            myTextBox1.background = true;
            myTextBox1.border = true;
            
            myTextBox2.x=220;
            myTextBox2.text="scrolled to line: " + myTextBox1.scrollV;

            addChild(myTextBox1);
            addChild(myTextBox2);
            myTextBox1.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownScroll);
            myTextBox1.addEventListener(Event.SCROLL, scrollHandler);
        }

        public function mouseDownScroll(event:MouseEvent):void
        {
            myTextBox1.scrollV++;
        }
        public function scrollHandler(event:Event):void
        {
           myTextBox2.text="scrolled to line: " + myTextBox1.scrollV;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.TextEvent.LINK_link"><apiName>link</apiName><shortdesc>
 当用户单击启用 HTML 的文本字段中的超链接（其中的 URL 以“event:”开头）时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.LINK</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户单击支持 HTML 的文本字段中的超链接（其中的 URL 以“event:”开头）时分派。URL 中“event:”后的其余部分将放在 LINK 事件的 text 属性中。
 <p><b>注意：</b>仅在 Flash Player 生成此事件时（在本例中，当用户尝试输入文本时发生此事件）才发生默认行为（向文本字段中添加文本）。无法通过发送 <codeph>textInput</codeph> 事件来在文本字段中放置文本。</p>
 </apiDesc><example conref="examples\TextField_event_link.as"> 在下面的示例中，定义了 <codeph>playMP3()</codeph> 函数。创建一个名为 <codeph>list</codeph> 的 TextField 对象，并向其中填充了 HTML 文本。文本 <codeph>"Track 1"</codeph> 和 <codeph>"Track 2"</codeph> 是文本字段中的链接。在用户单击任一链接时，调用 playMP3() 函数。HTML 标签的 <codeph>href</codeph> 属性中跟随在字符串“event:”之后的 MP3 文件名将被传递给 <codeph>linkHandler()</codeph> 方法，作为 <codeph>link</codeph> 事件对象的 <codeph>text</codeph> 属性。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.errors.IOError;
    import flash.events.IOErrorEvent;
    import flash.events.TextEvent;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class TextField_event_link extends Sprite
    {
        private var myMP3:Sound;
        public function TextField_event_link() {
            myMP3 = new Sound();
            var list:TextField = new TextField();
            list.autoSize = TextFieldAutoSize.LEFT;
            list.multiline = true;
            list.htmlText = "&lt;a href=\"event:track1.mp3\">Track 1&lt;/a>&lt;br>";
            list.htmlText += "&lt;a href=\"event:track2.mp3\">Track 2&lt;/a>&lt;br>";
            addEventListener(TextEvent.LINK, linkHandler);
            addChild(list);
        }
        
        private function playMP3(mp3:String):void {
            try {    
                myMP3.load(new URLRequest(mp3));
                myMP3.play();
            }
            catch(err:Error) {
                trace(err.message);
            }
            myMP3.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }
        
        private function linkHandler(linkEvent:TextEvent):void {
            playMP3(linkEvent.text);
        }
        
        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.Event.CHANGE_change"><apiName>change</apiName><shortdesc>
 在修改控件值后分派，这与 textInput 事件不同，后者是在修改值之前分派的。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在修改控件值后分派，这与 <codeph>textInput</codeph> 事件不同，后者是在修改值之前分派的。与 W3C DOM 事件模型版本的 <codeph>change</codeph> 事件（仅在控件失去焦点后分派此事件）不同，每当控件更改时即会分派 ActionScript 3.0 版本的 <codeph>change</codeph> 事件。例如，如果用户向文本字段中键入文本，则在每次键击后分派 <codeph>change</codeph> 事件。
 </apiDesc><example conref="examples\TextField_Event_changeExample.as"> 在下面的示例中，将用户输入的文本（用户输入）立即复制（回显）到另一个具有不同文本格式的文本字段中。 
 
 <p>共创建了两个文本字段，一个用于显示用户输入，另一个 (<codeph>headingTextField</codeph>) 用于显示用户输入副本。还创建了一个 TextFormat 对象，并将默认的文本格式分配给 <codeph>headingTextField</codeph> 文本字段。在更改文本字段的内容时，将调用 <codeph>changeHandler()</codeph> 方法，它将 <codeph>inputTextField</codeph> 文本字段中的文本分配给 <codeph>headingTextField</codeph> 文本字段。（如果为 <codeph>TextEvent.TEXT_INPUT</codeph> 事件而不是 <codeph>Event.CHANGE</codeph> 事件调用该方法，则仅在用户输入更多文本后才会复制用户输入的内容。）</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFormat;
    import flash.text.TextFormatAlign;
    import flash.events.Event;
    
    import flash.events.TextEvent;

    public class TextField_Event_changeExample extends Sprite {
        private var inputTextField:TextField = new TextField(); 
        private var headingTextField:TextField = new TextField(); 
        private var newFormat:TextFormat = new TextFormat();
         
        public function TextField_Event_changeExample() {
            headingTextField.x = 10;
            headingTextField.y = 10;
            headingTextField.height = 30;
            headingTextField.width = 400;
            headingTextField.background = true;
            headingTextField.backgroundColor = 0xF5F5DC;
            headingTextField.selectable = false;
 
            inputTextField.x = 10;
            inputTextField.y = 70;
            inputTextField.height = 20;
            inputTextField.width = 230;
            inputTextField.background = true;
            inputTextField.border = true;
            inputTextField.maxChars = 40;
            inputTextField.wordWrap = true;
            inputTextField.type = TextFieldType.INPUT;

            inputTextField.addEventListener(Event.CHANGE, changeHandler);

            newFormat.bold = true;
            newFormat.size = 18;
            newFormat.color = 0xFF0000;
            newFormat.align = TextFormatAlign.CENTER;

            headingTextField.defaultTextFormat = newFormat;

            this.addChild(inputTextField);
            this.addChild(headingTextField);
        }

        private function changeHandler(e:Event):void {
            headingTextField.text = inputTextField.text;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.text:TextField:TextField"><apiName>TextField</apiName><shortdesc>
	创建新的 TextField 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need to add an example.
	 </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	创建新的 TextField 实例。在创建 TextField 实例后，调用父 DisplayObjectContainer 对象的 <codeph>addChild()</codeph> 或 <codeph>addChildAt()</codeph> 方法可将 TextField 实例添加到显示列表中。
     <p>文本字段的默认大小是 100 x 100 个像素。</p>
	 
	 
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.text:TextField:appendText"><apiName>appendText</apiName><shortdesc>
	 将 newText 参数指定的字符串追加到文本字段的文本的末尾。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要追加到现有文本末尾的字符串。
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>将文本追加到 TextField 现有文本的末尾。
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 将 <codeph>newText</codeph> 参数指定的字符串追加到文本字段的文本的末尾。此方法要比对 <codeph>text</codeph> 属性的加法赋值 (<codeph>+=</codeph>)（如 <codeph>someTextField.text += moreText</codeph>）更有效，对于包含大量内容的文本字段尤其有效。
     
	 </apiDesc><example conref="examples\TextField_appendTextExample.as"> 如果不是周末，下面的示例将显示时间；如果是周末，则显示文本“It's the weekend”。它还计算到某个位置之前的字符数以及文本字段中的行数。
 
 <p><codeph>outputText</codeph> 文本字段被设置为自动适应文本，并使用 <codeph>autoSize</codeph> 属性将其调整为左对齐的文本。<codeph>outputText.text</codeph> 属性写入第一行内容，并由 <codeph>appendText()</codeph> 方法附加其余的内容。（并非必须以 <codeph>text</codeph> 属性开头。也可以从一开始就使用 <codeph>appendText()</codeph> 方法附加文本。） 第二次设置 <codeph>text</codeph> 属性时，将覆盖原始文本。可以使用 <codeph>+=</codeph> 运算符通过 <codeph>text</codeph> 属性附加内容。</p>
 
 <p><codeph>if</codeph> 语句检查日期是否为星期六 (6) 或星期日 (0)。如果不是，<codeph>toLocaleTimeString()</codeph> 方法将返回本地时间，它将附加到文本字段内容中。</p> 
 
 <p>文本字段的 <codeph>length</codeph> 属性用于读取就在调用函数之前的字符数；而属性 <codeph>numLines</codeph> 用于计算文本字段中的行数。请注意，在计算行数时将空行计算在内，并在确定长度内容时将空格和换行符 (\n) 计算在内。</p>   
 
<codeblock>
  package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
 
    public class TextField_appendTextExample extends Sprite {
         
        public function TextField_appendTextExample() {
            var outputText:TextField = new TextField();
            var today:Date = new Date();
                
            outputText.x = 10;
            outputText.y = 10;
            outputText.background = true;
            outputText.autoSize = TextFieldAutoSize.LEFT;
 
            outputText.text = "WHAT TIME IS IT?" + "\n\n";
 
            if((today.day == 0) || (today.day == 6)) {
                outputText.appendText("It's the weekend.");
                outputText.appendText("\n\n");
           
            } else {
                outputText.appendText("The time is: ");
                outputText.appendText(today.toLocaleTimeString() + ".\n\n");  
            }

            outputText.appendText("Number of characters including line breaks and spaces so far: ");
            outputText.appendText(outputText.length.toString() + "\n");
            outputText.appendText("Number of lines in the outputText: ");
            outputText.appendText(outputText.numLines.toString());   

            this.addChild(outputText);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getCharBoundaries"><apiName>getCharBoundaries</apiName><shortdesc>
	 返回一个矩形，该矩形是字符的边框。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个矩形，具有定义字符边框的 <codeph>x</codeph> 和 <codeph>y</codeph> 最小值和最大值。
	 
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>从零开始的字符索引值（例如，第一个位置为 0，第二个位置为 1，依此类推）。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>返回一个矩形，该矩形是字符的边框。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回一个矩形，该矩形是字符的边框。
	 
	 </apiDesc><example conref="examples\TextField_getCharBoundariesExample.as"> 在下面的示例中，使用 <codeph>getCharBoundaries()</codeph> 方法标记（产生聚光灯照射效果）用户选择的字符。
 
 <p>该类定义了 <codeph>spotlight</codeph> Shape 对象，该对象用于在每个所选的字符周围绘制一个矩形。当用户单击 <codeph>myTextField</codeph> 文本字段时，将调用 <codeph>clickHandler()</codeph> 方法。</p>
 
 <p>在 <codeph>clickHandler()</codeph> 方法中，<codeph>getCharIndexAtPoint()</codeph> 方法基于鼠标单击的 <codeph>localX</codeph> 和 <codeph>localY</codeph> 坐标来获取所单击的字符的索引，此坐标相对于包含它的 <codeph>Sprite</codeph>。如果该点（鼠标单击）不在任何字符上，<codeph>getCharIndexAtPoint()</codeph> 方法将返回 <codeph>-1</codeph>。由于文本字段可能比文本大，因此，应检查返回的整数 (<codeph>index</codeph>) 以确保用户单击了某个字符。<codeph>getCharBoundaries()</codeph> 还使用 <codeph>index</codeph> 整数来获取用于保存字符边界的 <codeph>Rectangle</codeph> 对象。<codeph>clear()</codeph> 方法将清除以前显示的所有 <codeph>spotlight</codeph> Shape 对象。将使用返回的 <codeph>frame</codeph> 矩形的 x 和 y 坐标，在字符位置生成一个字符宽度和高度边界大小的新矩形，字符位置是相对于 (10, 10) 坐标的偏移。要产生用聚光灯照射字符的效果，请使用黄色填充 <codeph>spotlight</codeph> Shape 对象，并将不透明度设置为 35%，以便能够看到字符。请注意，空格也被视为字符。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
    import flash.display.Shape;

    public class TextField_getCharBoundariesExample extends Sprite
    {
        private var myTextField:TextField = new TextField();    
        private var spotlight:Shape = new Shape();
        
        public function TextField_getCharBoundariesExample() {
            
            myTextField.x = 10;
            myTextField.y = 10; 
            myTextField.border = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            myTextField.text = "Selected a character from this text by clicking on it."

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            this.addChild(myTextField);    
            this.addChild(spotlight);
         }

        private function clickHandler (e:MouseEvent):void {
            var index:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
 
            if (index != -1) {
                 var frame:Rectangle = myTextField.getCharBoundaries(index);

                spotlight.graphics.clear();    
                spotlight.graphics.beginFill(0xFFFF00, .35);
                spotlight.graphics.drawRect((frame.x + 10), (frame.y + 10), frame.width, frame.height);            
                spotlight.graphics.endFill();
            }
        } 
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getCharIndexAtPoint"><apiName>getCharIndexAtPoint</apiName><shortdesc>
	 在 x 和 y 参数指定的位置返回从零开始的字符索引值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>从零开始的字符索引值（例如，第一个位置为 0，第二个位置为 1，依此类推）。如果该位置没有任何字符，则返回 -1。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>字符的 <i>x</i> 坐标。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>字符的 <i>y</i> 坐标。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>返回从零开始的字符索引值。
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 在 <codeph>x</codeph> 和 <codeph>y</codeph> 参数指定的位置返回从零开始的字符索引值。
	 
	 </apiDesc><example conref="examples\TextField_getCharIndexAtPointExample.as"> 在下面的示例中，当用户单击某个字符时，将在另一个文本字段中的文本上面回显该字符。
 
 <p>第一个文本字段用于保存用户将要选择的文本。为了确保单击该文本而没有将其选定，请将 <codeph>selectable</codeph> 属性设置为 false。当用户单击 <codeph>firstTextField</codeph> 文本字段时，将调用 <codeph>clickHandler()</codeph> 方法。</p>
 
 <p>在 <codeph>clickHandler()</codeph> 方法中，<codeph>getCharIndexAtPoint()</codeph> 方法基于鼠标单击的 <codeph>localX</codeph> 和 <codeph>localY</codeph> 坐标来返回字符的索引。由于文本字段可能比文本大，因此，应检查返回整数 (<codeph>index</codeph>) 以确保用户单击了某个字符。（如果该点（鼠标单击）不在某个字符上，<codeph>getCharIndexAtPoint()</codeph> 方法将返回 <codeph>-1</codeph>。）鼠标坐标用于设置显示回显字符的新文本字段的坐标。第二个文本字段中的字符颜色设置为红色。最后，第二个字段中的文本设置为选定的字符，它是使用 <codeph>charAt()</codeph> 方法检索的。请注意，如果使用 <codeph>text</codeph> 属性而不是 <codeph>appendText()</codeph> 方法，则会覆盖第二个文本字段中的字符，而不是进行附加。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_getCharIndexAtPointExample extends Sprite {
        private var firstTextField:TextField = new TextField();    
        private var secondTextField:TextField = new TextField();
        
        public function TextField_getCharIndexAtPointExample() {

            firstTextField.x = 100;
            firstTextField.y = 100; 
            firstTextField.width = 260;
            firstTextField.height = 20;
            firstTextField.border = true;
            firstTextField.background = true;
            firstTextField.selectable = false;
            
            firstTextField.text = "Selected a character from this text by clicking on it."

            firstTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(firstTextField);    
            this.addChild(secondTextField);
         }

        private function clickHandler (e:MouseEvent):void {
            var index:int = firstTextField.getCharIndexAtPoint(e.localX, e.localY);

            if (index != -1) {
                secondTextField.x = mouseX;
                secondTextField.y =  70;
                secondTextField.border = true;
                secondTextField.selectable = false;
                secondTextField.background = true;
                secondTextField.textColor = 0xFF0000;
                secondTextField.autoSize = TextFieldAutoSize.LEFT;
                secondTextField.text = firstTextField.text.charAt(index);    
            }
        } 
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getFirstCharInParagraph"><apiName>getFirstCharInParagraph</apiName><shortdesc>
	 如果给定一个字符索引，则返回同一段落中第一个字符的索引。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>指定的字符索引超出范围。
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>同一段落中从零开始的第一个字符索引值。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>从零开始的字符索引值（例如，第一个字符的索引值是 0，第二个字符的索引值是 1，依此类推）。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>从零开始的字符索引值。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 如果给定一个字符索引，则返回同一段落中第一个字符的索引。
	 
	 </apiDesc><example conref="examples\TextField_getFirstCharInParagraphExample.as"> 在下面的示例中，为文本字段内容应用了段落格式。当用户单击段落时，将右对齐段落文本；当用户再次单击段落时，将恢复为原始（默认）格式（左对齐）。
 
 <p>在构造函数中，将 <codeph>myTextField</codeph> 文本字段设置为文本换行。<codeph>getTextFormat</codeph> 方法返回文本字段内容中的第一个字符的原始格式，此格式放置在 <codeph>originalFormat</codeph> TextFormat 对象中。还定义了一个新的 TextFormat 对象 (<codeph>newFormat</codeph>)，并将其 <codeph>align</codeph> 属性指定为右对齐。当用户单击文本字段时，将调用 <codeph>clickHandler()</codeph> 方法。</p>
 
 <p>在 <codeph>clickHandler()</codeph> 方法中，<codeph>getCharIndexAtPoint()</codeph> 方法基于鼠标单击的 <codeph>localX</codeph> 和 <codeph>localY</codeph> 坐标来返回字符的索引。第一条 <codeph>if</codeph> 语句检查以确定用户是否已单击了某个字符。通过使用由 <codeph>getCharIndexAtPoint()</codeph> 方法返回的 <codeph>clickIndex</codeph> 整数，<codeph>getFirstCharInParagraph()</codeph> 方法将返回用户单击的段落中的第一个字符的索引。段落中的最后一个字符的索引是使用以下方法确定的：将段落中的第一个字符的索引与段落长度（使用 <codeph>getParagraphLength()</codeph> 方法）相加，然后减去最后一个字符 (<codeph>\n</codeph>)。第二条 <codeph>if</codeph> 语句检查段落中的第一个字符的格式。如果其对齐方式值与原始格式（左对齐）相同，则将新格式应用于段落中的所有字符。否则，将段落格式重新设置为原始格式。对齐方式以及格式（如缩进、项目符号、Tab 停靠位、左和右边距）都是用于段落的格式。请注意，在使用自动换行或换行符后，如果没有为 <codeph>setTextFormat()</codeph> 方法定义 <codeph>endIndex</codeph> 参数，该格式仅适用于段落的第一行。</p>
     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.text.TextFormatAlign;

    public class TextField_getFirstCharInParagraphExample extends Sprite
    {
        private var myTextField:TextField = new TextField();
        private var originalFormat:TextFormat = new TextFormat();
        private var newFormat:TextFormat = new TextFormat(); 
        
        public function TextField_getFirstCharInParagraphExample() {
            myTextField.x = 10;
            myTextField.y = 10; 
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.width = 300;
            myTextField.height = 300; 
            myTextField.background = true;
             
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file " 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                        + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                        + "Target Path dialog box in the Actions panel.\n\n"  
                        + "To create a text field dynamically, use the TextField constructor.\n\n"
                        + "The methods of the TextField class let you set, select, and manipulate "  
                        + "text in a dynamic or input text field that you create during authoring or at runtime.\n\n");

            originalFormat = myTextField.getTextFormat(0);

            newFormat.align = TextFormatAlign.RIGHT;

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
  
            this.addChild(myTextField);
        }

        private function clickHandler(e:MouseEvent):void {
            var clickIndex:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
                  
            if(clickIndex != -1) {
                var paragraphFirstIndex:int = myTextField.getFirstCharInParagraph(clickIndex);
                var paragraphEndIndex:int = paragraphFirstIndex + ((myTextField.getParagraphLength(clickIndex) - 1));
            
                if (myTextField.getTextFormat(paragraphFirstIndex).align == originalFormat.align) {
                     myTextField.setTextFormat(newFormat, paragraphFirstIndex, paragraphEndIndex);
                }else {
                     myTextField.setTextFormat(originalFormat, paragraphFirstIndex, paragraphEndIndex);
                }
            } 
        }
    }
}
 
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getImageReference"><apiName>getImageReference</apiName><shortdesc>
	 返回给定 id 或已使用 &amp;lt;img&amp;gt; 标签添加到 HTML 格式文本字段中的图像或 SWF 文件的 DisplayObject 引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>与图像或 SWF 文件（在文本字段的 <codeph>&lt;img></codeph> 标签中具有匹配 <codeph>id</codeph> 属性）对应的显示对象。对于从外部源加载的媒体，此对象是 Loader 对象，加载后，媒体对象是该 Loader 对象的子项。对于在 SWF 文件中嵌入的媒体，这是加载的对象。如果不存在具有匹配 <codeph>id</codeph> 的 <codeph>&lt;img></codeph> 标签，则此方法会返回 <codeph>null</codeph>。
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要匹配的 <codeph>id</codeph>（在 <codeph>&lt;img></codeph> 标签的 <codeph>id</codeph> 属性中）。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回给定 <codeph>id</codeph> 或已使用 <codeph>&lt;img></codeph> 标签添加到 HTML 格式文本字段中的图像或 SWF 文件的 DisplayObject 引用。<codeph>&lt;img></codeph> 标签的格式如下：
	 
	 <p><pre><codeph>	&lt;img src = 'filename.jpg' id = 'instanceName' ></codeph></pre></p>
	 
	 </apiDesc><example conref="examples\TextField_getImageReferenceExample.as"> 在下面的示例中，当单击文本字段时，字段中的图像将被设置为 25% 不透明度，并从其原始方向旋转 90 度。以后，每次单击时，该图像将继续旋转。
 
 <p>此图像 (<codeph>image.jpg</codeph>) 是通过 HTML 包括的。（此处，假定图像文件位于与 SWF 文件相同的目录中。）为了使用 <codeph>getImageReference()</codeph> 方法访问该图像，您需要为 <codeph>img</codeph> 标签定义 <codeph>id</codeph> 属性。<codeph>htmlText</codeph> 属性用于包括 HTML 格式的字符串内容。当用户单击 <codeph>myTextField</codeph> 文本字段时，将调用 <codeph>clickHandler()</codeph> 方法。</p> 
 
 <p>在 <codeph>clickHandler()</codeph> 方法中，<codeph>getImageReference()</codeph> 方法将对图像的引用作为 <codeph>DisplayObject</codeph> 返回。可以使用此引用来处理图像，就像任何 <codeph>DisplayObject</codeph> 对象一样。此处，设置了 <codeph>alpha</codeph>（透明度）和 <codeph>rotation</codeph> 属性。还可以使用 <codeph>transform</codeph> 属性访问显示对象的矩阵、颜色转换和像素范围。另请注意，需要导入 <codeph>flash.display.DisplayObject</codeph>。</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.display.DisplayObject;
    
    import flash.text.TextFieldAutoSize;
    
    public class TextField_getImageReferenceExample extends Sprite
    {
        private var myTextField:TextField = new TextField();
        
        public function TextField_getImageReferenceExample()
        {
            var myText1:String = "&lt;p>Here is an image we want to mainpulate: &lt;img src='image.jpg' id='testimage'>&lt;/p>";

            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 250;
            myTextField.height = 250;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.border = true;
            myTextField.multiline = true;

            myTextField.htmlText = myText1;
            
            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            this.addChild(myTextField);
        }
 
        private function clickHandler(e:MouseEvent):void {
            var imageRef:DisplayObject = myTextField.getImageReference("testimage");
 
            imageRef.rotation += 90;
            imageRef.x = 125;
            imageRef.y = 125;
            imageRef.alpha = 0.25;      
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>htmlText</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getLineIndexAtPoint"><apiName>getLineIndexAtPoint</apiName><shortdesc>
	 在 x 和 y 参数指定的位置返回从零开始的行索引值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>从零开始的行索引值（例如，第一行的索引值是 0，第二行的索引值是 1，依此类推）。如果该位置没有任何行，则返回 -1。
 	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>行的 <i>x</i> 坐标。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>行的 <i>y</i> 坐标。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>指定位置处行的索引值（从零开始）。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 在 <codeph>x</codeph> 和 <codeph>y</codeph> 参数指定的位置返回从零开始的行索引值。
	 
	 </apiDesc><example conref="examples\TextField_getLineIndexAtPointExample.as"> 在下面的示例中，当用户从莎士比亚的十四行诗中选择一行时，则会将其复制（附加）到新文本字段中。   
 
 <p>在构造函数中，将 <codeph>poem</codeph> 文本字段设置为不换行（因为它是一首诗）。还使用 <codeph>autoSize</codeph> 属性将文本设置为自动适应，并让其调整为左对齐的文本； 并将 <codeph>poemCopy</codeph> 文本字段放在 <codeph>poem</codeph> 文本字段下面。当用户单击诗歌的某一行时，将调用 <codeph>clickHandler()</codeph> 方法。</p>
 
 <p>在 <codeph>clickHandler()</codeph> 方法中，<codeph>getLineIndexAtPoint()</codeph> 方法基于鼠标单击的 <codeph>localX</codeph> 和 <codeph>localY</codeph> 坐标返回用户已单击的位置的行索引。（由于原始诗歌适合此处的文本字段大小，因此，不需要检查由 <codeph>getCharIndexAtPoint()</codeph> 方法引发的超出范围错误 (<codeph>RangeError</codeph>)。）接下来，使用行索引获取该行的内容（作为 <codeph>getLineText()</codeph> 方法中的字符串），然后将其附加到 <codeph>poemCopy</codeph> 文本字段内容中。可以连续进行复制，但在某一时刻后，文本将超出可查看的 <codeph>poemCopy</codeph> 文本字段范围之外。</p>    
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;

    public class TextField_getLineIndexAtPointExample extends Sprite {
        private var poem:TextField = new TextField();
        private var poemCopy:TextField = new TextField();
        
        public function TextField_getLineIndexAtPointExample() {
            poem.border = true;
            poem.autoSize = TextFieldAutoSize.LEFT;
            poem.x = 10;
            poem.wordWrap = false;

            poemCopy.height = 250;
            poemCopy.width = 270;
            poemCopy.y = 230;
            poemCopy.x = 10;
            poemCopy.background = true;
            poemCopy.border = true;
            poemCopy.wordWrap = false;
            
            poem.appendText("Let me not to the marriage of true minds\n"
                              + "Admit impediments. love is not love\n"
                              + "Which alters when it alteration finds\n"
                              + "Or bends with the remover to remove:\n"
                              + "O no! it is an ever-fixed mark\n" 
                              + "That looks on tempests and is never shaken;\n"
                              + "It is the star to every wandering bark,\n"
                              + "Whose worth's unknown, although his height be taken.\n"
                              + "Love's not Time's fool, though rosy lips and cheeks\n"
                              + "Within his bending sickle's compass come:\n"
                              + "Love alters not with his brief hours and weeks,\n"
                              + "But bears it out even to the edge of doom.\n"
                              + "If this be error and upon me proved,\n"
                              + "I never writ, nor no man ever loved.");

           poem.addEventListener(MouseEvent.CLICK, clickHandler); 

           this.addChild(poem); 
           this.addChild(poemCopy);
        }
    
        private function clickHandler(e:MouseEvent):void {
                var index:int = poem.getLineIndexAtPoint(e.localX, e.localY);
                var s:String;

                s = poem.getLineText(index);
                poemCopy.appendText(s + "\n");
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineIndexOfChar"><apiName>getLineIndexOfChar</apiName><shortdesc>
	 返回 charIndex 参数指定的字符所在的行的索引值（从零开始）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>指定的字符索引超出范围。
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>从零开始的行索引值。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>从零开始的字符索引值（例如，第一个字符的索引值是 0，第二个字符的索引值是 1，依此类推）。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>包含 <codeph>charIndex</codeph> 参数指定的字符的行的索引值（从零开始）。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回 <codeph>charIndex</codeph> 参数指定的字符所在的行的索引值（从零开始）。
	 
	 </apiDesc><example conref="examples\TextField_getLineIndexOfCharExample.as"> 在下面的示例中，<codeph>getLineIndexOfChar()</codeph> 方法返回文本字段中的第 100 个和第 500 个字符的行号。
 
 <p>我们将 <codeph>myTextField</codeph> 文本字段定义为换行并调整为左对齐的文本。<codeph>getLineIndexOfChar()</codeph> 方法返回指定的字符索引（100 和 500）的行索引。然后，将此信息附加到段落后面。请注意，由于行索引从 0 开始，因此，将行索引 (<codeph>index</codeph>) 增加 1 可得出行号。另外，如果调整显示方式，行号可能会发生改变，但此处的信息保持不变，因为只调用一次该方法。</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class TextField_getLineIndexOfCharExample extends Sprite 
    {
        public function TextField_getLineIndexOfCharExample()
        {
            var myTextField:TextField = new TextField();
            
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 200;
            myTextField.background = true;  
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.autoSize = TextFieldAutoSize.LEFT;

            myTextField.appendText("The TextField class is used to create display objects for "
                + "text display and input. All dynamic and input text fields in a SWF file" 
                + "are instances of the TextField class. You can use the TextField class "
                + "to perform low-level text rendering. However, in Flex, you typically use "
                + "the Label, Text, TextArea, and TextInput controls to process text. "  
                + "You can give a text field an instance name in the Property inspector "
                + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                + "Target Path dialog box in the Actions panel.\n\n");

            var index:int = myTextField.getLineIndexOfChar(100);
            myTextField.appendText("100th character is in line: " +  (index + 1) + "\n");
            index = myTextField.getLineIndexOfChar(500);
            myTextField.appendText("500th character is in line: " + (index + 1));

            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineLength"><apiName>getLineLength</apiName><shortdesc>
	 返回特定文本行中的字符数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getLineLength, getLineLength
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>指定的行号超出范围。
	 
 	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>行中的字符数。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>需要其长度的行号。
	 </apiDesc></apiParam><apiTipTexts><apiTipText>返回特定文本行中的字符数。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回特定文本行中的字符数。
	 
	 </apiDesc><example conref="examples\TextField_getLineLengthExample.as"> 在下面的示例中，当用户选择某一行后，将在单独的文本字段中显示其行长度（字符数）。 
 <p>为了便于说明，我们将 <codeph>myTextField</codeph> 文本字段（显示将要计算的文本）设置为 <codeph>INPUT</codeph>，这意味着用户可以实际更改行，或者在行之间或结尾处添加行。（通过使用换行符 (<codeph>\n</codeph>)，在最后一行的结尾处创建了一个空行。）在 <codeph>myTextField</codeph> 文本字段下面设置了 <codeph>countLines</codeph> 文本字段（其中显示行长度的计算结果），但无法选择该字段中的文本。当用户单击 <codeph>myTextField</codeph> 文本字段中的某一行时，将调用 <codeph>clickHandler()</codeph> 方法。</p>
 <p>在 <codeph>clickHandler()</codeph> 方法中，<codeph>getLineIndexAtPoint()</codeph> 方法通过使用鼠标单击的 <codeph>localX</codeph> 和 <codeph>localY</codeph> 坐标来返回用户所单击的位置的行索引。<codeph>if</codeph> 语句检查以确定用户是否已单击了某个字符。如果是，<codeph>getLineLength()</codeph> 方法将使用行索引返回行中的字符数。请注意，行之间的空行包含第二个换行符 (<codeph>\n</codeph>) 并计为 1 个字符；而最后一行后面的空行计为 0 个字符。空格也计为一个字符。用户可以编写新的行或更改某一行，也可以单击某一行以获取其字符数。如果使用文本换行并调整屏幕大小，行索引可能会发生变化。</p>
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.events.Event;
    import flash.events.MouseEvent;

    public class TextField_getLineLengthExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countLines:TextField = new TextField();  

        public function TextField_getLineLengthExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 350;
            myTextField.height = 150;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.type = TextFieldType.INPUT;
            
            myTextField.appendText("Click on the lines to count its number of characters:\n\n");
            myTextField.appendText("This is a short line.\n");
            myTextField.appendText("This is a longer line than the last line.\n\n");
            myTextField.appendText("This one is even longer than the one before. It has two sentences.\n");

            this.addChild(myTextField);

            countLines.border = true;
            countLines.x = 10;
            countLines.y = 180;
            countLines.height = 30;
            countLines.width = 200;
            countLines.background = true;
            countLines.selectable = false;

           this.addChild(countLines);    

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
        }

        private function clickHandler(e:MouseEvent):void {
            var index:int = myTextField.getLineIndexAtPoint(e.localX, e.localY);
        
            if (index != -1) {
            var lenght:int = myTextField.getLineLength(index);

            countLines.text = "Number of characters in the line is: " + lenght.toString();
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineMetrics"><apiName>getLineMetrics</apiName><shortdesc>
	 返回给定文本行的度量信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getLineMetrics, getLineMetrics
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>指定的行号超出范围。
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个 TextLineMetrics 对象。
	 </apiDesc><apiOperationClassifier>flash.text:TextLineMetrics</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>需要相关度量信息的行号。
	 </apiDesc></apiParam><apiTipTexts><apiTipText>返回给定文本行的度量信息。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回给定文本行的度量信息。
	 
	 </apiDesc><example conref="examples\TextField_getLineMetricsExample.as"> 下面的示例显示两个不同格式的文本行的某些行度量值。
 
 <p>附加的文本选自 Walt Whitman 的诗歌 <i>Song of Myself</i> 中的两行。使用了一个新的 TextFormat 对象 (<codeph>newFormat</codeph>) 来设置第二行的格式。第一行保留默认格式。<codeph>getLineMetrics()</codeph> 方法返回特定行的 <codeph>TextLineMetrics</codeph> 对象。（行索引从 0 开始。） 通过分别使用第 1 行和第 2 行的 <codeph>metrics1</codeph> 和 <codeph>metrics2</codeph> TextLineMetrics 对象，可以检索并显示这两行的 ascent、descent、height 和 weight 值。结果数字将转换为字符串，而不进行舍入。请注意，该值用于行而不是特定字符。它反映了某一行的字符范围。例如，如果某一行中包含各种具有不同高度格式的字符，则由高度最高的字符确定该值。这也意味着，如果其中一个字符的格式发生变化，某些度量值也可能会发生变化。</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextLineMetrics;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.TextFormat;
 
    public class TextField_getLineMetricsExample extends Sprite {

        public function TextField_getLineMetricsExample() {
            var myTextField:TextField = new TextField();
            var newFormat:TextFormat = new TextFormat(); 

            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.wordWrap = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            myTextField.appendText("A child said What is the grass? fetching it to me with full hands;\n");
            myTextField.appendText("How could I answer the child? I do not know what it is any more than he.\n\n");

            newFormat.size = 14;
            newFormat.font = "Arial";
            newFormat.italic = true;
            myTextField.setTextFormat(newFormat, 67, 139);
               
            var metrics1:TextLineMetrics = myTextField.getLineMetrics(0);
             
            myTextField.appendText("Metrics ascent for the line 1 is: " + metrics1.ascent.toString() + "\n");
            myTextField.appendText("Metrics descent is: " + metrics1.descent.toString() + "\n");
            myTextField.appendText("Metrics height is: " + metrics1.height.toString() + "\n"); 
            myTextField.appendText("Metrics width is: " + metrics1.width.toString() + "\n\n");

            var metrics2:TextLineMetrics = myTextField.getLineMetrics(1);
             
            myTextField.appendText("Metrics ascent for the line 2 is: " + metrics2.ascent.toString() + "\n");
            myTextField.appendText("Metrics descent is: " + metrics2.descent.toString() + "\n");
            myTextField.appendText("Metrics height is: " + metrics2.height.toString() + "\n"); 
            myTextField.appendText("Metrics width is: " + metrics2.width.toString() + "\n");

            addChild(myTextField);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>flash.text.TextLineMetrics</linktext></link><link href="flash.text.xml#TextLineMetrics"><linktext>flash.text.TextLineMetrics</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getLineOffset"><apiName>getLineOffset</apiName><shortdesc>
	 返回 lineIndex 参数指定的行中第一个字符的字符索引。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>指定的行号超出范围。
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>行中第一个字符的索引值（从零开始）。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>从零开始的行索引值（例如，第一行的索引值是 0，第二行的索引值是 1，依此类推）。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>行中第一个字符的索引值（从零开始）。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回 <codeph>lineIndex</codeph> 参数指定的行中第一个字符的字符索引。
	 
	 </apiDesc><example conref="examples\TextField_getLineOffsetExample.as"> 下面的示例检查第 4 行中的第一个字符，如果调整了屏幕（和文本字段）大小，该字符将会发生变化。
 
 <p>我们将 <codeph>myTextField</codeph> 文本字段设置为自动换行。<codeph>countField</codeph> 文本字段将显示第 4 行中的第一个字符。当用户单击 <codeph>myTextField</codeph> 文本字段时，将调用 <codeph>clickHandler()</codeph> 方法。</p>
 
 <p>在 <codeph>clickHandler()</codeph> 方法中，<codeph>getLineOffset()</codeph> 方法返回行索引 3（第 4 个文本行）中的第一个字符的索引。（第 1 行包含索引 0。） 我们使用 <codeph>charAt()</codeph> 方法以及第 4 行中的第一个字符的索引来获取字符； 并通过 <codeph>countField</codeph> 文本字段的 <codeph>text</codeph> 属性使用此信息更新 <codeph>countField</codeph> 文本字段内容。使用 <codeph>countField.text</codeph> 属性意味着，每次单击后，将会覆盖 <codeph>countField</codeph> 文本字段的内容。如果用户调整了显示方式，内容将会换行，第 4 行中的第一个字符可能会发生变化。通过再次单击 <codeph>myTextField</codeph> 字段，将使用第 4 行中的第一个字符（新字符）更新 <codeph>countField</codeph> 文本字段的内容。</p>    
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;

    public class TextField_getLineOffsetExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countField:TextField = new TextField();
        
        public function TextField_getLineOffsetExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 150;
            myTextField.height = 300;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.wordWrap = true;

            countField.height = 20;
            countField.width = 200;
            countField.x = 10;
            countField.y = 320;
            countField.selectable = false;
            
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file " 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript.");

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
        
            this.addChild(myTextField);
            this.addChild(countField);
        }
    
            private function clickHandler(e:MouseEvent):void {
                var c:String;
                var index:int;
                
                index = myTextField.getLineOffset(3);
                c = myTextField.text.charAt(index);
                countField.text = "The first character of line 4 is: " + c;
            }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineText"><apiName>getLineText</apiName><shortdesc>
	 返回 lineIndex 参数指定的行的文本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>指定的行号超出范围。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>指定行中包含的文本字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>从零开始的行索引值（例如，第一行的索引值是 0，第二行的索引值是 1，依此类推）。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>指定行中包含的文本字符串。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回 <codeph>lineIndex</codeph> 参数指定的行的文本。
	 
	 </apiDesc><example conref="examples\TextField_getLineTextExample.as"> 在下面的示例中，将查找并显示在莎士比亚的十四行诗中使用“love”一词的所有实例的行号。
 
 <p>我们将 <codeph>poem</codeph> 文本字段设置为自动适应文本并调整为左对齐的文本；并将 <codeph>wordWrap</codeph> 属性设置为 <codeph>false</codeph>，诗歌不会换行（但通常是在使用 <codeph>autoSize</codeph> 属性时），因而不会出现问题。<codeph>for</codeph> 循环使用文本字段的 <codeph>numLines</codeph> 属性循环访问十四行诗中的各行。<codeph>getLineText()</codeph> 方法将行内容作为字符串返回。（请注意，<codeph>numLines</codeph> 属性从第 1 行开始返回行数；而对于 <codeph>getLineText()</codeph> 方法，行号从 0 开始。）通过使用正则表达式模式 (<codeph>/love/i</codeph>)，<codeph>if</codeph> 语句查找词的任何子字符串（大写或小写）。如果找到该模式，<codeph>search</codeph> 方法将返回第一个匹配的子字符串的索引，否则，它返回 <codeph>-1</codeph>（如果不匹配）。然后，将找到“love”一词的行号 (<codeph>(i + 1)</codeph>) 放在字符串 <codeph>lineResult</codeph> 中。只要另一个参数是字符串 (" ")，此字符串方法就会将数字参数 (<codeph>(i + 1)</codeph>) 转换为字符串。搜索的行结果将包含具有“loved”或“Love's”一词的行。如果字符串“Love was found in lines:”是在 <codeph>for</codeph> 循环之前附加的，则也会包括此行中的“Love”一词。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
 
    public class TextField_getLineTextExample extends Sprite {
           
        public function TextField_getLineTextExample() {
           var poem:TextField = new TextField();
           var lineResult:String = ""; 
           var pattern:RegExp = /love/i;

            poem.x = 10;
            poem.y = 10;
            poem.background = true;
            poem.wordWrap = false;
            poem.autoSize = TextFieldAutoSize.LEFT;
            
            poem.text = "Let me not to the marriage of true minds\n"
                              + "Admit impediments. love is not love\n"
                              + "Which alters when it alteration finds\n"
                              + "Or bends with the remover to remove:\n"
                              + "O no! it is an ever-fixed mark\n" 
                              + "That looks on tempests and is never shaken;\n"
                              + "It is the star to every wandering bark,\n"
                              + "Whose worth's unknown, although his height be taken.\n"
                              + "Love's not Time's fool, though rosy lips and cheeks\n"
                              + "Within his bending sickle's compass come:\n"
                              + "Love alters not with his brief hours and weeks,\n"
                              + "But bears it out even to the edge of doom.\n"
                              + "If this be error and upon me proved,\n"
                              + "I never writ, nor no man ever loved.\n\n";

            for (var i:int = 0; i &lt; poem.numLines; i++) {

                var s:String = poem.getLineText(i);
                        
                if(s.search(pattern) != -1) {
                    lineResult += (i + 1) + " ";
                }
            }

            poem.appendText("Love was found in lines: " + lineResult);
             
            this.addChild(poem);                      
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getParagraphLength"><apiName>getParagraphLength</apiName><shortdesc>
	 如果给定一个字符索引，则返回包含给定字符的段落的长度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>指定的字符索引超出范围。
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回段落中的字符数。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>从零开始的字符索引值（例如，第一个字符的索引值是 0，第二个字符的索引值是 1，依此类推）。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>从零开始的字符索引值。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 如果给定一个字符索引，则返回包含给定字符的段落的长度。长度与段落中的第一个字符（由 <codeph>getFirstCharInParagraph()</codeph> 返回）有关，与传入的字符索引无关。
	 
	 </apiDesc><example conref="examples\TextField_getParagraphLengthExample.as"> 在下面的示例中，当用户选择某个段落时，将在单独的文本字段中显示段落长度和段落中的“s”字符数。
 
 <p><codeph>myTextField</codeph> 文本字段显示用户将选择的段落。当用户单击该文本字段时，将分派 <codeph>MouseEvent.CLICK</codeph> 事件并调用 <codeph>clickHandler()</codeph> 方法。段落长度和“s”字符数将显示在 <codeph>countField</codeph> 文本字段中，该字段位于 <codeph>myTextField</codeph> 文本字段下面。</p> 
 
 <p>在 <codeph>clickHandler()</codeph> 方法中，<codeph>getCharIndexAtPoint()</codeph> 方法基于鼠标单击的 <codeph>localX</codeph> 和 <codeph>localY</codeph> 坐标来返回字符的索引。第一条 <codeph>if</codeph> 语句检查以确定用户是否已单击了某个字符。<codeph>getFirstCharInParagraph()</codeph> 方法使用此索引返回相同段落中的第一个字符的索引。可以将 <codeph>getParagraphLength()</codeph> 方法返回的段落长度与段落中第一个字符的索引配合使用来确定段落结尾的索引。<codeph>for</codeph> 循环将循环访问段落以查找“s”字符数。</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;

    public class TextField_getParagraphLengthExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countField:TextField = new TextField();

        public function TextField_getParagraphLengthExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.width = 300;
            myTextField.height = 280;
            
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file" 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                        + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                        + "Target Path dialog box in the Actions panel.\n\n"  
                        + "To create a text field dynamically, use the TextField() constructor.\n\n"
                        + "The methods of the TextField class let you set, select, and manipulate "  
                        + "text in a dynamic or input text field that you create during authoring or at runtime.");

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            countField.x = 10;
            countField.y = 300;
            countField.height = 50;
            countField.width = 250;
            countField.background = true;
            countField.selectable = false;

            this.addChild(myTextField);
            this.addChild(countField);
        }

        private function clickHandler(e:MouseEvent):void {
            var index:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
            
            if(index != -1) {
                var beginParag:int = myTextField.getFirstCharInParagraph(index);
                var paragLength:int = myTextField.getParagraphLength(index);
                var endParag:int = beginParag + paragLength;
                var sCount:uint = 0;

                for (var i:int = beginParag; i &lt;= endParag; i++) {
                    if ((myTextField.text.charAt(i) == "s") || (myTextField.text.charAt(i) == "S")) {
                        sCount++; 
                    }

                countField.text = "Paragraph length is: " + paragLength.toString() + "\n" 
                        + "Number of 's' characters in the paragraph: " + sCount.toString();
                }
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/getFirstCharInParagraph()"><linktext>flash.text.TextField.getFirstCharInParagraph()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getTextFormat"><apiName>getTextFormat</apiName><shortdesc>
	 返回 TextFormat 对象，其中包含 beginIndex 和 endIndex 参数指定的文本范围的格式信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getTextFormat, getTextFormat
	 
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>指定的 <codeph>beginIndex</codeph> 或 <codeph>endIndex</codeph> 超出范围。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>表示指定文本格式设置属性的 TextFormat 对象。
	 
	 </apiDesc><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>可选；一个指定文本字段中某段文本起始位置的整数。
	 
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>可选；一个整数，指定所需文本范围后面的第一个字符的位置。正如所设计的一样，如果指定 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 值，则读取从 <codeph>beginIndex</codeph> 到 <codeph>endIndex-1</codeph> 的文本。 
	 
 	 </apiDesc></apiParam><apiTipTexts><apiTipText>返回一个 TextFormat 对象。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回 TextFormat 对象，其中包含 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 参数指定的文本范围的格式信息。在生成的 TextFormat 对象中，只设置指定的整个文本共有的属性。所有<i>混合</i>型属性（意味着它在文本中的不同位置有不同的值）的值都为 <codeph>null</codeph>。
	 
	 <p>如果没有为这些参数指定值，则此方法适用于文本字段中的所有文本。  </p>
	 
	 <p>下表描述三种可能的用法：</p>
	 
	 <adobetable class="innertable">
	   
	   
	 	 
	   
	 <tgroup cols="2"><thead><row><entry>用法</entry><entry>说明</entry></row></thead><tbody><row>
	     <entry><codeph>my_textField.getTextFormat()</codeph></entry>
	 	   <entry>返回一个 TextFormat 对象，该对象包含文本字段中所有文本的格式设置信息。在结果 TextFormat 对象中只设置文本字段中所有文本共有的属性。所有<i>混合</i>型属性（意味着它在文本中的不同位置有不同的值）的值都为 <codeph>null</codeph>。</entry>
	   </row><row>
	     <entry><codeph>my_textField.getTextFormat(beginIndex:Number)</codeph></entry>
	     <entry>返回一个 TextFormat 对象，其中包含 <codeph>beginIndex</codeph> 位置处字符的文本格式的一个副本。</entry>
	   </row><row>
	     <entry><codeph>my_textField.getTextFormat(beginIndex:Number,endIndex:Number)</codeph></entry>
	     <entry>返回一个 TextFormat 对象，该对象包含从 <codeph>beginIndex</codeph> 到 <codeph>endIndex-1</codeph> 范围内文本的格式设置信息。在结果 TextFormat 对象中只设置特定范围内所有文本共有的属性。所有混合型属性（也就是说，在该范围内的不同位置有不同的值）的值都设置为 <codeph>null</codeph>。</entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc><example>有关如何使用 <codeph>getTextFormat()</codeph> 方法的说明，请参阅 <xref href="TextField.html#getFirstCharInParagraph()">getFirstCharInParagraph()</xref> 或 <xref href="TextField.html#setTextFormat()">setTextFormat()</xref> 方法示例。 
	 </example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:isFontCompatible"><apiName>isFontCompatible</apiName><shortdesc>
	 如果具有指定的 fontName 和 fontStyle（其中的 Font.fontType 为 flash.text.FontType.EMBEDDED）的嵌入字体可用，则将返回 true。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>指定的 <codeph>fontStyle</codeph> 不是 <codeph>flash.text.FontStyle</codeph> 的成员。
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果兼容的嵌入字体可用，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	 
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>fontName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要检查的嵌入字体的名称。
	 </apiDesc></apiParam><apiParam><apiItemName>fontStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>指定要检查的字体样式。使用 <codeph>flash.text.FontStyle</codeph>
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 如果具有指定的 <codeph>fontName</codeph> 和 <codeph>fontStyle</codeph>（其中 <codeph>Font.fontType</codeph> 为 <codeph>flash.text.FontType.EMBEDDED</codeph>）的嵌入字体可用，则将返回 true。从 Flash Player 10 开始，两种嵌入字体可显示在 SWF 文件中。标准的嵌入字体只能与 TextField 对象一起使用。CFF 嵌入字体只能与 flash.text.engine 类一起使用。这两种类型由 <codeph>enumerateFonts()</codeph> 函数返回的 <codeph>Font</codeph> 类的 <codeph>fontType</codeph> 属性加以区分。
	 
	 <p>TextField 不能使用类型为 <codeph>EMBEDDED_CFF</codeph> 的字体。如果 <codeph>embedFonts</codeph> 设置为 <codeph>true</codeph> 并且运行时唯一可用的具有指定名称和样式的字体的类型为 <codeph>EMBEDDED_CFF</codeph>，则 Flash Player 将无法呈现文本，就如同没有任何可用的具有指定名称和样式的嵌入字体。</p>
	 
	 <p>如果具有相同名称和样式的 <codeph>EMBEDDED</codeph> 和 <codeph>EMBEDDED_CFF</codeph> 字体可用，则将选择 <codeph>EMBEDDED</codeph> 字体并使用 <codeph>EMBEDDED</codeph> 字体呈现文本。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link><link href="flash.text.engine.xml#TextBlock/createTextLine"><linktext>flash.text.engine.TextBlock.createTextLine</linktext></link><link href="flash.text.xml#FontType/EMBEDDED_CFF"><linktext>flash.text.FontType.EMBEDDED_CFF</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:replaceSelectedText"><apiName>replaceSelectedText</apiName><shortdesc>
	 使用 value 参数的内容替换当前所选内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.replaceSelectedText, replaceSelectedText
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>此方法不能用于具有样式表的文本字段。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要替换当前所选文本的字符串。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>使用 value 参数的内容替换当前所选内容。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 使用 <codeph>value</codeph> 参数的内容替换当前所选内容。使用当前默认字符格式和默认段落格式，在当前所选内容的所在位置插入文本。不将该文本视为 HTML。
	 
	 <p>可以使用 <codeph>replaceSelectedText()</codeph> 方法插入和删除文本，而不破坏其余文本的字符和段落格式。</p>
     <p><b>注意：</b>如果已对文本字段应用了样式表，则此方法不起作用。</p>
     
	 
	 </apiDesc><example conref="examples\TextField_replaceSelectedTextExample.as"> 在下面的示例中，用户从第一个文本字段中选择某些文本以将其删除，然后将第二个文本字段中的选定文本替换为“NEW TEXT”字符串。
 
 <p>我们创建了两个不同的 TextField 对象，并为 <codeph>MouseEvent.MOUSE_UP</codeph> 事件添加了事件侦听器。当用户松开鼠标时，鼠标将弹起；在选择文本后，通常会发生这种事件。请注意，文本字段的默认设置是选择其文本。</p>
 
 <p>在 <codeph>mouseHandler1()</codeph> 方法中，当用户在 <codeph>myTextField1</codeph> 文本字段中松开鼠标时，将删除该文本并替换为空字符串。此操作可能会继续进行，直至删除所有文本时为止。在 <codeph>mouseHandler2()</codeph> 方法中，当用户在 <codeph>myTextField2</codeph> 文本字段中选择某些文本时，将检查 <codeph>selectionBeginIndex</codeph> 和 <codeph>selectionEndIndex</codeph> 属性以确定是否选择了任何字符。（如果选择了某些文本，<codeph>selectionBeginIndex</codeph> 和 <codeph>selectionEndIndex</codeph> 属性不会具有相同的值。） 然后，将所选文本替换为“NEW TEXT”字符串。此操作可能会继续进行，直至将第二个文本字段的所有原始文本替换为“NEW TEXT”字符串时为止。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;    
    import flash.events.MouseEvent;

    public class TextField_replaceSelectedTextExample extends Sprite {
        private var myTextField1:TextField = new TextField();
        private var myTextField2:TextField = new TextField();
        
        public function TextField_replaceSelectedTextExample() {
            myTextField1.x = 10;
            myTextField1.width = 300;
            myTextField1.height = 50; 
            myTextField1.background = true; 
            myTextField1.border = true;
            myTextField1.text = "Select the text you want to remove from the line.";
            
            myTextField2.x = 10;
            myTextField2.y = 60;
            myTextField2.width = 300;
            myTextField2.height = 50;
            myTextField2.background = true;
            myTextField2.border = true;
            myTextField2.text = "Select the text you want to replace with NEW TEXT.";
            
            myTextField1.addEventListener(MouseEvent.MOUSE_UP, mouseHandler1);
            myTextField2.addEventListener(MouseEvent.MOUSE_UP, mouseHandler2);
            
            this.addChild(myTextField1);
            this.addChild(myTextField2);
        }
        
        private function mouseHandler1(e:MouseEvent):void {
            myTextField1.replaceSelectedText("");
        }

        private function mouseHandler2(e:MouseEvent):void {
            if(myTextField2.selectionBeginIndex != myTextField2.selectionEndIndex) {
                myTextField2.replaceSelectedText("NEW TEXT");    
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:replaceText"><apiName>replaceText</apiName><shortdesc>
	 将 beginIndex 和 endIndex 参数指定的字符范围替换为 newText 参数的内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>此方法不能用于具有样式表的文本字段。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>替换范围开始位置的从零开始的索引值。
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>所需文本范围后面的第一个字符的从零开始的索引位置。
	 </apiDesc></apiParam><apiParam><apiItemName>newText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要用来替换指定范围字符的文本。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>替换某范围内的字符。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 将 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 参数指定的字符范围替换为 <codeph>newText</codeph> 参数的内容。正如所设计的一样，将替换从 <codeph>beginIndex</codeph> 到 <codeph>endIndex-1</codeph> 的文本。  
     <p><b>注意：</b>如果已对文本字段应用了样式表，则此方法不起作用。</p>
     
	 </apiDesc><example conref="examples\TextField_replaceTextExample.as"> 下面的示例使用 <codeph>replaceText()</codeph> 方法在文本字段中删除、替换并插入一些文本。
 
 <p>我们将 <codeph>outputText</codeph> 文本字段设置为自动适应文本并调整为左对齐的文本。通过使用第一个 <codeph>replaceText()</codeph> 方法调用，将第一行（“This is the wrong heading”）替换为“THIS IS THE HEADING FOR EVERYONE”。通过使用第二个方法调用，在“THE”和“HEADING”之间插入文本“CORRECT”。通过使用第三个方法调用，删除词语“FOR EVERYONE”。请注意，执行每个 <codeph>appendText()</codeph> 方法调用时，将更改当前文本的开头和结尾。此处，仅显示了最终文本（进行更改后）。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_replaceTextExample extends Sprite {

        public function TextField_replaceTextExample() {
            var outputText:TextField = new TextField();

            outputText.x = 10;
            outputText.y = 10;
            outputText.background = true;
            outputText.autoSize = TextFieldAutoSize.LEFT;
            
            outputText.appendText("This is the wrong heading");
            outputText.appendText("\n\n"); 
            outputText.appendText("This is the body of the text.");

            outputText.replaceText(0, 25, "THIS IS THE HEADING FOR EVERYONE");

            outputText.replaceText(12, 12, "CORRECT ");
            
            outputText.replaceText(27, 40, "");
            
           this.addChild(outputText);
         }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:setSelection"><apiName>setSelection</apiName><shortdesc>
	 将第一个字符和最后一个字符的索引值（使用 beginIndex 和 endIndex 参数指定）指定的文本设置为所选内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need to add an example.
	 
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>所选内容中第一个字符从零开始的索引值（例如，第一个字符的索引值是 0，第二个字符的索引值是 1，依此类推）。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>所选内容中最后一个字符的从零开始的索引值。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>设置新的文本选择。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 将第一个字符和最后一个字符的索引值（使用 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 参数指定）指定的文本设置为所选内容。如果两个参数值相同，则此方法会设置插入点，就如同设置 <codeph>caretIndex</codeph> 属性一样。
	 
	 </apiDesc><example conref="examples\TextField_setSelectionExample.as"> 在下面的示例中，当用户单击文本字段中的任何位置时，将选择预定义的文本范围（加亮显示词语“TEXT IN ALL CAPS”）。
 
 <p><codeph>myTextField</codeph> 文本字段的两个事件侦听器将响应用户的鼠标单击或鼠标弹起事件。当用户松开鼠标时，鼠标将弹起；在选择文本后，通常会发生这种事件。请注意，文本字段的默认设置是选择其文本。当单击某些文本时，将调用 <codeph>clickHandler()</codeph> 方法。当选择某些文本并松开鼠标时，将调用 <codeph>mouseUpHandler()</codeph> 方法。</p>
 
 <p>在 <codeph>clickHandler()</codeph> 和 <codeph>mouseUpHandler()</codeph> 方法中，<codeph>setSelection()</codeph> 方法设置仅选择索引 54 和 70 之间的字符 (TEXT IN ALL CAPS)。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_setSelectionExample extends Sprite
    {
        private var myTextField:TextField = new TextField();

        public function TextField_setSelectionExample() {
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.text = "No matter where you click on this text field only the TEXT IN ALL CAPS is selected.";

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            myTextField.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);

            this.addChild(myTextField);
        }

        private function clickHandler(event:MouseEvent):void {
            myTextField.setSelection(54, 70);
        }

        private function mouseUpHandler(event:MouseEvent):void {
            myTextField.setSelection(54, 70);
        }

    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:setTextFormat"><apiName>setTextFormat</apiName><shortdesc>
	 将 format 参数指定的文本格式应用于文本字段中的指定文本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.setTextFormat, setTextFormat
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>此方法不能用于具有样式表的文本字段。
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>指定的 <codeph>beginIndex</codeph> 或 <codeph>endIndex</codeph> 超出范围。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier><apiDesc>一个包含字符和段落格式设置信息的 TextFormat 对象。
	 
     </apiDesc></apiParam><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>可选；一个整数，指定所需文本范围内第一个字符的从零开始的索引位置。
	 
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>可选；一个整数，指定所需文本范围后面的第一个字符。正如所设计的一样，如果指定 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 值，则更新从 <codeph>beginIndex</codeph> 到 <codeph>endIndex-1</codeph> 的文本。  
	 
	 <p>
	 <adobetable class="innertable">
	   
	   
	  
	   
	   
	 
	 <tgroup cols="2"><thead><row><entry>用法</entry><entry>说明</entry></row></thead><tbody><row>
	     <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat)</codeph></entry>
	 
	     <entry>将 <codeph>textFormat</codeph> 的属性应用于文本字段中的所有文本。</entry>
	   </row><row>
	 
	 <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat, beginIndex:int)</codeph></entry>
	 
	     <entry>将 <codeph>textFormat</codeph> 的属性应用于从 <codeph>beginIndex</codeph> 处开始的文本。</entry>
	   </row><row>
	     <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat, beginIndex:int, endIndex:int)</codeph></entry>
	 	   <entry>将 <codeph>textFormat</codeph> 参数的属性应用于范围从 <codeph>beginIndex</codeph> 处到 <codeph>endIndex-1</codeph> 处的文本。</entry>
	   </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p>请注意，对于用户手动插入的任何文本或通过 <codeph>replaceSelectedText()</codeph> 方法替换的任何文本，将接收默认的文本格式设置（而非为文本插入点指定的格式设置）以应用于新文本。要为新文本设置文本字段的默认格式设置，请使用 <codeph>defaultTextFormat</codeph> 属性。</p>
	 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>应用文本格式设置。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 将 <codeph>format</codeph> 参数指定的文本格式应用于文本字段中的指定文本。<codeph>format</codeph> 的值必须是指定所需文本格式设置更改的 TextFormat 对象。只有 <codeph>format</codeph> 的非空属性才会应用到文本字段。不会应用 <codeph>format</codeph> 的设置为 <codeph>null</codeph> 的任何属性。默认情况下，新创建的 TextFormat 对象的所有属性都设置为 <codeph>null</codeph>。
     <p><b>注意：</b>如果已对文本字段应用了样式表，则此方法不起作用。</p>
     
	 <p><codeph>setTextFormat()</codeph> 方法会更改应用于文本字段中一定范围的字符或整个文本的文本格式设置。要将 format 的属性应用于文本字段中的所有文本，请不要指定 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 的值。要将 format 的属性应用于一定范围的文本，请指定 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 参数的值。可以使用 <codeph>length</codeph> 属性来确定索引值。</p>
	 
	 <p>TextFormat 对象中包含两种类型的格式设置信息：字符级格式设置和段落级格式设置。文本字段中的每个字符都可以有自己的字符格式设置，例如字体名称、字体大小、粗体和斜体。</p>
	 
	 <p>对于段落，通过检查段落的第一个字符可了解整个段落的格式设置。段落格式设置的示例有左边距、右边距和缩进。</p>
	 
	 <p>对于用户手动插入的任何文本或通过 <codeph>replaceSelectedText()</codeph> 方法替换的任何文本，将接收默认的文本格式设置（而非为文本插入点指定的格式设置）以应用于新文本。要为新文本设置默认格式，请使用 <codeph>defaultTextFormat</codeph>。</p>
	 
	 </apiDesc><example conref="examples\TextField_setTextFormatExample.as"> 在下面的示例中，当单击文本时，所定义范围内的文本（“TEXT IN ALL CAPS”）将在默认文本格式和新格式之间切换格式。
 
 <p>我们为 <codeph>myTextField</codeph> 文本字段添加了一个事件侦听器，以便通过调用 <codeph>clickHandler()</codeph> 方法来响应鼠标单击。在 <codeph>clickHandler()</codeph> 方法中，<codeph>getTextFormat()</codeph> 方法从指定的文本范围中返回字符（索引 55）的当前格式，然后，将其放在 <codeph>currentTextFormat</codeph> TextFormat 对象中。<codeph>if</codeph> 语句检查 <codeph>currentTextFormat</codeph> 文本格式，以确定该范围内的字符是否使用新格式（字体磅值设置为 18）。如果不是，则新格式将在 54-70 范围内的文本 (TEXT IN ALL CAPS) 的大小更改为 18 磅，将颜色更改为红色，并应用下划线和斜体。如果该范围内的字符使用的是新格式，则将该范围的格式重新设置为文本字段的默认（原始）格式。</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;  
    import flash.text.TextFieldAutoSize;  
    import flash.events.MouseEvent;

    public class TextField_setTextFormatExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var newFormat:TextFormat = new TextFormat();
        
        public function TextField_setTextFormatExample() {
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.selectable = false;
            myTextField.background = true;
            myTextField.text = "No matter where you click on this text field only the TEXT IN ALL CAPS changes format.";

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            newFormat.color = 0xFF0000;
            newFormat.size = 18;
            newFormat.underline = true;
            newFormat.italic = true;
                
            this.addChild(myTextField);
        }

        private function clickHandler(event:MouseEvent):void {
            var currentTextFormat:TextFormat = myTextField.getTextFormat(55);
            
            if(currentTextFormat.size != 18) {
                myTextField.setTextFormat(newFormat, 54, 70);
            }
            else {
                myTextField.setTextFormat(myTextField.defaultTextFormat);
            }    
        }    
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextField:alwaysShowSelection:get"><apiName>alwaysShowSelection</apiName><shortdesc>
	如果设置为 true 且文本字段没有焦点，Flash Player 将以灰色突出显示文本字段中的所选内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField object, built-in class
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
    
	</apiDefaultValue></apiValueDef><apiDesc>
	如果设置为 <codeph>true</codeph> 且文本字段没有焦点，Flash Player 将以灰色突出显示文本字段中的所选内容。如果设置为 <codeph>false</codeph> 且文本字段没有焦点，则 Flash Player 不会突出显示文本字段中的所选内容。
	
    </apiDesc><example conref="examples\TextField_alwaysShowSelection.as"> 编译并运行下面的文件。在运行此文件时，拖动以分别选择两个文本字段中的文本，注意在您选择两个文本字段中的文本（更改焦点）时，突出显示的所选内容之间的区别：
<codeblock>

    package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_alwaysShowSelection extends Sprite {
        public function TextField_alwaysShowSelection() {
            var label1:TextField = createCustomTextField(0, 20, 200, 20);
            label1.text = "This text is selected.";
            label1.setSelection(0, 9);
            label1.alwaysShowSelection = true;

            var label2:TextField = createCustomTextField(0, 50, 200, 20);
            label2.text = "Drag to select some of this text.";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x; result.y = y;
            result.width = width; result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:antiAliasType:get"><apiName>antiAliasType</apiName><shortdesc>
	 用于此文本字段的消除锯齿类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>This example creates two text fields and applies advanced anti-aliasing to the first one
	 only.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 300, 30);
	 my_text1.text = "This text uses advanced anti-aliasing.";
	 my_text1.antiAliasType = "advanced";
	 my_text1.border = true;
	 my_text1.embedFonts = true;
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 50, 300, 30);
	 my_text2.text = "This text uses normal anti-aliasing."
	 my_text2.antiAliasType = "normal";
	 my_text2.border = true;
	 my_text2.embedFonts = true;
	 my_text2.setTextFormat(my_format);
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>使用的消除锯齿类型。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 用于此文本字段的消除锯齿类型。将 <codeph>flash.text.AntiAliasType</codeph> 常数用于此属性。仅在字体为嵌入（即 <codeph>embedFonts</codeph> 属性设置为 <codeph>true</codeph>）时可以控制此设置。默认设置为 <codeph>flash.text.AntiAliasType.NORMAL</codeph>。
	 
	 <p>要设置此属性的值，请使用下列字符串值：</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>字符串值</entry><entry>说明</entry></row></thead><tbody><row>
	 	<entry><codeph>flash.text.AntiAliasType.NORMAL</codeph></entry>
	 	<entry>应用常规文本消除锯齿功能。此值与 Flash Player 7 和早期版本中使用的消除锯齿的类型匹配。</entry>
	   </row><row>
	   	<entry><codeph>flash.text.AntiAliasType.ADVANCED</codeph></entry>
	 	<entry>应用高级消除锯齿功能，这增加了文本的可读性。（此功能在 Flash Player 8 中可用。）高级消除锯齿功能可以高品质呈现小尺寸的字体。它最适合在具有大量小字号文本的应用程序中使用。建议不要对大于 48 磅的字体使用高级消除锯齿功能。</entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link><link href="flash.text.xml#TextField/embedFonts"><linktext>flash.text.TextField.embedFonts</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:autoSize:get"><apiName>autoSize</apiName><shortdesc>
	 控制文本字段的自动大小调整和对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.autoSize, autoSize
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>指定的 <codeph>autoSize</codeph> 不是 flash.text.TextFieldAutoSize 的成员。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>控制文本字段的自动大小调整和对齐。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 控制文本字段的自动大小调整和对齐。<codeph>TextFieldAutoSize</codeph> 常数的可接受值为 <codeph>TextFieldAutoSize.NONE</codeph>（默认值）、<codeph>TextFieldAutoSize.LEFT</codeph>、<codeph>TextFieldAutoSize.RIGHT</codeph> 和 <codeph>TextFieldAutoSize.CENTER</codeph>。
	 
	 <p>如果 <codeph>autoSize</codeph> 设置为 <codeph>TextFieldAutoSize.NONE</codeph>（默认值），则不会进行调整。</p>
	 
	 <p>如果 <codeph>autoSize</codeph> 设置为 <codeph>TextFieldAutoSize.LEFT</codeph>，会将文本视为左对齐文本，这意味着该文本字段的左边距保持固定，在右边可调整单个文本字段行。如果文本中包括换行符（例如 <codeph>"\n"</codeph> 或 <codeph>"\r"</codeph>），则会另外调整底边来适合文本的下一行。如果 <codeph>wordWrap</codeph> 也设置为 <codeph>true</codeph>，则仅调整文本字段的底边，而右边距保持固定。</p>
	 
	 <p>如果 <codeph>autoSize</codeph> 设置为 <codeph>TextFieldAutoSize.RIGHT</codeph>，会将文本视为右对齐文本，这意味着该文本字段的右边距保持固定，可在左边调整单个文本字段行。如果文本中包括换行符（例如 <codeph>"\n" or "\r")</codeph>），则会另外调整底边来适合文本的下一行。如果 <codeph>wordWrap</codeph> 也设置为 <codeph>true</codeph>，则仅调整文本字段的底边，而左边距保持固定。</p>
	 
	 <p>如果 <codeph>autoSize</codeph> 设置为 <codeph>TextFieldAutoSize.CENTER</codeph>，会将文本视为居中对齐文本，这意味着对单个文本字段行的调整将使其在左右边距间均衡分布。如果文本中包括换行符（例如 <codeph>"\n"</codeph> 或 <codeph>"\r"</codeph>），则会另外调整底边来适合文本的下一行。如果 <codeph>wordWrap</codeph> 也设置为 <codeph>true</codeph>，则仅调整文本字段的底边，而左右边距保持固定。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFieldAutoSize"><linktext>flash.text.TextFieldAutoSize</linktext></link><link href="flash.text.xml#TextField/autoSize"><linktext>flash.text.TextField.autoSize</linktext></link><link href="flash.text.xml#TextField/wordWrap"><linktext>flash.text.TextField.wordWrap</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:background:get"><apiName>background</apiName><shortdesc>
	 指定文本字段是否具有背景填充。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.background, background
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue></apiValueDef><apiDesc>
	 指定文本字段是否具有背景填充。如果为 <codeph>true</codeph>，则文本字段具有背景填充。如果为 <codeph>false</codeph>，则文本字段没有背景填充。使用 <codeph>backgroundColor</codeph> 属性来设置文本字段的背景颜色。
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/backgroundColor"><linktext>flash.text.TextField.backgroundColor</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:backgroundColor:get"><apiName>backgroundColor</apiName><shortdesc>
	 文本字段背景的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.backgroundColor, backgroundColor, background Color
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 文本字段背景的颜色。默认值为 <codeph>0xFFFFFF</codeph>（白色）。即使当前没有背景，也可检索或设置此属性，但只有当文本字段已将 <codeph>background</codeph> 属性设置为 <codeph>true</codeph> 时，才可以看到颜色。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/background"><linktext>flash.text.TextField.background</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:border:get"><apiName>border</apiName><shortdesc>
	 指定文本字段是否具有边框。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.border, border
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue></apiValueDef><apiDesc>
	 指定文本字段是否具有边框。如果为 <codeph>true</codeph>，则文本字段具有边框。如果为 <codeph>false</codeph>，则文本字段没有边框。使用 <codeph>borderColor</codeph> 属性来设置边框颜色。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/borderColor"><linktext>flash.text.TextField.borderColor</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:borderColor:get"><apiName>borderColor</apiName><shortdesc>
	 文本字段边框的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.borderColor, borderColor
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 文本字段边框的颜色。默认值为 <codeph>0x000000</codeph>（黑色）。即使当前没有边框，也可检索或设置此属性，但只有当文本字段已将 <codeph>border</codeph> 属性设置为 <codeph>true</codeph> 时，才可以看到颜色。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/border"><linktext>flash.text.TextField.border</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:bottomScrollV:get"><apiName>bottomScrollV</apiName><shortdesc>
	 一个整数（从 1 开始的索引），指示指定文本字段中当前可以看到的最后一行。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.bottomScrollV, bottomScrollV
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>一个整数，指示文本字段中的最后一行。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 一个整数（从 1 开始的索引），指示指定文本字段中当前可以看到的最后一行。可将文本字段看作文本块上的一个窗口。<codeph>scrollV</codeph> 属性是此窗口中最顶端可见行的从 1 开始的索引。
	 
	 <p>当前可以看到文本字段中 <codeph>scrollV</codeph> 和 <codeph>bottomScrollV</codeph> 指示的行之间的所有文本。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:caretIndex:get"><apiName>caretIndex</apiName><shortdesc>
	 插入点（尖号）位置的索引。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>返回闪烁插入点的从零开始的索引值。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 插入点（尖号）位置的索引。如果没有显示任何插入点，则在将焦点恢复到字段时，值将为插入点所在的位置（通常为插入点上次所在的位置，如果字段不曾具有焦点，则为 0）。
	 
	 <p>选择范围索引是从零开始的（例如，第一个位置为 0、第二个位置为 1，依此类推）。</p>
	 
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> 在此示例中，创建了一个 TextField 实例，并用文本填充该实例。分配了一个事件侦听器，以便在用户单击 TextField 时，调用 <codeph>printCursorPosition</codeph> 方法。在这种情况下，将输出 <codeph>caretIndex</codeph>、<codeph>selectionBeginIndex</codeph> 和 <codeph>selectionEndIndex</codeph> 属性的值。
 
 <p>运行此示例并尝试在 TextField 中单击以选择文本。然后在字段中单击，但不选择文本。如果在文本中单击但不进行选择，<codeph>caretIndex</codeph> 属性将指示在何处出现插入点，而 <codeph>selectionBeginIndex</codeph> 和 <codeph>selectionEndIndex</codeph> 属性则等于 <codeph>caretIndex</codeph> 属性值。</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:condenseWhite:get"><apiName>condenseWhite</apiName><shortdesc>
	 一个布尔值，指定是否删除具有 HTML 文本的文本字段中的额外空白（空格、换行符等等）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>textfield, text, HTML
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>一个布尔值，指定是否删除具有 HTML 文本的文本字段中的额外空白。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 一个布尔值，指定是否删除具有 HTML 文本的文本字段中的额外空白（空格、换行符等等）。默认值为 <codeph>false</codeph>。<codeph>condenseWhite</codeph> 属性只影响使用 <codeph>htmlText</codeph> 属性（而非 <codeph>text</codeph> 属性）设置的文本。如果使用 <codeph>text</codeph> 属性设置文本，则忽略 <codeph>condenseWhite</codeph>。
	 
	 <p>如果 <codeph>condenseWhite</codeph> 设置为 <codeph>true</codeph>，请使用标准 HTML 命令（如 <codeph>&lt;BR></codeph> 和 <codeph>&lt;P></codeph>），将换行符放在文本字段中。</p>
	 
	 <p>在设置 <codeph>htmlText</codeph> 属性之前设置 <codeph>condenseWhite</codeph> 属性。</p>
	 
	 
	 </apiDesc><example conref="examples\TextField_condenseWhite.as"> 下面显示将 <codeph>condenseWhite</codeph> 设置为 <codeph>false</codeph> 和将其设置为 <codeph>true</codeph> 之间的区别：
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_condenseWhite extends Sprite {
        public function TextField_condenseWhite() {
            var tf1:TextField = createCustomTextField(0, 0, 200, 50);
            tf1.condenseWhite = false;
            tf1.htmlText = "keep    on\n\ttruckin'";
            
            var tf2:TextField = createCustomTextField(0, 120, 200, 50);
            tf2.condenseWhite = true;
            tf2.htmlText = "keep    on\n\ttruckin'";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:defaultTextFormat:get"><apiName>defaultTextFormat</apiName><shortdesc>
	 指定应用于新插入文本（例如，用户输入的文本或使用 replaceSelectedText() 方法插入的文本）的格式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.defaultTextFormat, defaultTextFormat
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.text:TextFormat</apiValueClassifier><apiException><apiDesc>此方法不能用于具有样式表的文本字段。
	  
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>为新插入的文本指定文本格式。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指定应用于新插入文本（例如，用户输入的文本或使用 <codeph>replaceSelectedText()</codeph> 方法插入的文本）的格式。
	 
	 <p><b>注意：</b>当选择要替换为 <codeph>setSelection()</codeph> 和 <codeph>replaceSelectedText()</codeph> 的字符时，仅在选择的文本达到和包括最后字符时才会应用 <codeph>defaultTextFormat</codeph>。下面是一个示例：</p>
	 <pre>
	 var my_txt:TextField new TextField();
	 my_txt.text = "Flash Macintosh version";
	 var my_fmt:TextFormat = new TextFormat();
	 my_fmt.color = 0xFF0000;
	 my_txt.defaultTextFormat = my_fmt;
	 my_txt.setSelection(6,15); // partial text selected - defaultTextFormat not applied
	 my_txt.setSelection(6,23); // text selected to end - defaultTextFormat applied
	 my_txt.replaceSelectedText("Windows version");
	 </pre>
	 
	 <p>在访问 <codeph>defaultTextFormat</codeph> 属性时，返回的 TextFormat 对象已定义了它的所有属性。所有属性都不为 <codeph>null</codeph>。</p>
     <p><b>注意：</b>如果对文本字段应用了样式表，则不能设置该属性。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/replaceSelectedText()"><linktext>flash.text.TextField.replaceSelectedText()</linktext></link><link href="flash.text.xml#TextField/getTextFormat()"><linktext>flash.text.TextField.getTextFormat()</linktext></link><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:displayAsPassword:get"><apiName>displayAsPassword</apiName><shortdesc>
	 指定文本字段是否是密码文本字段。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.password, password
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>指定是否隐藏输入字符。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指定文本字段是否是密码文本字段。如果此属性的值为 <codeph>true</codeph>，则文本字段被视为密码文本字段，并使用星号而不是实际字符来隐藏输入的字符。如果为 <codeph>false</codeph>，则不会将文本字段视为密码文本字段。启用密码模式时，“剪切”和“复制”命令及其对应的键盘快捷键将不起作用。此安全机制可防止不良用户使用快捷键在无人看管的计算机上破译密码。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:embedFonts:get"><apiName>embedFonts</apiName><shortdesc>
	 指定是否使用嵌入字体轮廓进行呈现。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.embedFonts, embedFonts
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>呈现使用字体轮廓或设备字体的文本字段。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指定是否使用嵌入字体轮廓进行呈现。如果为 <codeph>false</codeph>，则 Flash Player 使用设备字体呈现文本字段。
	 
	 <p>如果将文本字段的 <codeph>embedFonts</codeph> 属性设置为 <codeph>true</codeph>，则必须使用应用于该文本字段的 TextFormat 对象的 <codeph>font</codeph> 属性来指定该文本的字体。如果指定的字体没有嵌入 SWF 文件中，则不会显示该文本。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#Font/enumerateFonts()"><linktext>Font.enumerateFonts()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:gridFitType:get"><apiName>gridFitType</apiName><shortdesc>
	 用于此文本字段的网格固定类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example shows three text fields that use the
	 different <code>flash.text.GridFitType</code> settings.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 9.5, 10, 400, 100);
	 my_text1.text = "this.gridFitType = none";
	 my_text1.embedFonts = true;
	 my_text1.antiAliasType = "advanced";
	 my_text1.gridFitType = "none";
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 9.5, 40, 400, 100);
	 my_text2.text = "this.gridFitType = advanced";
	 my_text2.embedFonts = true;
	 my_text2.antiAliasType = "advanced";
	 my_text2.gridFitType = "pixel";
	 my_text2.setTextFormat(my_format);
	 
	 var my_text3:TextField = this.createTextField("my_text3", this.getNextHighestDepth(), 9.5, 70, 400, 100);
	 my_text3.text = "this.gridFitType = subpixel";
	 my_text3.embedFonts = true;
	 my_text3.antiAliasType = "advanced";
	 my_text3.gridFitType = "subpixel";
	 my_text3.setTextFormat(my_format);
	 </listing>
	 
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>pixel
     
	 </apiDefaultValue><apiTipTexts><apiTipText>使用的网格固定类型。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 用于此文本字段的网格固定类型。仅在文本字段的 <codeph>flash.text.AntiAliasType</codeph> 属性设置为 <codeph>flash.text.AntiAliasType.ADVANCED</codeph> 时才应用此属性。
	 
	 <p>使用的网格固定类型确定了 Flash Player 是否强制让粗水平线和垂直线适合像素网格或子像素网格。</p>
	 
	 <p>对于 <codeph>flash.text.GridFitType</codeph> 属性，您可以使用下列字符串值：</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>字符串值</entry><entry>说明</entry></row></thead><tbody><row>
	     <entry><codeph>flash.text.GridFitType.NONE</codeph></entry>
	     <entry>指定无网格固定。不强制根据像素网格调整字型中的水平线和垂直线。建议对动画或大号字使用此设置。</entry>
	   </row><row>
	     <entry><codeph>flash.text.GridFitType.PIXEL</codeph></entry>
	     <entry>指定粗水平线和垂直线适合像素网格。此设置仅适用于左对齐文本字段。要使用此设置，文本字段的 <codeph>flash.dispaly.AntiAliasType</codeph> 属性必须设置为 <codeph>flash.text.AntiAliasType.ADVANCED</codeph>。此设置通常能为左对齐文本提供最佳可读性。</entry>
	   </row><row>
	     <entry><codeph>flash.text.GridFitType.SUBPIXEL</codeph></entry>
	     <entry>指定粗水平线和垂直线适合 LCD 显示器上的子像素网格。要使用此设置，文本字段的 <codeph>flash.text.AntiAliasType</codeph> 属性必须设置为 <codeph>flash.text.AntiAliasType.ADVANCED</codeph>。<codeph>flash.text.GridFitType.SUBPIXEL</codeph> 设置通常适合右对齐或居中的动态文本，有时，为了在动画与文本品质之间达到一种平衡，也可使用此设置。</entry>
	   </row></tbody></tgroup></adobetable>
	 
     </apiDesc><example conref="examples\TextField_gridFitType.as"> 下面的示例显示具有不同 <codeph>gridFitType</codeph> 属性设置的三个文本字段。在使用此示例时，请注意前两行在清晰度方面的差异。还要注意用于左对齐文本的 <codeph>GridFitType.PIXEL</codeph> 和用于右对齐文本的 <codeph>GridFitType.SUBPIXEL</codeph> 的最佳用法。
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;

    public class gridFitTypeExample extends Sprite
    {
        public function gridFitTypeExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=12;

    var tf1:TextField = createCustomTextField(0,0,format1,"NONE",TextFieldAutoSize.LEFT,GridFitType.NONE);
    
    var tf2:TextField = createCustomTextField(0,30,format1,"PIXEL",TextFieldAutoSize.LEFT,GridFitType.PIXEL);

    var tf3:TextField = createCustomTextField(300,60,format1,"SUBPIXEL",TextFieldAutoSize.RIGHT,GridFitType.SUBPIXEL);

        }
        private function createCustomTextField(x:Number,y:Number,fm:TextFormat,tl:String,tfs:String,gft:String):TextField 
        {
            var result:TextField = new TextField();
            result.x=x;
            result.y=y;
            result.embedFonts=true;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.text="This text uses a gridFitType of " + tl;
            result.autoSize=tfs;
        result.gridFitType=gft;
            result.setTextFormat(fm);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#GridFitType"><linktext>flash.text.GridFitType</linktext></link><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:htmlText:get"><apiName>htmlText</apiName><shortdesc>
	 包含文本字段内容的 HTML 表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.htmlText, htmlText
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>文本字段内容的 HTML 表示形式。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 包含文本字段内容的 HTML 表示形式。 
	 
	 <p>Flash Player 支持以下 HTML 标签：</p>
	 
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>
	 标签
	 </entry><entry>
	 说明
	 </entry></row></thead><tbody><row>
	 
	 <entry>
	 锚标签
	 </entry>
	 
	 <entry>
	 <codeph>&lt;a></codeph> 标签创建超文本链接并支持以下属性：
	 <ul>
	 
	 <li>
	 <codeph>target</codeph>：指定加载页面的目标窗口的名称。选项包括 <codeph>_self</codeph>、<codeph>_blank</codeph>、<codeph>_parent</codeph> 和 <codeph>_top</codeph>。<codeph>_self</codeph> 选项指定当前窗口中的当前帧，<codeph>_blank</codeph> 指定一个新窗口，<codeph>_parent</codeph> 指定当前帧的父级，而 <codeph>_top</codeph> 指定当前窗口中的顶级帧。 
	 </li>
	 
	 <li>
	 <codeph>href</codeph>：指定 URL 或 ActionScript <codeph>link</codeph> 事件。URL 可以是绝对路径或相对路径（相对于加载页的 SWF 文件的位置）。<codeph>http://www.adobe.com</codeph> 示例表示对 URL 的绝对引用；<codeph>/index.html</codeph> 示例表示相对引用。绝对 URL 必须以 http:// 为前缀，否则 Flash Player 或 AIR 会将其视为相对 URL。可以使用 <codeph>link</codeph> 事件使链接执行 SWF 文件中的 ActionScript 函数，而不是打开 URL。要指定 <codeph>link</codeph> 事件，请在 <codeph>href</codeph> 属性中使用 event 方案，而不是 http 方案。例如，使用 <codeph>href="event:myText"</codeph> 而不是 <codeph>href="http://myURL"</codeph>；当用户单击包含 event 方案的超文本链接时，文本字段将分派 <codeph>link</codeph> TextEvent，并将其 <codeph>text</codeph> 属性设置为“<codeph>myText</codeph>”。可随后创建一个 ActionScript 函数，每次分派 link TextEvent 时都会执行该函数。还可以使用样式表为锚标签定义 <codeph>a:link</codeph>、<codeph>a:hover</codeph> 和 <codeph>a:active</codeph> 样式。
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 粗体标签
	 </entry>
	 
	 <entry>
	 <codeph>&lt;b></codeph> 标签以粗体形式呈现文本。粗体必须可用于所使用的字体。
	 </entry>
	 </row><row>
	 
	 <entry>
	 换行标签
	 </entry>
	 <entry>
	 <codeph>&lt;br></codeph> 标签将在文本字段中创建一个换行符。将文本字段设置为多行文本字段以使用此标签。
	 </entry>
	 </row><row>
	 
	 <entry>
	 字体标签
	 </entry>
	 
	 <entry>
	 <codeph>&lt;font></codeph> 标签指定一种字体或一个字体列表来显示文本。字体标签支持以下属性：
	 <ul>
	 
	 <li>
	 <codeph>color</codeph>：只支持十六进制颜色 (<codeph>#FFFFFF</codeph>) 值。 
	 </li>
	 
	 <li>
	 <codeph>face</codeph>：指定要使用的字体的名称。如下例所示，您可以指定一个以逗号分隔的字体名称的列表，在这种情况下，Flash Player 选择第一个可用字体。如果本地计算机系统上未安装指定的字体，或 SWF 文件中未嵌入指定的字体，则 Flash Player 将选择替代字体。 
	 </li>
	 
	 <li>
	 <codeph>size</codeph>：指定字体的大小。您可以使用绝对像素大小（如 16 或 18），也可以使用相对磅值（如 +2 或 -4）。 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 图像标签
	 </entry>
	 
	 <entry>
	 使用 <codeph>&lt;img></codeph> 标签可将外部图像文件（JPEG、GIF、PNG）、SWF 文件和影片剪辑嵌入到文本字段中。在文本字段中，文本在嵌入的图像旁自动换行。您必须将文本字段设置为多行才能在图像周围绕排文本。 
	 
	  <p><codeph>&lt;img></codeph> 标签支持以下属性： </p>
	 
	 <ul>
	 
	 <li>
	 <codeph>src</codeph>：指定图像或 SWF 文件的 URL，或库中影片剪辑元件的链接标识符。此属性是必需的，所有其它属性都是可选的。外部文件（JPEG、GIF、PNG 和 SWF 文件）只有在完全下载之后才能显示。 
	 </li>
	 
	 <li>
	 <codeph>width</codeph>：所插入的图像、SWF 文件或影片剪辑的宽度（以像素为单位）。 
	 </li>
	 
	 <li>
	 <codeph>height</codeph>：所插入的图像、SWF 文件或影片剪辑的高度（以像素为单位）。 
	 </li>
	 
	 <li>
	 <codeph>align</codeph>：指定文本字段中嵌入图像的水平对齐方式。有效值为 <codeph>left</codeph> 和 <codeph>right</codeph>。默认值为 <codeph>left</codeph>。 
	 </li>
	 
	 <li>
	 <codeph>hspace</codeph>：指定图像周围不显示任何文本的水平空间量。默认值为 8。 
	 </li>
	 
	 <li>
	 <codeph>vspace</codeph>：指定图像周围不显示任何文本的垂直空间量。默认值为 8。  
	 </li>
	 
	 <li>
	 <codeph>id</codeph>：指定包含嵌入的图像文件、SWF 文件或影片剪辑的影片剪辑实例（由 Flash Player 创建）的名称。此方法可用于使用 ActionScript 控制嵌入的内容。 
	 </li>
	 
	 <li>
	 <codeph>checkPolicyFile</codeph>：指定 Flash Player 将在与图像域相关的服务器上查找 URL 策略文件。如果存在策略文件，则此文件中列出的域中的 SWF 文件可以访问所加载的图像的数据，例如，通过使用此图像作为 <codeph>source</codeph> 参数来调用 <codeph>BitmapData.draw()</codeph> 方法。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“Flash Player 安全性”一章。
	 </li>
	 
	 </ul>
	  <p>Flash 以完全大小显示文本字段中嵌入的媒体。要指定嵌入的媒体的尺寸，请使用 <codeph>&lt;img></codeph> 标签的 <codeph>height</codeph> 和 <codeph>width</codeph> 属性。 </p>
	 
	  <p>通常情况下，文本字段中嵌入的图像显示在 <codeph>&lt;img></codeph> 标签后的行上。但是，如果 <codeph>&lt;img></codeph> 标签是文本字段中的第一个字符，则该图像显示在文本字段的第一行上。 </p>
	 
	 <p>对于应用程序安全沙箱中的 AIR 内容，AIR 会忽略 ActionScript TextField 对象的 HTML 内容中的 <codeph>img</codeph> 标签。这是为了防止可能发生的仿冒攻击，</p>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 斜体标签
	 </entry>
	 
	 <entry>
	 <codeph>&lt;i></codeph> 标签以斜体形式显示标签中的文本。斜体必须可用于所使用的字体。
	 </entry>
	 </row><row>
	 
	 <entry>
	 列表项标签
	 </entry>
	 
	 <entry>
	 <codeph>&lt;li></codeph> 标签在所包含的文本前放置项目符号。<b>注意：</b>因为 Flash Player 和 AIR 无法识别有序和无序列表标签（<codeph>&lt;ol></codeph> 和 <codeph>&lt;ul></codeph>），所以这些标签无法修改列表的呈现方式。所有列表都是无序的，所有列表项都使用项目符号。
	 </entry>
	 </row><row>
	 
	 <entry>
	 段落标签
	 </entry>
	 
	 <entry>
	 <codeph>&lt;p></codeph> 标签创建一个新段落。必须将文本字段设置为多行文本字段才能使用此标签。<codeph>&lt;p></codeph> 标签支持以下属性：
	 <ul>
	 
	 <li>
	 align：指定段落内文本的对齐方式；有效值为 <codeph>left</codeph>、<codeph>right</codeph>、<codeph>justify</codeph> 和 <codeph>center</codeph>。 
	 </li>
	 
	 <li>
	 class：指定 flash.text.StyleSheet 对象定义的 CSS 样式类。 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Span 标签
	 </entry>
	 
	 <entry>
	 
	 <codeph>&lt;span></codeph> 标签只可用于 CSS 文本样式。它支持以下属性：
	 
	 <ul>
	 
	 <li>
	 class：指定 flash.text.StyleSheet 对象定义的 CSS 样式类。 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 文本格式标签
	 </entry>
	 
	 <entry>
	  <p>使用 <codeph>&lt;textformat></codeph> 标签可在文本字段中使用 TextFormat 类的段落格式设置属性的子集，其中包括行距、缩进、边距和 Tab 停靠位。您可以将 <codeph>&lt;textformat></codeph> 标签与内置 HTML 标签结合使用。 </p>
	 
	  <p><codeph>&lt;textformat></codeph> 标签具有以下属性： </p>
	 <ul>
	 
	 <li>
	 <codeph>blockindent</codeph>：指定块缩进（以磅为单位）；对应于 <codeph>TextFormat.blockIndent</codeph>。 
	 </li>
	 
	 <li>
	 <codeph>indent</codeph>：指定从左边距到段落中第一个字符的缩进；对应于 <codeph>TextFormat.indent</codeph>。正数和负数均可以接受。 
	 </li>
	 
	 <li>
	 <codeph>leading</codeph>：指定行与行之间的前导量（垂直间距）；对应于 <codeph>TextFormat.leading</codeph>。正数和负数均可以接受。 
	 </li>
	 
	 <li>
	 <codeph>leftmargin</codeph>：指定段落的左边距（以磅为单位）；对应于 <codeph>TextFormat.leftMargin</codeph>。 
	 </li>
	 
	 <li>
	 <codeph>rightmargin</codeph>：指定段落的右边距（以磅为单位）；对应于 <codeph>TextFormat.rightMargin</codeph>。 
	 </li>
	 
	 <li>
	 <codeph>tabstops</codeph>：将自定义 Tab 停靠位指定为一个非负整数的数组；对应于 <codeph>TextFormat.tabStops</codeph>。 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 下划线标签
	 </entry>
	 
	 <entry>
	 <codeph>&lt;u></codeph> 标签为标签文本添加下划线。
	 </entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Flash Player 和 AIR 支持以下 HTML 实体：</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>
	 实体
	 </entry><entry>
	 说明
	 </entry></row></thead><tbody><row>
	 
	 <entry>
	 
	 &amp;amp;lt;	
	 
	 </entry>
	 
	 <entry>
	 
	 &lt; (小于)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;gt;	
	 
	 </entry>
	 
	 <entry>
	 
	 > (大于)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;amp;	
	 
	 </entry>
	 
	 <entry>
	 
	 &amp;（和）
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 &amp;amp;quot;	
	 
	 </entry>
	 
	 <entry>
	 
	 "（双引号）
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;apos;	
	 
	 </entry>
	 
	 <entry>
	 
	 '（撇号，单引号）
	 
	 </entry>
	 
	 </row></tbody></tgroup></adobetable>
	  
	  <p>Flash Player 和 AIR 还支持显式字符代码，如 &amp;#38;（ASCII 和号）和 &amp;#x20AC;（Unicode € 符号）。 </p>
	 
	 </apiDesc><example conref="examples\TextField_text.as"> 下例创建一个名为 <codeph>tf1</codeph> 的 TextField，并将 HTML 格式的字符串赋给其 <codeph>text</codeph> 属性。当跟踪其 <codeph>htmlText</codeph> 属性时，输出为 HTML 格式的字符串，带有由 Flash Player 自动添加的其它标签（如 &lt;P> 和 &lt;FONT>）。当跟踪 <codeph>text</codeph> 属性的值时，将显示不带 HTML 标签的无格式字符串。
 
 <p>为了进行比较，我们对另一个名为 <codeph>tf2</codeph> 的 TextField 对象执行了同样的步骤，并在设置 <codeph>tf2</codeph> 的 <codeph>htmlText</codeph> 属性之前将 StyleSheet 对象赋给它的 <codeph>styleSheet</codeph> 属性。在这种情况下，当跟踪 <codeph>htmlText</codeph> 属性时，它只包括最初赋给 <codeph>htmlText</codeph> 属性的 HTML 文本，说明 Flash Player 没有添加其它标签。</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;

    public class TextField_text extends Sprite {
        public function TextField_text() {
            var tf1:TextField = createCustomTextField(10, 10, 400, 22);
            tf1.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";

            // htmlText: &lt;P ALIGN="LEFT">&lt;FONT FACE="Times New Roman" SIZE="12" COLOR="#000000" LETTERSPACING="0" KERNING="0">&amp;lt;b&amp;gt;Lorem ipsum dolor sit amet.&amp;lt;/b&amp;gt;&lt;/FONT>&lt;/P>
            trace("htmlText: " + tf1.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf1.text);
            
            var tf2:TextField = createCustomTextField(10, 50, 400, 22);
            tf2.styleSheet = new StyleSheet();
            tf2.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";
            // htmlText: &lt;b>Lorem ipsum dolor sit amet.&lt;/b>
            trace("htmlText: " + tf2.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf2.text);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/text"><linktext>flash.text.TextField.text</linktext></link><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link><link href="flash.events.xml#TextEvent"><linktext>flash.events.TextEvent</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:length:get"><apiName>length</apiName><shortdesc>
	 文本字段中的字符数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.length, length
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>文本字段中的字符数。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 文本字段中的字符数。如 tab (<codeph>\t</codeph>) 之类的字符视为一个字符。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:maxChars:get"><apiName>maxChars</apiName><shortdesc>
	 文本字段中最多可包含的字符数（即用户输入的字符数）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxChars, maxChars
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
	 
	 </apiDefaultValue><apiTipTexts><apiTipText>文本字段可以包含的最多字符数。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 文本字段中最多可包含的字符数（即用户输入的字符数）。脚本可以插入比 <codeph>maxChars</codeph> 允许的字符数更多的文本；<codeph>maxChars</codeph> 属性仅指示用户可以输入多少文本。如果此属性的值为 <codeph>0</codeph>，则用户可以输入无限数量的文本。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:maxScrollH:get"><apiName>maxScrollH</apiName><shortdesc>
	 scrollH 的最大值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxScrollH, maxScrollH
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>scrollH 的最大值。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 <codeph>scrollH</codeph> 的最大值。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollH"><linktext>flash.text.TextField.scrollH</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:maxScrollV:get"><apiName>maxScrollV</apiName><shortdesc>
	 scrollV 的最大值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxScrollV, maxScrollV
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText><codeph>scrollV</codeph> 的最大值。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 <codeph>scrollV</codeph> 的最大值。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:mouseWheelEnabled:get"><apiName>mouseWheelEnabled</apiName><shortdesc>
	 一个布尔值，指示当用户单击某个文本字段并滚动鼠标滚轮时，Flash Player 是否自动滚动多行文本字段。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.mouseWheelEnabled, mouseWheelEnabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>指示 Flash Player 是否自动滚动多行文本字段。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 一个布尔值，指示当用户单击某个文本字段并滚动鼠标滚轮时，Flash Player 是否自动滚动多行文本字段。默认情况下，此值为 <codeph>true</codeph>。如果您想让文本字段在用户滚动鼠标滚轮时不随之滚动，或要实现您自己的文本字段滚动方式，可以使用此属性。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:multiline:get"><apiName>multiline</apiName><shortdesc>
	 指示字段是否为多行文本字段。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.multiline, multiline
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>指示文本字段是否为多行文本字段。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指示字段是否为多行文本字段。如果值为 <codeph>true</codeph>，则文本字段为多行文本字段；如果值为 <codeph>false</codeph>，则文本字段为单行文本字段。在类型为 <codeph>TextFieldType.INPUT</codeph> 的字段中，<codeph>multiline</codeph> 值将确定 <codeph>Enter</codeph> 键是否创建新行（如果值为 <codeph>false</codeph>，则将忽略 <codeph>Enter</codeph> 键）。如果将文本粘贴到其 <codeph>multiline</codeph> 值为 <codeph>false</codeph> 的 <codeph>TextField</codeph> 中，则文本中将除去新行。

	 
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/numLines"><linktext>numLines</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:numLines:get"><apiName>numLines</apiName><shortdesc>
	 定义多行文本字段中的文本行数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.numLines, numLines
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>定义多行文本字段中的文本行数。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 定义多行文本字段中的文本行数。如果 <codeph>wordWrap</codeph> 属性设置为 <codeph>true</codeph>，则在文本自动换行时会增加行数。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/multiline"><linktext>multiline</linktext></link><link href="flash.text.xml#TextField/wordWrap"><linktext>wordWrap</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:restrict:get"><apiName>restrict</apiName><shortdesc>
	 指示用户可输入到文本字段中的字符集。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.restrict, restrict
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>null
     
	 </apiDefaultValue><apiTipTexts><apiTipText>用户可以输入到文本字段中的字符集。
	 

	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指示用户可输入到文本字段中的字符集。如果 <codeph>restrict</codeph> 属性的值为 <codeph>null</codeph>，则可以输入任何字符。如果 <codeph>restrict</codeph> 属性的值为空字符串，则不能输入任何字符。如果 <codeph>restrict</codeph> 属性的值为一串字符，则只能在文本字段中输入该字符串中的字符。从左向右扫描该字符串。可以使用连字符 (-) 指定一个范围。只限制用户交互；脚本可将任何文本放入文本字段中。<ph outputclass="flashonly">此属性不与属性检查器中的“嵌入字体”选项同步。</ph>
	 
	 <p>如果字符串以尖号 (^) 开头，则先接受所有字符，然后从接受字符集中排除字符串中 ^ 之后的字符。如果字符串不以尖号 (^) 开头，则最初不接受任何字符，然后将字符串中的字符包括在接受字符集中。</p>
	 
	 <p>下例仅允许在文本字段中输入大写字符、空格和数字：</p>
	 <pre>
	 my_txt.restrict = "A-Z 0-9";
	 </pre>
	 <p>下例包含除小写字母之外的所有字符：</p>
	 <pre>
	 my_txt.restrict = "^a-z";
	 </pre>
	 <p>可以使用反斜杠输入 ^ 或 - 的本义。认可的反斜杠序列为 \-、\^ 或 \\。反斜杠在字符串中必须是一个本义字符，因此在 ActionScript 中指定时必须使用两个反斜杠。例如，下面的代码只包含短划线 (-) 和尖号 (^)：</p>
	 <pre>
	 my_txt.restrict = "\\-\\^";
	 </pre>
	 <p>可在字符串中的任何位置使用 ^，以在包含字符与排除字符之间进行切换。下面的代码只包含除大写字母 Q 之外的大写字母：</p>
	 <pre>
	 my_txt.restrict = "A-Z^Q";
	 </pre>
	 <p>可以使用 <codeph>\u</codeph> 转义序列构造 <codeph>restrict</codeph> 字符串。下面的代码只包含从 ASCII 32（空格）到 ASCII 126（代字号）之间的字符。</p>
	 <pre>
     my_txt.restrict = "\u0020-\u007E";
	 </pre>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:scrollH:get"><apiName>scrollH</apiName><shortdesc>
	 当前水平滚动位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.scrollH, scrollH
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>当前水平滚动位置。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 当前水平滚动位置。如果 <codeph>scrollH</codeph> 属性为 0，则不能水平滚动文本。此属性值是一个以像素为单位表示水平位置的整数。
	 
	 
	 <p>水平滚动的单位是像素，而垂直滚动的单位是行。水平滚动以像素计量是因为您通常使用的大多数字体都是按比例隔开的；这意味着字符可以有不同的宽度。Flash Player 按行进行垂直滚动是因为用户通常希望看到完整的一行文本，而不是一行的局部。即使一行中包含多种字体，行的高度也会调整到与使用的最大字体相适合。</p>
	 
	 <p><b>注意：</b> <codeph>scrollH</codeph> 属性是从 0 开始的，不像 <codeph>scrollV</codeph> 垂直滚动属性是从 1 开始的。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/maxScrollH"><linktext>flash.text.TextField.maxScrollH</linktext></link><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:scrollV:get"><apiName>scrollV</apiName><shortdesc>
	 文本在文本字段中的垂直位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.scrollV, scroll
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>文本在文本字段中的垂直位置。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 文本在文本字段中的垂直位置。<codeph>scrollV</codeph> 属性可帮助用户定位到长篇文章的特定段落，还可用于创建滚动文本字段。
	 
	 <p>垂直滚动的单位是行，而水平滚动的单位是像素。如果显示的第一行是文本字段中的第一行，则 scrollV 设置为 1（而非 0）。水平滚动以像素计量是因为大多数字体都是按比例隔开的；这意味着字符可以有不同的宽度。Flash 按行进行垂直滚动是因为用户通常希望看到完整的一行文本，而不是一行的局部。即使一行上有多种字体，行的高度也会调整到与使用的最大字体相适合。</p>
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollH"><linktext>flash.text.TextField.scrollH</linktext></link><link href="flash.text.xml#TextField/maxScrollV"><linktext>flash.text.TextField.maxScrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectable:get"><apiName>selectable</apiName><shortdesc>
	 一个布尔值，指示文本字段是否可选。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.selectable, selectable
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
     
         </apiDefaultValue><apiTipTexts><apiTipText>指示文本字段是否可选。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 一个布尔值，指示文本字段是否可选。值 <codeph>true</codeph> 表示文本可选。<codeph>selectable</codeph> 属性控制文本字段是否可选，而不控制文本字段是否可编辑。动态文本字段即使不可编辑，它也可能是可选的。如果动态文本字段是不可选的，则用户不能选择其中的文本。
	 
	 <p>如果 <codeph>selectable</codeph> 设置为 <codeph>false</codeph>，则文本字段中的文本不响应来自鼠标或键盘的选择命令，并且不能使用“复制”命令复制文本。如果 <codeph>selectable</codeph> 设置为 <codeph>true</codeph>，则可以使用鼠标或键盘选择文本字段中的文本，并且可以使用“复制”命令复制文本。即使文本字段是动态文本字段而不是输入文本字段，您也可以用这种方式选择文本。 </p>
	 
     </apiDesc><example conref="examples\TextField_selectable.as"> 下面的示例创建两个动态文本字段：一个文本字段的 <codeph>selectable</codeph> 属性设置为 <codeph>true</codeph>，另一个文本字段的 <codeph>selectable</codeph> 属性设置为 <codeph>false</codeph>。在使用此示例时，请尝试用鼠标或键盘在这些字段中选择文本。
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class selectableExample extends Sprite
    {
        public function selectableExample()
        {
    var tf1:TextField = createCustomTextField(10, 10);
    tf1.text="This text can be selected";
    tf1.selectable=true;

    var tf2:TextField = createCustomTextField(10, 30);
    tf2.text="This text cannot be selected";
    tf2.selectable=false;
        }

        private function createCustomTextField(x:Number, y:Number):TextField 
       {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.autoSize=TextFieldAutoSize.LEFT;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectionBeginIndex:get"><apiName>selectionBeginIndex</apiName><shortdesc>
	 当前所选内容中第一个字符从零开始的字符索引值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>所选内容中第一个字符从零开始的索引值。 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 当前所选内容中第一个字符从零开始的字符索引值。例如，第一个字符的索引值是 0，第二个字符的索引值是 1，依此类推。如果未选定任何文本，此属性为 <codeph>caretIndex</codeph> 的值。
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> 在此示例中，创建了一个 TextField 实例，并用文本填充该实例。分配了一个事件侦听器，以便在用户单击 TextField 时，调用 <codeph>printCursorPosition</codeph> 方法。在这种情况下，将输出 <codeph>caretIndex</codeph>、<codeph>selectionBeginIndex</codeph> 和 <codeph>selectionEndIndex</codeph> 属性的值。
 
 <p>运行此示例并尝试在 TextField 中单击以选择文本。然后在字段中单击，但不选择文本。如果在文本中单击但不进行选择，<codeph>caretIndex</codeph> 属性将指示在何处出现插入点，而 <codeph>selectionBeginIndex</codeph> 和 <codeph>selectionEndIndex</codeph> 属性则等于 <codeph>caretIndex</codeph> 属性值。</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectionEndIndex:get"><apiName>selectionEndIndex</apiName><shortdesc>
	 当前所选内容中最后一个字符从零开始的字符索引值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>所选内容中最后一个字符的从零开始的索引值。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 当前所选内容中最后一个字符从零开始的字符索引值。例如，第一个字符的索引值是 0，第二个字符的索引值是 1，依此类推。如果未选定任何文本，此属性为 <codeph>caretIndex</codeph> 的值。
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> 在此示例中，创建了一个 TextField 实例，并用文本填充该实例。分配了一个事件侦听器，以便在用户单击 TextField 时，调用 <codeph>printCursorPosition</codeph> 方法。在这种情况下，将输出 <codeph>caretIndex</codeph>、<codeph>selectionBeginIndex</codeph> 和 <codeph>selectionEndIndex</codeph> 属性的值。
 
 <p>运行此示例并尝试在 TextField 中单击以选择文本。然后在字段中单击，但不选择文本。如果在文本中单击但不进行选择，<codeph>caretIndex</codeph> 属性将指示在何处出现插入点，而 <codeph>selectionBeginIndex</codeph> 和 <codeph>selectionEndIndex</codeph> 属性则等于 <codeph>caretIndex</codeph> 属性值。</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:sharpness:get"><apiName>sharpness</apiName><shortdesc>
	 此文本字段中字型边缘的清晰度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example creates three text fields with
	 <code>sharpness</code> set to <code>400</code>, <code>0</code>, and <code>-400</code>.
	 It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 400, 100);
	 my_text1.text = "This text has sharpness set to 400."
	 my_text1.embedFonts = true;
	 my_text1.antiAliasType = "advanced";
	 my_text1.gridFitType = "pixel";
	 my_text1.sharpness = 400;
	 my_text1.setTextFormat(my_format);
         
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 40, 400, 100);
	 my_text2.text = "This text has sharpness set to 0."
	 my_text2.embedFonts = true;
	 my_text2.antiAliasType = "advanced";
	 my_text2.gridFitType = "pixel";
	 my_text2.sharpness = 0;
	 my_text2.setTextFormat(my_format);
	 
	 var my_text3:TextField = this.createTextField("my_text3", this.getNextHighestDepth(), 10, 70, 400, 100);
	 my_text3.text = "This text has sharpness set to -400."
	 my_text3.embedFonts = true;
	 my_text3.antiAliasType = "advanced";
	 my_text3.gridFitType = "pixel";
	 my_text3.sharpness = -400;
	 my_text3.setTextFormat(my_format);
	 </listing>
	 
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
     
         </apiDefaultValue><apiTipTexts><apiTipText>字型边缘的清晰度。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 此文本字段中字型边缘的清晰度。仅在文本字段的 <codeph>flash.text.AntiAliasType</codeph> 属性设置为 <codeph>flash.text.AntiAliasType.ADVANCED</codeph> 时才应用此属性。<codeph>sharpness</codeph> 的范围是从 -400 到 400 的一个数字。如果尝试将 <codeph>sharpness</codeph> 设置为该范围外的值，则 Flash 会将该属性设置为范围内最接近的值（-400 或 400）。
	 
	 </apiDesc><example conref="examples\TextField_sharpness.as"> 下面的示例显示更改 TextField 对象的 <codeph>sharpness</codeph> 属性所产生的效果。您需要嵌入字体并将 <codeph>antiAliasType</codeph> 属性设置为 <codeph>ADVANCED</codeph>。
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;
    import flash.text.TextFormat;

    public class sharpnessExample extends Sprite
    {
        public function sharpnessExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=24;
    var lTxt:String = "The quick brown fox";

    var tf1:TextField=createCustomTextField(0,lTxt,format1,-400);
    var tf2:TextField=createCustomTextField(30,lTxt,format1,0);
    var tf3:TextField=createCustomTextField(60,lTxt,format1,400);
        }

        private function createCustomTextField(y:Number,fldTxt:String,format:TextFormat,fldSharpness:Number):TextField 
       {
            var result:TextField = new TextField();
            result.y=y;
            result.text=fldTxt;
            result.embedFonts=true;
            result.autoSize=TextFieldAutoSize.LEFT;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.gridFitType=GridFitType.PIXEL;
            result.sharpness=fldSharpness;
            result..setTextFormat(format);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:styleSheet:get"><apiName>styleSheet</apiName><shortdesc>
	 将样式表附加到文本字段。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, StyleSheet, style sheet, stylesheet
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.text:StyleSheet</apiValueClassifier><apiTipTexts><apiTipText>将样式表附加到文本字段。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 将样式表附加到文本字段。有关创建样式表的信息，请参阅 StyleSheet 类和<i>《ActionScript 3.0 编程》</i>。
	 
	 <p>您可以随时更改与文本字段相关的样式表。如果更改使用中的样式表，会使用新的样式表重绘文本字段。您可以将样式表设置为 <codeph>null</codeph> 或 <codeph>undefined</codeph> 以删除此样式表。如果删除正在使用的样式表，则不使用样式表重绘文本字段。 </p>
     <p><b>注意：</b>如果删除样式表，则 <codeph>TextField.text</codeph> 和 <codeph> TextField.htmlText</codeph> 的内容都将体现先前由该样式表应用的格式。要保留不带格式的原始 <codeph>TextField.htmlText</codeph> 内容，请在删除样式表前将该值保存在变量中。</p>
	 
     </apiDesc><example conref="examples\TextField_styleSheet.as"> 下面的示例定义一个简单的 StyleSheet 对象并为其分配一个包含 HTML 内容的文本字段。在设置内容之前设置 <codeph>stylesheet</codeph> 属性。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.StyleSheet;

    public class TextStylesheetExample extends Sprite {
        var myLabel:TextField = new TextField();
        var labelText:String = "Hello world.";
        var newStyle:StyleSheet = new StyleSheet();

        public function TextStylesheetExample()
       {
            var styleObj:Object = new Object();
            styleObj.fontWeight = "bold";
            styleObj.color = "#660066";
            newStyle.setStyle(".defStyle", styleObj);

            myLabel.styleSheet=newStyle;
            myLabel.htmlText=labelText;
            addChild(myLabel);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:text:get"><apiName>text</apiName><shortdesc>
	 作为文本字段中当前文本的字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.text, text
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>作为文本字段中当前文本的字符串。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 作为文本字段中当前文本的字符串。各行之间用回车符（<codeph>'\r'</codeph>，即 ASCII 13）分隔。此属性包含文本字段中的无格式文本，不带 HTML 标签。
	 
	 <p>要获取 HTML 形式的文本，请使用 <codeph>htmlText</codeph> 属性。</p>
	 
	 </apiDesc><example conref="examples\TextField_text.as"> 下例创建一个名为 <codeph>tf1</codeph> 的 TextField，并将 HTML 格式的字符串赋给其 <codeph>text</codeph> 属性。当跟踪其 <codeph>htmlText</codeph> 属性时，输出为 HTML 格式的字符串，带有由 Flash Player 自动添加的其它标签（如 &lt;P> 和 &lt;FONT>）。当跟踪 <codeph>text</codeph> 属性的值时，将显示不带 HTML 标签的无格式字符串。
 
 <p>为了进行比较，我们对另一个名为 <codeph>tf2</codeph> 的 TextField 对象执行了同样的步骤，并在设置 <codeph>tf2</codeph> 的 <codeph>htmlText</codeph> 属性之前将 StyleSheet 对象赋给它的 <codeph>styleSheet</codeph> 属性。在这种情况下，当跟踪 <codeph>htmlText</codeph> 属性时，它只包括最初赋给 <codeph>htmlText</codeph> 属性的 HTML 文本，说明 Flash Player 没有添加其它标签。</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;

    public class TextField_text extends Sprite {
        public function TextField_text() {
            var tf1:TextField = createCustomTextField(10, 10, 400, 22);
            tf1.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";

            // htmlText: &lt;P ALIGN="LEFT">&lt;FONT FACE="Times New Roman" SIZE="12" COLOR="#000000" LETTERSPACING="0" KERNING="0">&amp;lt;b&amp;gt;Lorem ipsum dolor sit amet.&amp;lt;/b&amp;gt;&lt;/FONT>&lt;/P>
            trace("htmlText: " + tf1.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf1.text);
            
            var tf2:TextField = createCustomTextField(10, 50, 400, 22);
            tf2.styleSheet = new StyleSheet();
            tf2.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";
            // htmlText: &lt;b>Lorem ipsum dolor sit amet.&lt;/b>
            trace("htmlText: " + tf2.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf2.text);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:textColor:get"><apiName>textColor</apiName><shortdesc>
	 文本字段中文本的颜色（采用十六进制格式）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textColor, textColor
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiDefaultValue>0 (0x000000)
	 </apiDefaultValue><apiTipTexts><apiTipText>文本字段中文本的颜色（采用十六进制格式）。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 文本字段中文本的颜色（采用十六进制格式）。十六进制颜色系统使用六位数表示颜色值。每位数有 16 个可能的值或字符。字符范围从 0 到 9，然后从 A 到 F。例如，黑色是 <codeph>0x000000</codeph>；白色是 <codeph>0xFFFFFF</codeph>。
	 
     </apiDesc><example conref="examples\TextField_textColor.as"> 下面的 ActionScript 创建一个 TextField 对象，并将其 <codeph>textColor</codeph> 属性更改为 red (<codeph>0xFF0000</codeph>)。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textColor extends Sprite {
        public function TextField_textColor() {
            var tf:TextField = createCustomTextField(10, 10, 100, 300);
            tf.text = "This will be red text";
            tf.textColor = 0xFF0000;            
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.text:TextField:textHeight:get"><apiName>textHeight</apiName><shortdesc>
	 文本的高度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textHeight, textHeight
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>文本的高度，以像素为单位。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 文本的高度，以像素为单位。
	 
	 </apiDesc><example conref="examples\TextField_textHeight.as"> 下例创建一个 TextField 对象，并为其分配文本。<codeph>trace</codeph> 语句显示 <codeph>textWidth</codeph> 和 <codeph>textHeight</codeph> 属性的值。为了进行比较，还会显示 <codeph>width</codeph> 和 <codeph>height</codeph> 属性。（请注意，看到的 <codeph>textHeight</codeph> 和 <codeph>textWidth</codeph> 值可能会有所不同，这取决于计算机上所用的字体）。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textHeight extends Sprite {
        public function TextField_textHeight() {
            var tf:TextField = createCustomTextField(10, 10, 100, 150);
            tf.text = "Sample text";
            
            trace("textWidth: " + tf.textWidth); // textWidth: 55.75
            trace("textHeight: " + tf.textHeight); // textHeight: 13.450000000000001
            trace("width: " + tf.width); // width: 100
            trace("height: " + tf.height); // height: 150
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            result.background = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/textWidth"><linktext>flash.text.TextField.textWidth</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:textWidth:get"><apiName>textWidth</apiName><shortdesc>
	 文本的宽度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textWidth, textWidth
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>文本的宽度，以像素为单位。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 文本的宽度，以像素为单位。
	 
	 </apiDesc><example conref="examples\TextField_textHeight.as"> 下例创建一个 TextField 对象，并为其分配文本。<codeph>trace</codeph> 语句显示 <codeph>textWidth</codeph> 和 <codeph>textHeight</codeph> 属性的值。为了进行比较，还会显示 <codeph>width</codeph> 和 <codeph>height</codeph> 属性。（请注意，看到的 <codeph>textHeight</codeph> 和 <codeph>textWidth</codeph> 值可能会有所不同，这取决于计算机上所用的字体）。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textHeight extends Sprite {
        public function TextField_textHeight() {
            var tf:TextField = createCustomTextField(10, 10, 100, 150);
            tf.text = "Sample text";
            
            trace("textWidth: " + tf.textWidth); // textWidth: 55.75
            trace("textHeight: " + tf.textHeight); // textHeight: 13.450000000000001
            trace("width: " + tf.width); // width: 100
            trace("height: " + tf.height); // height: 150
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            result.background = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/textHeight"><linktext>flash.text.TextField.textHeight</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:thickness:get"><apiName>thickness</apiName><shortdesc>
	 此文本字段中字型边缘的粗细。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example creates two text fields and applies a <code>thickness</code> of -200 to one
	 and 200 to the other.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 300, 30);
	 my_text1.text = "thickness = 200";
	 my_text1.antiAliasType = "advanced";
	 my_text1.border = true;
	 my_text1.thickness = 200;
	 my_text1.embedFonts = true;
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 50, 300, 30);
	 my_text2.text = "thickness = -200."
	 my_text2.antiAliasType = "advanced";
	 my_text2.thickness = -200;
	 my_text2.border = true;
	 my_text2.embedFonts = true;
	 my_text2.setTextFormat(my_format);
	 </listing>
     
         </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
     
	 </apiDefaultValue><apiTipTexts><apiTipText>字型边缘的粗细。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 此文本字段中字型边缘的粗细。仅在 <codeph>flash.text.AntiAliasType</codeph> 设置为 <codeph>flash.text.AntiAliasType.ADVANCED</codeph> 时才可应用此属性。
	 
	 <p><codeph>thickness</codeph> 的范围是从 -200 到 200 的一个数字。如果要尝试将 <codeph>thickness</codeph> 设置为该范围外的值，则该属性会设置为范围内最接近的值（-200 或 200）。</p>
	 
     </apiDesc><example conref="examples\TextField_thickness.as"> 下面的示例显示更改 TextField 对象的 <codeph>thickness</codeph> 属性所产生的效果。您需要嵌入字体并将 <codeph>antiAliasType</codeph> 属性设置为 <codeph>ADVANCED</codeph>。
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;
    import flash.text.TextFormat;

    public class thicknessExample extends Sprite
    {
        public function thicknessExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=24;
    var lTxt:String = "The quick brown fox";

    var tf1:TextField=createCustomTextField(0,lTxt,format1,-200);
    var tf2:TextField=createCustomTextField(30,lTxt,format1,0);
    var tf3:TextField=createCustomTextField(60,lTxt,format1,200);
        }

        private function createCustomTextField(y:Number,fldTxt:String,format:TextFormat,fldThickness:Number):TextField 
       {
            var result:TextField = new TextField();
            result.y=y;
            result.text=fldTxt;
            result.embedFonts=true;
            result.autoSize=TextFieldAutoSize.LEFT;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.gridFitType=GridFitType.PIXEL;
            result.thickness=fldThickness;
            result.setTextFormat(format);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:type:get"><apiName>type</apiName><shortdesc>
	 文本字段的类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.type, type
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>指定的 <codeph>type</codeph> 不是 flash.text.TextFieldType 的成员。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>dynamic
     
	 </apiDefaultValue><apiTipTexts><apiTipText>文本字段的类型。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 文本字段的类型。以下 TextFieldType 常量中的任一个：<codeph>TextFieldType.DYNAMIC</codeph>（指定用户无法编辑的动态文本字段），或 <codeph>TextFieldType.INPUT</codeph>（指定用户可以编辑的输入文本字段）。
	 
     </apiDesc><example conref="examples\TextField_type.as"> 下例创建两个文本字段：<codeph>tfDynamic</codeph> 和 <codeph>tfInput</codeph>。文本输入到两个文本字段中。但是，<codeph>tfDynamic</codeph> 将其 <codeph>type</codeph> 属性设置为 <codeph>TextFieldType.DYNAMIC</codeph>，而 <codeph>tfInput</codeph> 将其 <codeph>type</codeph> 属性设置为 <codeph>TextFieldType.INPUT</codeph>，所以用户可以修改 <codeph>tfInput</codeph> 中的文本，但只能查看 <codeph>tfDynamic</codeph> 中的文本。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_type extends Sprite {
        public function TextField_type() {
            var tfDynamic:TextField = createCustomTextField(10, 10, 100, 20);
            tfDynamic.type = TextFieldType.DYNAMIC;
            tfDynamic.text = "hello";

            var tfInput:TextField = createCustomTextField(10, 45, 100, 20);
            tfInput.type = TextFieldType.INPUT;
            tfInput.text = "world";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextFieldType"><linktext>flash.text.TextFieldType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:useRichTextClipboard:set"><apiName>useRichTextClipboard</apiName><shortdesc>
	 指定在复制和粘贴文本时是否同时复制和粘贴其格式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 指定在复制和粘贴文本时是否同时复制和粘贴其格式。如果设置为 <codeph>true</codeph>，则在文本字段之间复制和粘贴时，Flash Player 也将复制和粘贴格式设置（例如，对齐方式、粗体和斜体）。复制和粘贴过程中的原始和目标文本字段必须已将 <codeph>useRichTextClipboard</codeph> 设置为 <codeph>true</codeph>。默认值为 <codeph>false</codeph>。
	 
	 </apiDesc><example conref="examples\TextField_useRichTextClipboard.as"> 此示例创建一个输入文本字段 (<codeph>tf1</codeph>) 和两个动态文本字段（<codeph>tf2</codeph> 和 <codeph>tf3</codeph>）。代码为每个动态文本字段分配一个 TextFormat 对象（Courier Bold 字体）。<codeph>tf2</codeph> 文本字段的 <codeph>useRichTextClipboard</codeph> 属性设置为 <codeph>false</codeph>。<codeph>tf3</codeph> 文本字段的 <codeph>useRichTextClipboard</codeph> 属性设置为 <codeph>true</codeph>。在从 <codeph>tf2</codeph> 文本字段复制文本并将其粘贴到 <codeph>tf1</codeph> 文本字段中时，粘贴的文本不包括格式。在从 <codeph>tf3</codeph> 文本字段（<codeph>useRichTextClipboard</codeph> 设置为 <codeph>true</codeph>）复制文本并将其粘贴到 <codeph>tf1</codeph> 文本字段中时，粘贴的文本包括格式。
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFormat;

    public class useRichTextClipboard extends Sprite
    {
        public function useRichTextClipboard()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Courier";
    format1.bold=true;

    var tf1:TextField = createCustomTextField(10, 10, 200, 20);
    tf1.type=TextFieldType.INPUT;
    tf1.useRichTextClipboard=true;

    var tf2:TextField = createCustomTextField(220, 10, 200, 20);
    tf2.text="1.Text loses format";
    tf2.setTextFormat(format1);
    tf2.useRichTextClipboard=false;

    var tf3:TextField = createCustomTextField(220, 50, 200, 20);
    tf3.text="2.Text includes format";
    tf3.setTextFormat(format1);
    tf3.useRichTextClipboard=true;
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField 
       {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.text:TextField:wordWrap:get"><apiName>wordWrap</apiName><shortdesc>
	 一个布尔值，指示文本字段是否自动换行。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.wordWrap, wordWrap
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>指示文本字段是否自动换行。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 一个布尔值，指示文本字段是否自动换行。如果 <codeph>wordWrap</codeph> 的值为 <codeph>true</codeph>，则该文本字段自动换行；如果值为 <codeph>false</codeph>，则该文本字段不自动换行。默认值为 <codeph>false</codeph>。
	 
	 </apiDesc><example conref="examples\TextField_wordWrap.as"> 下面显示将 <codeph>wordWrap</codeph> 属性设置为 <codeph>true</codeph> 和将其设置为 <codeph>false</codeph> 之间的区别。创建两个 TextField 实例，它们的内容对于它们的宽度来说太大。第一个（名为 <codeph>tfWrap</codeph>）的 <codeph>wordWrap</codeph> 属性设置为 <codeph>true</codeph>；第二个 (<codeph>tfNoWrap</codeph>) 的此属性设置为 <codeph>false</codeph>。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_wordWrap extends Sprite {
        public function TextField_wordWrap() {
            var tfWrap:TextField = createCustomTextField(10, 10, 100, 100);
            tfWrap.wordWrap = true;
            tfWrap.text = "(wordWrap = true):\nThis is very long text that will certainly extend beyond the width of this text field";

            var tfNoWrap:TextField = createCustomTextField(10, 150, 100, 100);
            tfNoWrap.wordWrap = false;
            tfNoWrap.text = "(wordWrap = false):\nThis is very long text that will certainly extend beyond the width of this text field";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextFormat"><apiName>TextFormat</apiName><shortdesc>
 TextFormat 类描述字符格式设置信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Insure the above example is correct and meets example standards
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>创建文本字段的文本格式设置。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 TextFormat 类描述字符格式设置信息。使用 TextFormat 类可以为文本字段创建特定的文本格式。您可以将文本格式应用于静态文本字段和动态文本字段。TextFormat 类的属性适用于设备字体和嵌入字体。不过，对于嵌入字体，粗体和斜体文本实际上需要特定字体。如果要使用嵌入字体来显示粗体或斜体文本，则需要嵌入该字体的粗体和斜体变体。
 
 <p> 必须先使用构造函数 <codeph>new TextFormat()</codeph> 创建 TextFormat 对象，才能设置该构造函数的属性。在使用 <codeph>TextField.defaultTextFormat</codeph> 属性或 <codeph>TextField.setTextFormat()</codeph> 方法对文本字段应用 TextFormat 对象时，将只应用该对象的已定义的属性。在向 <codeph>TextField</codeph> 添加文本前，请使用 <codeph>TextField.defaultTextFormat</codeph> 属性应用格式，在向 the <codeph>TextField</codeph> 添加文本后，请使用 <codeph>setTextFormat()</codeph> 方法添加格式。默认情况下，TextFormat 属性为 <codeph>null</codeph>，因为如果没有提供属性值，Flash Player 将使用自己的默认格式设置。Flash Player 用于各个属性的默认格式（如果属性的值为 <codeph>null</codeph>）如下所示：</p>
 
 <adobetable class="innertable">
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="1"><tbody><row><entry>align = "left"</entry></row><row><entry>blockIndent = 0</entry></row><row><entry>bold = false</entry></row><row><entry>bullet = false</entry></row><row><entry>color = 0x000000</entry></row><row><entry>font = "Times New Roman"（在 Mac OS X 上，默认字体为 Times）</entry></row><row><entry>indent = 0</entry></row><row><entry>italic = false</entry></row><row><entry>kerning = false</entry></row><row><entry>leading = 0</entry></row><row><entry>leftMargin = 0</entry></row><row><entry>letterSpacing = 0</entry></row><row><entry>rightMargin = 0</entry></row><row><entry>size = 12</entry></row><row><entry>tabStops = [] (empty array)</entry></row><row><entry>target = ""(empty string)</entry></row><row><entry>underline = false</entry></row><row><entry>url = ""(empty string)</entry></row></tbody></tgroup></adobetable>
 
 <p>各个属性的默认格式设置在各自的说明中也有所描述。</p>
 
 </apiDesc><example conref="examples\TextFormatExample.as"> 下例创建 TextFieldExample 类来显示默认位置 (x = 0, y = 0) 的文本消息。这是使用以下步骤完成的：
 <ol>
  <li>创建了 TextField 类型的 <codeph>label</codeph> 属性。</li>
  <li>类构造函数调用函数 <codeph>configureLabel()</codeph></li>
  <li><codeph>configureLabel()</codeph> 函数首先创建一个新的 TextField 对象并将其赋给 <codeph>label</codeph> 然后将其参数设置为
  <ul>
      <li>左对齐文本字段</li>
      <li>启用背景填充</li>
      <li>启用边框。</li>
  </ul>
  </li>
  <li>接下来，<codeph>configureLable()</codeph> 创建局部变量 <codeph>format</codeph> 并将该变量赋给新的 TextFormat 实例，同时将其参数设置为:
  <ul>
      <li>字体类型 = 宋体</li>
      <li>字体颜色 = 纯红色</li>
      <li>字体大小 = 10</li>
      <li>字体下划线 = true。</li>
  </ul>
  </li>
  <li>标签的 <codeph>defaultTextFormat</codeph> 属性设置为 <codeph>format</codeph>，而 <codeph>label</codeph> 实例将添加到显示列表中，此显示列表最初在舞台上显示不包含文本的文本字段（例如具有白色背景的小框）。</li>
  <li>最后（返回构造函数），通过调用以下 <codeph>setLabel()</codeph>，标签的文本会设置为在坐标 x = 0，y = 0 处显示“Hello World and welcome to the show”。</li>
 </ol>
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFormat;


    public class TextFormatExample extends Sprite {
        private var label:TextField;

        public function TextFormatExample() {
            configureLabel();
            setLabel("Hello World and welcome to the show");
        }

        public function setLabel(str:String):void {
            label.text = str;
        }

        private function configureLabel():void {
            label = new TextField();
            label.autoSize = TextFieldAutoSize.LEFT;
            label.background = true;
            label.border = true;

            var format:TextFormat = new TextFormat();
            format.font = "Verdana";
            format.color = 0xFF0000;
            format.size = 10;
            format.underline = true;

            label.defaultTextFormat = format;
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link><link href="flash.text.xml#TextField/getTextFormat()"><linktext>flash.text.TextField.getTextFormat()</linktext></link></related-links><apiConstructor id="flash.text:TextFormat:TextFormat"><apiName>TextFormat</apiName><shortdesc>
 	 创建一个具有指定属性的 TextFormat 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat
 	 
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>font</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>以字符串形式表示的文本字体名称。
 	 </apiDesc></apiParam><apiParam><apiItemName>size</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>一个指示大小（以像素为单位）的整数。
 	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>使用此文本格式的文本的颜色。包含三个 8 位 RGB 颜色成分的数字；例如，0xFF0000 为红色，0x00FF00 为绿色。
 	 </apiDesc></apiParam><apiParam><apiItemName>bold</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>一个布尔值，指示文本是否为粗体字。
 	 </apiDesc></apiParam><apiParam><apiItemName>italic</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>一个布尔值，指示文本是否为斜体。
 	 </apiDesc></apiParam><apiParam><apiItemName>underline</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>一个布尔值，指示文本是否带有下划线。
 	 </apiDesc></apiParam><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>使用此文本格式的文本超链接到的 URL。如果 <codeph>url</codeph> 为空字符串，则表示文本没有超链接。
 	 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>显示超链接的目标窗口。如果目标窗口为空字符串，则文本显示在默认目标窗口 <codeph>_self</codeph> 中。如果 <codeph>url</codeph> 参数设置为空字符串或值 <codeph>null</codeph>，虽然您可以获取或设置此属性，但该属性不起作用。
 	 </apiDesc></apiParam><apiParam><apiItemName>align</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>段落的对齐方式，作为 TextFormatAlign 值。
 	 </apiDesc></apiParam><apiParam><apiItemName>leftMargin</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>指示段落的左边距，以像素为单位。
 	 </apiDesc></apiParam><apiParam><apiItemName>rightMargin</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>指示段落的右边距，以像素为单位。
 	 </apiDesc></apiParam><apiParam><apiItemName>indent</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>一个整数，指示从左边距到段落中第一个字符的缩进。
 	 </apiDesc></apiParam><apiParam><apiItemName>leading</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>一个数字，指示行与行之间的前导垂直间距量。
 	 
   	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 创建一个具有指定属性的 TextFormat 对象。然后可更改 TextFormat 对象的属性以更改文本字段的格式设置。
	 
 	 <p>任何参数都可设置为 <codeph>null</codeph> 以指示该参数未定义。所有参数都是可选的；任何省略的参数都被视为 <codeph>null</codeph>。</p>
  	 
 	 </apiDesc><example conref="examples\TextFormat_constructorExample.as"> 在下面的示例中，用户可以从应用于另一个文本字段内容的列表中选择不同的文本格式选项。如果用户单击文本字段的内容，该格式将恢复为默认（原始）格式。
 
 <p><codeph>formatTextField</codeph> 文本字段将在单独的行中列出所有 TextField 类属性选项（<codeph>kerning</codeph> 除外）。当用户单击 <codeph>formatTextField</codeph> 文本字段中的某一行时，将触发 <codeph>formatTextFieldClickHandler()</codeph> 方法。</p> 
 
 <p><codeph>formatTextFieldClickHandler()</codeph> 方法调用 <codeph>TextField.getLineIndexAtPoint()</codeph> 方法以获取所单击的行的索引，然后调用 <codeph>TextField.getLineText()</codeph> 方法以获取行内容。switch 语句将检查该行内容，并相应地设置 <codeph>newformat</codeph> TextFormat 对象的属性。然后，<codeph>setTextFormat()</codeph> 方法将 <codeph>contentTextField</codeph> 文本字段的文本格式设置为新格式。通过单击不同的 <codeph>formatTextField</codeph> 行，用户可以将一个不同的格式应用于 <codeph>contentTextField</codeph> 文本字段。（Tab 设置是一个数组，它为行中的每个 Tab 定义了单独的 Tab 停靠位。） 如果选择了 <codeph>url</codeph> 或 <codeph>target</codeph> 行，用户必须单击 <codeph>contentTextField</codeph> 文本字段才能激活链接并显示目标 URL（Flex 主页）的内容。<codeph>target</codeph> 属性的默认值为“_self”，这意味着，如果用户选择了 <codeph>url</codeph> 行，则会在当前窗口中显示该内容。要使 <codeph>target</codeph> 属性起作用，必须已经在 <codeph>url</codeph> 属性中设置了 URL。</p>
 
 <p>如果用户单击 <codeph>contentTextField</codeph> 文本字段，将触发 <codeph>contentTextFieldClickHandler()</codeph> 方法，它将该字段的格式以及 <codeph>newFormat</codeph> TextFormat 对象设置为文本字段的默认（原始）格式。这将清除用户所做的所有格式更改。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.text.TextFormatAlign;
    
    public class TextFormat_constructorExample extends Sprite {
        private var contentTextField:TextField = new TextField();
        private var formatTextField:TextField = new TextField();
        private var newFormat:TextFormat = new TextFormat();
        
        public function TextFormat_constructorExample() {
            contentTextField.x = 10;
            contentTextField.y = 10;
            contentTextField.background = true;
            contentTextField.border = true;
            contentTextField.multiline = true;
            contentTextField.wordWrap = true;
            contentTextField.selectable = false;
            contentTextField.width = 250;
            contentTextField.height = 120; 
  
            contentTextField.htmlText = "&lt;p>The TextFormat class represents character formatting "
                + "information. Use the TextFormat class to create specific text formatting "
                + "for text fields." + 
                " &lt;/p>&lt;br>" + "\tTab One" + "\tTab Two&lt;br>";
              
            formatTextField.x = 10;
            formatTextField.y = 140;
            formatTextField.background = true;
            formatTextField.border = true;
            formatTextField.autoSize = TextFieldAutoSize.LEFT;
            
            formatTextField.text = "align: right\n" + "blockIndent: 10 pixels\n" + "bold:\n" + "bullet:\n" + "color: red\n"
                                + "font: Arial\n" + "indent: 20 pixels\n" + "italic:\n" + "leading: 5 spaces\n" 
                                + "leftMargin: 20 pixels\n" + "letterSpacing: 4 pixels\n" + "rightMargin: 20 pixels\n" 
                                + "size: 16 point\n" + "target: new window\n" + "tabStops: 50 and 150 pixel\n" 
                                + "underline:\n" + "url: Adobe Flex page\n";

            formatTextField.addEventListener(MouseEvent.CLICK, formatTextFieldClickHandler);
            
            contentTextField.addEventListener(MouseEvent.CLICK, contentTextFieldClickHandler);
            
            this.addChild(contentTextField);
            this.addChild(formatTextField);
        }

        private function formatTextFieldClickHandler(e:MouseEvent):void {
                var value:String= "";
                var i:uint = 0;
                var index:int = formatTextField.getLineIndexAtPoint(e.localX, e.localY);
                var line:String = formatTextField.getLineText(index);;

                line = line.substr(0, (line.indexOf(":")));

                switch(line) {
                    case "align":
                        newFormat.align = TextFormatAlign.RIGHT;
                        break;
                    case "blockIndent":
                        newFormat.blockIndent = 10;
                        break;
                    case "bold":
                        newFormat.bold = true;
                        break;
                    case "bullet":
                        newFormat.bullet = true;
                        break;
                    case "color":
                        newFormat.color = 0xFF0000;        
                        break;
                    case "font":
                        newFormat.font = "Arial";
                        break;
                    case "indent":
                        newFormat.indent = 20;
                        break;
                    case "italic":
                        newFormat.italic = true;
                        break;
                    case "leading":
                        newFormat.leading = 5;
                        break;
                    case "leftMargin":
                        newFormat.leftMargin = 20;
                        break;
                    case "letterSpacing":
                        newFormat.letterSpacing = 4;
                        break;
                    case "rightMargin":
                        newFormat.rightMargin = 20;
                        break;
                    case "size":
                        newFormat.size = 16;
                        break;
                    case "tabStops":                
                        newFormat.tabStops = [50, 150];
                        break;
                    case "target":
                        newFormat.url = "http://www.adobe.com/products/flex/";    
                        newFormat.target = "_blank";
                        break;    
                    case "underline":
                        newFormat.underline = true;
                        break;
                    case "url":
                        newFormat.url = "http://www.adobe.com/products/flex/";    
                        break;
                }    

                contentTextField.setTextFormat(newFormat);
        }

        private function contentTextFieldClickHandler(e:MouseEvent):void {
            contentTextField.setTextFormat(contentTextField.defaultTextFormat);
            newFormat = contentTextField.defaultTextFormat;
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.text:TextFormat:align:get"><apiName>align</apiName><shortdesc>
	 指示段落的对齐方式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.align, align
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>指定的 <codeph>align</codeph> 不是 flash.text.TextFormatAlign 的成员。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>TextFormatAlign.LEFT
	 
	 </apiDefaultValue></apiValueDef><apiDesc>
	 指示段落的对齐方式。有效值为 TextFormatAlign 常数。
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormatAlign"><linktext>flash.text.TextFormatAlign</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:blockIndent:get"><apiName>blockIndent</apiName><shortdesc>
	 指示块缩进，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.blockIndent, blockIndent
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 指示块缩进，以像素为单位。块缩进应用于整个文本块，即文本的所有行。而普通缩进 (<codeph>TextFormat.indent</codeph>) 只影响各段的第一行。如果此属性为 <codeph>null</codeph>，则 TextFormat 对象不指定块缩进（块缩进为 0）。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
 	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:bold:get"><apiName>bold</apiName><shortdesc>
	 指定文本是否为粗体字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.bold, bold
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 指定文本是否为粗体字。默认值为 <codeph>null</codeph>，这意味着不使用粗体字。如果值为 <codeph>true</codeph>，则文本为粗体字。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:bullet:get"><apiName>bullet</apiName><shortdesc>
	 指示文本为带项目符号的列表的一部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.bullet, bullet
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 指示文本为带项目符号的列表的一部分。在带项目符号的列表中，文本的各段都是缩进的。项目符号显示在各段第一行的左侧。默认值为 <codeph>null</codeph>，这意味着不使用带项目符号的列表。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:color:get"><apiName>color</apiName><shortdesc>
	 指示文本的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.color, color
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 指示文本的颜色。包含三个 8 位 RGB 颜色成分的数字；例如，0xFF0000 为红色，0x00FF00 为绿色。默认值为 <codeph>null</codeph>，这意味着 Flash Player 使用黑色 (0x000000)。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:font:get"><apiName>font</apiName><shortdesc>
	 使用此文本格式的文本的字体名称，以字符串形式表示。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.font, font
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 使用此文本格式的文本的字体名称，以字符串形式表示。默认值为 <codeph>null</codeph>，这意味着 Flash Player 对文本使用 Times New Roman 字体。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:indent:get"><apiName>indent</apiName><shortdesc>
	 指示从左边距到段落中第一个字符的缩进。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.indent, indent
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 指示从左边距到段落中第一个字符的缩进。默认值为 <codeph>null</codeph>，它指示不使用缩进。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/blockIndent"><linktext>flash.text.TextFormat.blockIndent</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:italic:get"><apiName>italic</apiName><shortdesc>
	 指示使用此文本格式的文本是否为斜体。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.italic, italic
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 指示使用此文本格式的文本是否为斜体。默认值为 <codeph>null</codeph>，这意味着不使用斜体。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:kerning:get"><apiName>kerning</apiName><shortdesc>
	 一个布尔值，指示是启用 (true) 还是禁用 (false) 字距调整。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><internal>Add better description and example.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 一个布尔值，指示是启用 (<codeph>true</codeph>) 还是禁用 (<codeph>false</codeph>) 字距调整。通过字距调整可为了提高可读性而调整某些字符对之间的像素，并且只在需要时（如使用大字体标题时）使用字距调整。仅对嵌入字体支持字距调整。
	 
	 <p>某些字体（如宋体）和等宽字体（如 Courier New）不支持字距调整。</p>
	 
	 <p>默认值为 <codeph>null</codeph>，这意味着没有启用字距调整。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:leading:get"><apiName>leading</apiName><shortdesc>
	 一个整数，表示行与行之间的垂直间距（称为前导）量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.leading, leading
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 一个整数，表示行与行之间的垂直间距（称为<i>前导</i>）量。默认值为 <codeph>null</codeph>，它指示使用的前导量为 0。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:leftMargin:get"><apiName>leftMargin</apiName><shortdesc>
	 段落的左边距，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.leftMargin, leftMargin
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 段落的左边距，以像素为单位。默认值为 <codeph>null</codeph>，它指示左边距为 0 像素。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:letterSpacing:get"><apiName>letterSpacing</apiName><shortdesc>
     一个数字，表示在所有字符之间均匀分配的空间量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><internal>Add better description and example.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     一个数字，表示在所有字符之间均匀分配的空间量。该值指定在每个字符之后添加到进距的像素数。默认值为 <codeph>null</codeph>，这意味着使用的字母间距为 0 个像素。可以使用十进制值，如 <codeph>1.75</codeph>。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:rightMargin:get"><apiName>rightMargin</apiName><shortdesc>
	 段落的右边距，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.rightMargin, rightMargin
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 段落的右边距，以像素为单位。默认值为 <codeph>null</codeph>，它指示右边距为 0 像素。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:size:get"><apiName>size</apiName><shortdesc>
	 使用此文本格式的文本的大小（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.size, size
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 使用此文本格式的文本的大小（以像素为单位）。默认值为 <codeph>null</codeph>，这意味着使用的大小为 12。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:tabStops:get"><apiName>tabStops</apiName><shortdesc>
	 将自定义 Tab 停靠位指定为一个非负整数的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.tabStops, tabStops
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 将自定义 Tab 停靠位指定为一个非负整数的数组。指定每个 Tab 停靠位，以像素为单位。如果没有指定自定义 Tab 停靠位 (<codeph>null</codeph>)，则默认的 Tab 停靠位为 4（平均字符宽度）。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:target:get"><apiName>target</apiName><shortdesc>
	 指示显示超链接的目标窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.target, target
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指示显示超链接的目标窗口。如果目标窗口为空字符串，则文本显示在默认目标窗口 <codeph>_self</codeph> 中。可以选择自定义名称或以下四种名称中的一个：<codeph>_self</codeph> 指定当前窗口中的当前帧，<codeph>_blank</codeph> 指定一个新窗口，<codeph>_parent</codeph> 指定当前帧的父级，<codeph>_top</codeph> 指定当前窗口中的顶级帧。如果 <codeph>TextFormat.url</codeph> 属性是空字符串或 <codeph>null</codeph>，则虽然您可以获取或设置此属性，但该属性不起作用。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/url"><linktext>flash.text.TextFormat.url</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:underline:get"><apiName>underline</apiName><shortdesc>
	 指示使用此文本格式的文本是带下划线 (true) 还是不带下划线 (false)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.underline, underline
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 指示使用此文本格式的文本是带下划线 (<codeph>true</codeph>) 还是不带下划线 (<codeph>false</codeph>)。此下划线类似于用 <codeph>&lt;U></codeph> 标签生成的下划线，但后者不是真正的下划线，因为它不能正确地跳过下行字符。默认值为 <codeph>null</codeph>，它指示不使用下划线。
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:url:get"><apiName>url</apiName><shortdesc>
	 指示使用此文本格式的文本的目标 URL。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.url, url
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指示使用此文本格式的文本的目标 URL。如果 <codeph>url</codeph> 属性为空字符串，则文本没有超链接。默认值为 <codeph>null</codeph>，它指示文本没有超链接。
	 <p><b>注意：</b>必须使用 <codeph>htmlText</codeph> 属性对具有指定文本格式的文本进行设置以使超链接起作用。</p>
	 
	 </apiDesc><example>有关如何使用此属性的说明，请参阅 <xref href="TextFormat.html#TextFormat()">TextFormat()</xref> 构造函数示例。 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextDisplayMode"><apiName>TextDisplayMode</apiName><shortdesc>
 TextDisplayMode 类包含控制高级消除锯齿系统的子像素锯齿消除的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 TextDisplayMode 类包含控制高级消除锯齿系统的子像素锯齿消除的值。 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer/displayMode"><linktext>flash.text.TextRenderer.displayMode</linktext></link></related-links><apiValue id="flash.text:TextDisplayMode:CRT"><apiName>CRT</apiName><shortdesc>
	 强制 Flash Player 显示灰度消除锯齿。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>crt</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 强制 Flash Player 显示灰度消除锯齿。虽然此设置可避免显示文本颜色，但一些用户可能认为它看起来很模糊。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextDisplayMode:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 允许 Flash Player 选择 LCD 或 CRT 模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 允许 Flash Player 选择 LCD 或 CRT 模式。	
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextDisplayMode:LCD"><apiName>LCD</apiName><shortdesc> 
	 强制 Flash Player 使用 LCD 子像素消除锯齿。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lcd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	 强制 Flash Player 使用 LCD 子像素消除锯齿。根据字体和硬件，此设置可产生分辨率很高的文本或文本颜色。
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:AntiAliasType"><apiName>AntiAliasType</apiName><shortdesc>
AntiAliasType 类为 flash.text.TextField 类中的消除锯齿提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
AntiAliasType 类为 flash.text.TextField 类中的消除锯齿提供值。
</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiValue id="flash.text:AntiAliasType:ADVANCED"><apiName>ADVANCED</apiName><shortdesc>
	将消除锯齿功能设置为高级消除锯齿功能。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>advanced</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	将消除锯齿功能设置为高级消除锯齿功能。使用高级消除锯齿功能时，即使字号很小，字型也能达到极高的呈现品质。它最适合在具有大量小字号文本的应用程序中使用。建议不要对非常大（大于 48 磅）的字体使用高级消除锯齿功能。该常数用于 TextField 类中的 <codeph>antiAliasType</codeph> 属性。使用语法 <codeph>AntiAliasType.ADVANCED</codeph>。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:AntiAliasType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	将消除锯齿功能设置为 Flash Player 7 和更低版本中使用的消除锯齿功能。</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	将消除锯齿功能设置为 Flash Player 7 和更低版本中使用的消除锯齿功能。建议在文本不多的应用程序使用此设置。该常数用于 TextField 类中的 <codeph>antiAliasType</codeph> 属性。使用语法 <codeph>AntiAliasType.NORMAL</codeph>。
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:FontType"><apiName>FontType</apiName><shortdesc>
	 FontType 类包含 Font 类的 fontType 属性的枚举常量 "embedded" 和 "device"。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 FontType 类包含 Font 类的 <codeph>fontType</codeph> 属性的枚举常量 <codeph>"embedded"</codeph> 和 <codeph>"device"</codeph>。 
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#Font/fontType"><linktext>flash.text.Font.fontType</linktext></link></related-links><apiValue id="flash.text:FontType:DEVICE"><apiName>DEVICE</apiName><shortdesc>
		 指示这是一种设备字体。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>device</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示这是一种设备字体。SWF 文件使用系统中安装的字体来呈现字体。
		 
		 <p>使用设备字体可减小影片大小，因为字体数据不包括在文件中。设备字体通常适合以小磅值显示文本，因为消除锯齿的文本在使用小字号时可能显得模糊。设备字体还适合大文本块，如滚动文本。</p>
		 
		 <p>使用设备字体的文本字段在不同系统和平台上的显示可能有所不同，因为文本字段是使用系统中安装的字体来呈现的。由于同样的原因，设备字体未消除锯齿，并且在以大磅值显示时可能出现锯齿。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/embedFonts"><linktext>TextField.embedFonts</linktext></link><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link></related-links></apiValue><apiValue id="flash.text:FontType:EMBEDDED"><apiName>EMBEDDED</apiName><shortdesc>
		 指示这是一种嵌入字体。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>embedded</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示这是一种嵌入字体。字体轮廓嵌入到已发布的 SWF 文件中。
		 
		 <p>使用嵌入字体的文本字段始终以选择的字体显示，不管该字体是否安装在回放系统上。另外，始终对使用嵌入字体的文本字段进行消除锯齿（平滑）处理。可以使用 <codeph>TextField.antiAliasType property</codeph>来选择所需的消除锯齿量。</p>
		 
		 <p>嵌入字体的一个缺点是它们增大了 SWF 文件的大小。</p>
		 
		 <p>类型为 <codeph>EMBEDDED</codeph> 的字体只能由 TextField 使用。如果指示 flash.text.engine 类使用这种字体，则这些类将使用备用的设备字体。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/embedFonts"><linktext>TextField.embedFonts</linktext></link></related-links></apiValue><apiValue id="flash.text:FontType:EMBEDDED_CFF"><apiName>EMBEDDED_CFF</apiName><shortdesc>
		 指示这是一种嵌入 CFF 字体。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>embeddedCFF</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示这是一种嵌入 CFF 字体。字体轮廓和 OpenType 表的一个子集已嵌入到已发布的 SWF 文件中。
		 
		 <p>使用嵌入 CFF 字体的文本始终以选择的字体显示，而不管播放系统上是否安装了该字体。另外，Flash Player 始终对使用嵌入 CFF 字体的文本进行消除锯齿（平滑）处理。您可以使用 <codeph>flash.text.engine.FontDescription.renderingMode</codeph> 和 <codeph>flash.text.engine.FontDescription.cffHinting</codeph> 属性来选择呈现模式和嵌入 CFF 字体的提示。</p>
		 
		 <p>嵌入 CFF 字体的一个缺点是它们增加了 SWF 文件的大小。不过，嵌入 CFF 字体通常比普通的嵌入字体小 20% 到 30%。</p>
		 
		 <p>类型为 <codeph>EMBEDDED_CFF</codeph> 的字体只能由 flash.text.engine 类使用。要求使用这种字体的 TextField 将无法呈现。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFormatAlign"><apiName>TextFormatAlign</apiName><shortdesc>
 TextFormatAlign 类为 TextFormat 类中的文本对齐方式提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 TextFormatAlign 类为 TextFormat 类中的文本对齐方式提供值。
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link></related-links><apiValue id="flash.text:TextFormatAlign:CENTER"><apiName>CENTER</apiName><shortdesc>
	 常数；在文本字段内将文本居中对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>center</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 常数；在文本字段内将文本居中对齐。使用语法 <codeph>TextFormatAlign.CENTER</codeph>。
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:JUSTIFY"><apiName>JUSTIFY</apiName><shortdesc>
	 常数；在文本字段内将文本两端对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>justify</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 常数；在文本字段内将文本两端对齐。使用语法 <codeph>TextFormatAlign.JUSTIFY</codeph>。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
	 常数；在文本字段内将文本左对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>left</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 常数；在文本字段内将文本左对齐。使用语法 <codeph>TextFormatAlign.LEFT</codeph>。
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
	 常数；在文本字段内将文本右对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>right</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 常数；在文本字段内将文本右对齐。使用语法 <codeph>TextFormatAlign.RIGHT</codeph>。
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:Font"><apiName>Font</apiName><shortdesc>
 Font 类可用来管理 SWF 文件中的嵌入字体。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Font 类可用来管理 SWF 文件中的嵌入字体。嵌入字体表示为 Font 类的子类。Font 类当前只适用于查找有关嵌入字体的信息，您无法使用此类来更改字体。无法单独使用 Font 类来加载外部字体，或创建 Font 对象的实例。Font 类用作抽象基类。
 
 </apiDesc></apiClassifierDetail><apiOperation id="flash.text:Font:enumerateFonts"><apiName>enumerateFonts</apiName><shortdesc> 
    指定是否提供当前可用嵌入字体列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>一个作为 Font 对象数组的可用字体列表。
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>enumerateDeviceFonts</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指示是否要将列表限制为仅当前可用的嵌入字体。如果设置为 <codeph>true</codeph>，则返回一个包括所有字体（设备字体和嵌入字体）的列表。如果设置为 <codeph>false</codeph>，则返回一个只包括嵌入字体的列表。
        </apiDesc></apiParam></apiOperationDef><apiDesc> 
    指定是否提供当前可用嵌入字体列表。
        </apiDesc><example conref="examples\Font.enumerateFonts.1.as"> 此示例首先调用静态方法 <codeph>Font.enumerateFonts()</codeph> 来获取包括所有设备字体和嵌入字体的列表。然后此示例按 <codeph>fontName</codeph> 属性对生成的 Array 的 Font 对象进行排序。
 
 <p>接下来，此示例显示如何调用 <codeph>enumerateDeviceFonts</codeph> 参数设置为 false 时的 <codeph>Font.enumerateFonts()</codeph> 方法。生成的 Array 只包括嵌入的 Font 对象。（如果在不包含任何嵌入字体的应用程序中运行此代码，则 <codeph>embeddedFonts</codeph> 数组将为空。）</p>
<codeblock>
 
import flash.text.Font;

var allFonts:Array = Font.enumerateFonts(true);
allFonts.sortOn("fontName", Array.CASEINSENSITIVE);

var embeddedFonts:Array = Font.enumerateFonts(false);
embeddedFonts.sortOn("fontName", Array.CASEINSENSITIVE);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:Font:hasGlyphs"><apiName>hasGlyphs</apiName><shortdesc> 
        指定能否使用当前指定的字体显示提供的字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果可使用此字体完全显示指定的字符串，则值为 <codeph>true</codeph>。
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要针对当前字体进行测试的字符串。
        </apiDesc></apiParam></apiOperationDef><apiDesc> 
        指定能否使用当前指定的字体显示提供的字符串。
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:Font:registerFont"><apiName>registerFont</apiName><shortdesc> 
	在全局字体列表中注册一个字体类。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>font</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiDesc>要添加到全局字体列表中的类。
	</apiDesc></apiParam></apiOperationDef><apiDesc> 
	在全局字体列表中注册一个字体类。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.text:Font:fontName:get"><apiName>fontName</apiName><shortdesc> 
	嵌入字体的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	嵌入字体的名称。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:Font:fontStyle:get"><apiName>fontStyle</apiName><shortdesc> 
	字体的样式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	字体的样式。此值可以是 FontStyle 类中定义的任何值。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#FontStyle"><linktext>flash.text.FontStyle</linktext></link></related-links></apiValue><apiValue id="flash.text:Font:fontType:get"><apiName>fontType</apiName><shortdesc> 
	字体的类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	字体的类型。此值可以是 FontType 类中定义的任何常数。
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#FontType"><linktext>flash.text.FontType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextRenderer"><apiName>TextRenderer</apiName><shortdesc>
 TextRenderer 类提供了嵌入字体的高级消除锯齿功能。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>-- Class sample changed due to bug 193833
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>控制嵌入字体的消除锯齿。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 TextRenderer 类提供了嵌入字体的高级消除锯齿功能。使用高级消除锯齿功能时，即使字号很小，也能使字型达到极高的呈现品质。对需要显示大量小字的应用程序使用高级消除锯齿功能。Adobe 建议不要对非常大（大于 48 磅）的字体使用高级消除锯齿功能。高级消除锯齿功能仅适用于 Flash Player 8 和更高版本。
 
 <p>要在文本字段上设置高级消除锯齿功能，请设置 TextField 实例的 <codeph>antiAliasType</codeph> 属性。</p>
 
 <p>高级消除锯齿功能提供连续笔触调制 (CSM)，它是笔触粗细和边缘清晰度的连续调制。作为一种高级功能，您可以使用 <codeph>setAdvancedAntiAliasingTable()</codeph> 方法定义特定字体和字体大小的设置。</p>
 
 </apiDesc><example conref="examples\TextRendererExample2.as"> 下面的示例创建 TextRendererExample 类，以演示对小号和大号字体大小应用高级消除锯齿设置的视觉示例。在测试该示例前，需要先嵌入字体。如果使用的是 Flex，则使用以下方法嵌入字体：
 <ol>
    <li>将名为 georgia.ttf 的 Georgia 字体放在与该 AS 文件相同的目录中。</li>
    <li>在类定义下面直接添加以下代码行：</li>
    <li><codeph>[Embed(source="georgia.ttf", fontFamily="Georgia")]</codeph></li>
    <li><codeph>private var embeddedFont:String;</codeph></li>
 </ol>
 如果使用的是 Flash，则使用以下方法嵌入字体：
 <ol>
     <li>在舞台上放置一文本字段并将其选中。</li>
     <li>在“属性”检查器中，将该文本字段的字体设置为 Georgia</li>
     <li>在“属性”检查器中，按“嵌入...”并选择“全部”</li>
 </ol>
 <p> <b>注意：</b>
  <ul>
     <li>您需要编译 SWF 文件，将“本地回放安全性”设置为“只访问本地文件”。</li>
    </ul>
 </p>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.text.*;
    
    public class TextRendererExample2 extends Sprite {

        private var gutter:int = 10;

        public function TextRendererExample2() {
            createTextField(8,AntiAliasType.NORMAL);
            createTextField(8,AntiAliasType.ADVANCED);
            createTextField(24,AntiAliasType.NORMAL);
            createTextField(24,AntiAliasType.ADVANCED);
        }
            
        private function createTextField(fontSize:Number,antiAliasType:String):TextField {
            var tf:TextField = new TextField();
            tf.embedFonts = true;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.antiAliasType = antiAliasType;
            tf.defaultTextFormat = getTextFormat(fontSize);
            tf.selectable = false;
            tf.mouseEnabled = true;
            tf.text = "The quick brown fox jumped over the lazy dog.";
            if(numChildren > 0) {
                var sibling:DisplayObject = getChildAt(numChildren - 1);
                tf.y = sibling.y + sibling.height + gutter;
            }
            addChild(tf);
            return tf;
        }
        
        private function getTextFormat(fontSize:Number):TextFormat {
            var format:TextFormat = new TextFormat();
            format.size = fontSize;
            format.font = "Georgia";
            return format;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links><apiOperation id="flash.text:TextRenderer:setAdvancedAntiAliasingTable"><apiName>setAdvancedAntiAliasingTable</apiName><shortdesc>
	 设置字体的自定义连续笔触调制 (CSM) 查找表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates two anti-alias entries and two text fields to 
	 illustrate them. For this example to work, the SWF file must have a shared font embedded with a linkage identifier of <code>
	 "myArial"</code>. 
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library.</li>
	 <li>Click the Library options menu in the upper-right corner of the Library.</li>
	 <li>Select New Font from the pop-up menu.</li>
	 <li>Name the font <b>myArial</b>.</li>
	 <li>Select Arial from the font pop-up menu.</li>
	 <li>Click OK.</li>
	 <li>Right-click the newly created font, and select Linkage.</li>
	 <li>Select the Export for ActionScript check box.</li>
	 <li>Click OK to accept the default identifier, myArial.</li>
	 </ol>
	 
	 <listing version="2.0">
	 import flash.text.TextRenderer;
	 
	 var antiAliasEntry_1 = {fontSize:24, insideCutoff:1.61, outsideCutoff:-3.43};
	 var antiAliasEntry_2 = {fontSize:48, insideCutoff:0.8, outsideCutoff:-0.8};
	 var arialTable:Array = new Array(antiAliasEntry_1, antiAliasEntry_2);
	 
	 var lbl_1:TextField = createLabel(0, 0, 300, 100, 24);
	 var lbl_2:TextField = createLabel(0, 100, 300, 100, 48);
	 
	 TextRenderer.setAdvancedAntiAliasingTable("Arial", "none", "dark", arialTable);
	 
	 function createLabel(x:Number, y:Number, width:Number, height:Number, fontSize:Number):TextField {
	 var depth:Number = this.getNextHighestDepth();
	 
	 var tmpTxt = this.createTextField("txt_" + depth, depth, x, y, width, height);
	 tmpTxt.antiAliasType = "advanced";
	 tmpTxt.gridFitType = "pixel";
	 tmpTxt.border = true;
	 tmpTxt.text = "Hello World";
	 tmpTxt.embedFonts = true;
	 tmpTxt.setTextFormat(getTextFormat(fontSize));
	 return tmpTxt;
	 }
	 
	 function getTextFormat(fontSize:Number):TextFormat {
	 	var tf:TextFormat = new TextFormat();
	 	tf.align = "center";
	 	tf.size = fontSize;
	 	tf.font = "myArial";
	 	return tf;
	 }
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>fontName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要为其应用设置的字体的名称。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fontStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>使用 flash.text.FontStyle 类中某个值指示的字体样式。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>此值确定了笔触是深色还是浅色的。使用 flash.text.TextColorType 类中的一个值。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>advancedAntiAliasingTable</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>一个数组，由一个或多个指定字体的 CSMSettings 对象组成。每个对象都包含下列属性：
	 
	 <ul>
	 
	   <li><codeph>fontSize</codeph></li>
	   <li><codeph>insideCutOff</codeph></li>
	   <li><codeph>outsideCutOff</codeph></li>
	 
	 </ul>
	 
	 <p><codeph>advancedAntiAliasingTable</codeph> 数组可以包含指定不同字体大小的 CSM 设置的多个条目。</p>
	 
	 <p><codeph>fontSize</codeph> 是设置所应用的大小，以像素为单位。</p>
	 
	 <p>高级消除锯齿功能使用自适应采样距离字段 (ADF) 表示确定字型的轮廓。Flash Player 使用外侧截止值 <codeph>outsideCutOff</codeph>（在该值之下密度设置为 0）和内侧截止值 <codeph>insideCutOff</codeph>（在该值之上密度设置为最大密度值（如 255））。在这两个截止值之间，映射函数是其范围从外侧截止处的 0 到内侧截止处最大密度的线性曲线。</p>
	 
	 <p>调整外侧截止值和内侧截止值会影响笔触粗细和边缘清晰度。这两个参数之间的间距相当于典型消除锯齿方法的滤镜半径的两倍；较窄的间距提供的边缘更清晰，而较宽的间距提供更柔滑、经过更多过滤的边缘。当间距为 0 时，生成的密度图像为双层位图。在间距非常宽时，生成的密度图像具有类似水彩画的边缘。</p>
	 
	 <p>通常，对于小磅值，用户首选清晰的、高对比边缘，对于动画文本和较大的磅值，用户首选较柔滑的边缘。 </p>
	 
	 <p>外侧截止通常具有负值，内侧截止通常具有正值，而它们的中点通常在 0 附近。通过调整这些参数以使中点向负无穷大移动，将增大笔触粗细；将中点向正无穷大移动将减小笔触粗细。请确保外侧截止值始终小于等于内侧截止值。</p>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 设置字体的自定义连续笔触调制 (CSM) 查找表。Flash Player 尝试检测最佳 CSM 以查找所需字体。如果您不满意 Flash Player 提供的 CSM，可以使用 <codeph>setAdvancedAntiAliasingTable()</codeph> 方法自定义自己的 CSM。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#FontStyle"><linktext>flash.text.FontStyle</linktext></link><link href="flash.text.xml#TextColorType"><linktext>flash.text.TextColorType</linktext></link><link href="flash.text.xml#CSMSettings"><linktext>CSMSettings</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextRenderer:displayMode:get"><apiName>displayMode</apiName><shortdesc> 
	 控制高级消除锯齿文本的呈现。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>"default"
	 </apiDefaultValue></apiValueDef><apiDesc> 
	 控制高级消除锯齿文本的呈现。文本的视觉品质非常主观，虽然 Flash Player 尝试使用最佳设置来满足各种条件，但设计人员也可能为他们的文本选择不同的外观。此外，使用 <codeph>displayMode</codeph>，设计人员可以独立于用户的硬件覆盖 Flash Player 的子像素选择和创建可视一致性。使用 TextDisplayMode 类中的值来设置此属性。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextDisplayMode"><linktext>TextDisplayMode 类</linktext></link></related-links></apiValue><apiValue id="flash.text:TextRenderer:maxLevel:get"><apiName>maxLevel</apiName><shortdesc>
	 高级消除锯齿功能的自适应采样距离字段 (ADF) 的品质级别。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example specifies the <code>maxLevel</code> value for the entire
	 SWF file, and then displays a text field with the value set. For the 
	 text in this example to display correctly, there must be a font symbol available with
	 a linkage identifier of <code>"CustomFont"</code>. 
	 <listing version="2.0">
	 import flash.text.TextRenderer;
	 TextRenderer.maxLevel = 3;
	 
	 var txtFormat:TextFormat = new TextFormat();
	 txtFormat.font = "CustomFont";
	 txtFormat.size = 64;
	 
	 var label:TextField = this.createTextField("label", this.getNextHighestDepth(), 10, 10, 500, 100);
	 label.setNewTextFormat(txtFormat);
	 label.text = "Hello World";
	 label.embedFonts = true;
	 trace("TextRenderer.maxLevel: " + TextRenderer.maxLevel);
	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>4
	 </apiDefaultValue></apiValueDef><apiDesc>
	 高级消除锯齿功能的自适应采样距离字段 (ADF) 的品质级别。可接受的值只有 3、4 和 7。 
	 
	 <p>高级消除锯齿功能使用 ADF 表示确定字型的轮廓。品质越高，ADF 结构所需的缓存空间越多。值 <codeph>3</codeph> 需要的内存量最小，提供的品质也最低。字体越大，所需的缓存空间越多；对于大小为 64 像素的字体，除非品质级别已设置为 <codeph>7</codeph>，否则品质级别将可从 <codeph>3</codeph> 增加到 <codeph>4</codeph> 或从 <codeph>4</codeph> 增加到 <codeph>7</codeph>。</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextLineMetrics"><apiName>TextLineMetrics</apiName><shortdesc>
 TextLineMetrics 类包含文本字段中某行文本的文本位置和度量值的相关信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>包含文本字段中某行文本的文本位置和度量值的相关信息。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 TextLineMetrics 类包含文本字段中<i>某行文本</i>的文本位置和度量值的相关信息。所有度量值均以像素为单位。此类的对象由 <codeph>flash.text.TextField.getLineMetrics()</codeph> 方法返回。
 <p>有关与包含文本行的文本字段相关的度量值（例如，图中的“文本字段高度”度量值），请参阅 flash.text.TextField。 </p>
 
 <p>下图指示了文本字段的点和度量值以及该字段包含的文本行：</p>
 <p>
 <adobeimage alt="演示文本度量的图像" href="../../images/text-metrics.jpg"/></p>
 
 </apiDesc><example conref="examples\TextLineMetricsExample.as"> 下例创建了类 TextLineMetricsExample 和 LineMetricsReader 以通过 XML 对象输出 Flash Player 中的消息。这是使用以下步骤完成的：
 <ol>
  <li>创建名为 <codeph>label</codeph> 的 TextField 类型的属性。</li>
  <li>构造函数调用 <codeph>configureAssets()</codeph>，该构造函数可执行以下操作：
  <ul>
      <li>将舞台的对齐方式设置为靠左上角对齐，且不进行缩放。</li>
      <li>创建新的 TextField 对象，名为 <codeph>label</codeph>。</li>
      <li>启用 <codeph>label</codeph> 的背景并将颜色设置为白色。</li>
      <li>允许 <codeph>label</codeph> 的文本通过自动换行来跨多行。</li>
      <li>将对 <codeph>getLabelText()</codeph> 调用的结果赋给 <codeph>label</codeph> 的 <codeph>text</codeph> 属性。<codeph>getLabelText()</codeph> 方法创建一个 XML 类型的变量并将该变量赋给一个名为 <codeph>body</codeph> 的 XML 节点，该节点填充了一个长句子。</li>
      <li>使用 <codeph>addChild()</codeph> 将 <codeph>label</codeph> 添加到显示列表中。</li>
  </ul>
  </li>
  <li>然后会添加侦听在舞台上执行的 <codeph>resize</codeph> 事件的方法，方法名为 <codeph>resizeHandler()</codeph>。每次更改 Flash Player 窗口大小时，都会分派 <codeph>RESIZE</codeph> 事件，并执行以下操作： 
  <ul>
      <li>调用 <codeph>draw()</codeph> 以确保 <codeph>label</codeph> 显示在舞台的中央，并在四周各留出 10 像素的缓冲距离。</li>
      <li><codeph>setTimeout()</codeph> 然后在短暂的延迟后执行 <codeph>showMetrics()</codeph>。添加延迟的原因是，在 <codeph>RESIZE</codeph> 事件完成并且舞台被完全重绘以前，行度量不会更新。</li>
      <li><codeph>showMetrics()</codeph> 将名为 <codeph>metrics</codeph> 的 TextLineMetrics 变量赋给对 <codeph>getLineMetrics()</codeph> 的调用结果，然后将此变量传递给 LineMetricsReader 实例的新实例，新实例名为 <codeph>reader</codeph>。然后，在对 <codeph>trace()</codeph> 的调用中使用这两个变量，以输出 <codeph>label</codeph> 的第一行（只有这一行）和由 LineMetricsReader 实例通过其 <codeph>toString()</codeph> 方法提供的信息。</li>
  </ul>
  </li>
  <li>构造函数强制 <codeph>resize</codeph> 事件的一次分派，以便在第一次加载 SWF 文件时迫使 <codeph>label</codeph> 绘制正确。</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.text.TextField;
    import flash.text.TextLineMetrics;
    import flash.utils.setTimeout;

    public class TextLineMetricsExample extends Sprite {
        private var gutter:int = 10;
        private var label:TextField;

        public function TextLineMetricsExample() {
            configureAssets();
            configureListeners();
            resizeHandler(new Event(Event.RESIZE));
        }

        private function showMetrics():void {
            var metrics:TextLineMetrics = label.getLineMetrics(0);
            var reader:LineMetricsReader = new LineMetricsReader(metrics);
            trace("lineText: " + label.getLineText(0));
            trace("metrics: " + reader);
        }

        private function configureAssets():void {
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;

            label = new TextField();
            label.background = true;
            label.backgroundColor = 0xFFFFFF;
            label.multiline = true;
            label.wordWrap = true;
            label.text = getLabelText();
            addChild(label);
        }

        private function configureListeners():void {
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function resizeHandler(event:Event):void {
            draw();
            setTimeout(showMetrics, 100);
        }

        private function draw():void {
            label.x = gutter;
            label.y = gutter;
            label.width = stage.stageWidth - (gutter * 2);
            label.height = stage.stageHeight - (gutter * 2);
        }

        private function getLabelText():String {
            var text:XML = &lt;body>The Flex product line enables developers to build rich Internet applications that blend the responsiveness of desktop software, the cross-platform reach of the web, and the expressiveness of the Flash Platform.&lt;/body>
            return text.toString();
        }
    }
}

import flash.text.TextLineMetrics;

class LineMetricsReader {
    private var metrics:TextLineMetrics;

    public function LineMetricsReader(metrics:TextLineMetrics) {
        this.metrics = metrics;
    }

    public function toString():String {
        return "[TextLineMetrics ascent:" + metrics.ascent
            + ", descent:" + metrics.descent
            + ", leading:" + metrics.leading
            + ", width:" + metrics.width
            + ", height:" + metrics.height
            + ", x:" + metrics.x
            + "]";
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiConstructor id="flash.text:TextLineMetrics:TextLineMetrics"><apiName>TextLineMetrics</apiName><shortdesc>
	 创建 TextLineMetrics 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>第一个字符的左侧位置，以像素为单位。
	 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>选定行中文本的宽度（并不一定是完整文本），以像素为单位。
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>选定行中文本的高度（并不一定是完整文本），以像素为单位。
	 </apiDesc></apiParam><apiParam><apiItemName>ascent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>从基线到行顶部的长度，以像素为单位。
	 </apiDesc></apiParam><apiParam><apiItemName>descent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>从基线到行底部的长度，以像素为单位。
	 </apiDesc></apiParam><apiParam><apiItemName>leading</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>文本行之间的垂直距离度量值。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>包含文本字段中某行文本的文本位置和度量值的相关信息。
  	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 创建 TextLineMetrics 对象。TextLineMetrics 对象包含文本字段中文本行的相关文本度量信息。此类的对象由 <codeph>flash.text.TextField.getLineMetrics()</codeph> 方法返回。
	 <p>有关上下文中提到的属性，请参阅此类概述部分的插图。</p>
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>TextLineMetrics 类概述</linktext></link><link href="flash.text.xml#TextField/getLineMetrics()"><linktext>flash.text.TextField.getLineMetrics()</linktext></link></related-links></apiConstructor><apiValue id="flash.text:TextLineMetrics:ascent"><apiName>ascent</apiName><shortdesc>
	 文本的上升值是从基线到行高度顶部的长度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>including accents? is it really the line or the font itself?
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 文本的上升值是从基线到行高度顶部的长度，以像素为单位。请参阅此类概述部分的插图中的“上升”度量值。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>TextLineMetrics 类概述</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:descent"><apiName>descent</apiName><shortdesc>
	 文本的下降值是从基线到行深度底部的长度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>is it really the line? or the font itself?
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 文本的下降值是从基线到行深度底部的长度，以像素为单位。请参阅此类概述部分的插图中的“下降”度量值。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>TextLineMetrics 类概述</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:height"><apiName>height</apiName><shortdesc>
	 高度值是选定行中的文本的高度（并不一定是完整文本），以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 高度值是选定行中的文本的高度（并不一定是完整文本），以像素为单位。文本行的高度不包括装订线高度。请参阅此类概述部分的插图中的“行高”度量值。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>TextLineMetrics 类概述</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:leading"><apiName>leading</apiName><shortdesc>
	 前导值是文本行之间的垂直距离的度量值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 前导值是文本行之间的垂直距离的度量值。请参阅此类概述部分的插图中的“前导”度量值。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>TextLineMetrics 类概述</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:width"><apiName>width</apiName><shortdesc>
	 宽度值是选定行中的文本的宽度（并不一定是完整文本），以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 宽度值是选定行中的文本的宽度（并不一定是完整文本），以像素为单位。文本行的宽度与文本字段的宽度不同。文本行的宽度与文本字段的宽度有关，它等于文本字段的宽度减去 4 个像素的装订线宽度（每边 2 个像素）。请参阅此类概述部分的插图中的“文本行宽度”度量值。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>TextLineMetrics 类概述</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:x"><apiName>x</apiName><shortdesc>
	 x 值是第一个字符的左侧位置，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 x 值是第一个字符的左侧位置，以像素为单位。此值包括边距、缩进（如果有）和装订线宽度。请参阅此类概述部分的插图中的“文本行 x 位置”。
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>TextLineMetrics 类概述</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:StyleSheet"><apiName>StyleSheet</apiName><shortdesc>
 使用 StyleSheet 类可以创建包含文本格式设置规则（例如，字体大小、颜色和其它格式样式）的 StyleSheet 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, StyleSheet class, built-in class, style sheet, stylesheet
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>用于创建 StyleSheet 对象。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 StyleSheet 类可以创建包含文本格式设置规则（例如，字体大小、颜色和其它格式样式）的 StyleSheet 对象。然后，可以将样式表定义的样式应用到包含 HTML 或 XML 格式文本的 TextField 对象。根据 StyleSheet 对象定义的标签样式自动设置 TextField 对象中文本的格式。可以使用文本样式来定义新的格式标签，重新定义内置的 HTML 标签，或创建可应用到某些 HTML 标签的样式类。
 
 <p>要对一个 TextField 对象应用样式，请将该 StyleSheet 对象赋给 TextField 对象的 <codeph>styleSheet</codeph> 属性。</p>
 <p><b>注意：</b>具有样式表的文本字段不可编辑。也就是说，<codeph>type</codeph> 属性设置为 <codeph>TextFieldType.INPUT</codeph> 的文本字段会对文本字段的默认文本应用样式表，但用户不再能编辑该内容。考虑使用 TextFormat 类将样式分配给输入文本字段。</p> 
 
 <p>Flash Player 支持原 CSS1 规范 (<xref href="http://www.w3.org/TR/REC-CSS1" scope="external">www.w3.org/TR/REC-CSS1</xref>) 中的部分属性。下表显示受支持的层叠样式表 (CSS) 属性和值，及其相应的 ActionScript 属性名称。（每个 ActionScript 属性名称都是从对应的 CSS 属性名称派生的；如果名称中包含连字符，请省略连字符并将连字符后的字符变成大写。）</p>
 
 <adobetable class="innertable">
 
   
 
   
 
   
 
   
 
   
 
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
 <tgroup cols="3"><thead><row><entry>CSS 属性</entry><entry>ActionScript 属性</entry><entry>用法和支持的值</entry></row></thead><tbody><row>
     <entry><codeph>color</codeph></entry>
     <entry><codeph>color</codeph></entry>
     <entry>只支持十六进制颜色值。不支持具有指定名称的颜色（例如 <codeph>blue</codeph>）。颜色以下面的格式写入：<codeph>#FF0000</codeph>。</entry>
   </row><row>
     <entry><codeph>display</codeph></entry>
     <entry><codeph>display</codeph></entry>
     <entry>受支持的值为 <codeph>inline</codeph>、<codeph>block</codeph> 和 <codeph>none</codeph>。</entry>
   </row><row>
     <entry><codeph>font-family</codeph></entry>
     <entry><codeph>fontFamily</codeph></entry>
     <entry>用逗号分隔的供使用字体的列表，根据需要按降序排列。可以使用任何字体系列名称。如果您指定通用字体名称，它将转换为相应的设备字体。支持以下字体转换：<codeph>mono</codeph> 转换为 <codeph>_typewriter</codeph>，<codeph>sans-serif</codeph> 转换为 <codeph>_sans</codeph>，<codeph>serif</codeph> 转换为 <codeph>_serif</codeph>。</entry>
   </row><row>
     <entry><codeph>font-size</codeph></entry>
     <entry><codeph>fontSize</codeph> </entry>
     <entry>只使用该值的数字部分。不分析单位（px、pt）；像素和磅是等价的。</entry>
   </row><row>
     <entry><codeph>font-style</codeph></entry>
     <entry><codeph>fontStyle</codeph></entry>
     <entry>可识别的值为 <codeph>normal</codeph> 和 <codeph>italic</codeph>。</entry>
   </row><row>
     <entry><codeph>font-weight</codeph></entry>
     <entry><codeph>fontWeight</codeph></entry>
     <entry>可识别的值为 <codeph>normal</codeph> 和 <codeph>bold</codeph>。</entry>
   </row><row>
     <entry><codeph>kerning</codeph></entry>
     <entry><codeph>kerning</codeph></entry>
     <entry>可识别的值为 <codeph>true</codeph> 和 <codeph>false</codeph>。仅对嵌入字体支持字距调整。某些字体（如 Courier New）不支持字距调整。只有 Windows 中创建的 SWF 文件支持 kerning 属性，而 Macintosh 中创建的 SWF 文件不支持该属性。但是，这些 SWF 文件可以在 Flash Player 的非 Windows 版本中播放，并且仍可以应用字距调整。</entry>
   </row><row>
     <entry><codeph>leading</codeph></entry>
     <entry><codeph>leading</codeph></entry>
     <entry>两行之间统一分布的距离。该值指定在每行之后添加的像素数。负值将压缩两行之间的距离。只使用该值的数字部分。不分析单位（px、pt）；像素和磅是等价的。</entry>
   </row><row>
     <entry><codeph>letter-spacing</codeph></entry>
     <entry><codeph>letterSpacing</codeph></entry>
     <entry>两个字符之间统一分布的距离。该值指定在每个字符之后添加的像素数。负值将压缩两个字符之间的距离。只使用该值的数字部分。不分析单位（px、pt）；像素和磅是等价的。</entry>
   </row><row>
     <entry><codeph>margin-left</codeph></entry>
     <entry><codeph>marginLeft</codeph></entry>
     <entry>只使用该值的数字部分。不分析单位（px、pt）；像素和磅是等价的。 </entry>
   </row><row>
     <entry><codeph>margin-right</codeph></entry>
     <entry><codeph>marginRight</codeph></entry>
     <entry>只使用该值的数字部分。不分析单位（px、pt）；像素和磅是等价的。</entry>
   </row><row>
     <entry><codeph>text-align</codeph></entry>
     <entry><codeph>textAlign</codeph></entry>
     <entry>可识别的值为 <codeph>left</codeph>、<codeph>center</codeph>、<codeph>right</codeph> 和 <codeph>justify</codeph>。</entry>
   </row><row>
     <entry><codeph>text-decoration</codeph></entry>
     <entry><codeph>textDecoration</codeph></entry>
     <entry>可识别的值为 <codeph>none</codeph> 和 <codeph>underline</codeph>。</entry>
   </row><row>
     <entry><codeph>text-indent</codeph></entry>
     <entry><codeph>textIndent</codeph></entry>
     <entry>只使用该值的数字部分。不分析单位（px、pt）；像素和磅是等价的。 </entry>
   </row></tbody></tgroup></adobetable> 
 
 <p><ph outputclass="flexonly">可以使用 StyleSheet 类执行低级文本呈现。但是，在 Flex 中，您通常使用 Label、Text、TextArea 和 TextInput 控件来处理文本。</ph></p>
 
 
 </apiDesc><example conref="examples\StyleSheetExample.as"> 下例创建了一个新样式表并将粗体和红色字体处理分配给标题样式。
<codeblock>
 
package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class StyleSheetExample extends Sprite {

        public function StyleSheetExample() {
            var style:StyleSheet = new StyleSheet();

            var heading:Object = new Object();
            heading.fontWeight = "bold";
            heading.color = "#FF0000";

            var body:Object = new Object();
            body.fontStyle = "italic";

            style.setStyle(".heading", heading);
            style.setStyle("body", body);

            var label:TextField = new TextField();
            label.styleSheet = style;
            label.htmlText = "&lt;body>&lt;span class='heading'>Hello &lt;/span>World...&lt;/body>";
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiConstructor id="flash.text:StyleSheet:StyleSheet"><apiName>StyleSheet</apiName><shortdesc>
	 创建新的 StyleSheet 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet, constructor
	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 创建新的 StyleSheet 对象。
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.text.xml#StyleSheet/getStyle()"><linktext>flash.text.StyleSheet.getStyle()</linktext></link></related-links></apiConstructor><apiOperation id="flash.text:StyleSheet:clear"><apiName>clear</apiName><shortdesc>
	 从样式表对象中删除所有样式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.clear, clear
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 从样式表对象中删除所有样式。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:getStyle"><apiName>getStyle</apiName><shortdesc> 
	 返回与名为 styleName 的样式相关联的样式对象的一个副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.getStyle, getStyle
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个对象。
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>styleName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>一个字符串，该字符串指定要检索的样式的名称。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc> 
	 返回与名为 <codeph>styleName</codeph> 的样式相关联的样式对象的一个副本。如果没有与 <codeph>styleName</codeph> 相关联的样式对象，则返回 <codeph>null</codeph>。
	 
	 </apiDesc><example>有关如何使用 <codeph>getStyle()</codeph> 方法的说明，请参阅 <xref href="StyleSheet.html#parseCSS()">parseCSS()</xref> 或 <xref href="StyleSheet.html#transform()">transform()</xref> 方法的示例。 
	 </example></apiOperationDetail><related-links><link href="flash.text.xml#StyleSheet/setStyle()"><linktext>flash.text.StyleSheet.setStyle()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:StyleSheet:parseCSS"><apiName>parseCSS</apiName><shortdesc>
	 分析 CSSText 中的 CSS 并用它加载样式表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.parseCSS, parseCSS
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>CSSText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要分析的 CSS 文本（字符串）。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>分析 cssText 中的 CSS 并用它加载 StyleSheet。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 分析 <codeph>CSSText</codeph> 中的 CSS 并用它加载样式表。如果 <codeph>CSSText</codeph> 中的某个样式在 <codeph>styleSheet</codeph> 中已经存在，则保留 <codeph>styleSheet</codeph> 中的属性，在 <codeph>styleSheet</codeph> 中只添加或更改 <codeph>CSSText</codeph> 中的属性。
	 
	 <p>要扩展本机 CSS 分析功能，可通过创建 StyleSheet 类的子类来覆盖此方法。</p>
	 
	 </apiDesc><example conref="examples\StyleSheet_parseCSSExample.as"> 在下面的示例中，当用户单击文本文件时，则会将从某个文件中加载的 CSS 样式应用于文本文件内容。
 
 <p>在构造函数中，创建了一个多行文本字段，并将其内容设置为 HTML 格式的字符串。（在应用 CSS 样式之前不会呈现 HTML heading 和 span 标签。）将创建一个用于指定 CSS 文件位置的 <codeph>URLRequest</codeph> 对象，就本示例而言，该 CSS 文件与 SWF 文件位于同一个目录中。该文件是使用 <codeph>URLLoader</codeph> 对象加载的。共为 <codeph>loader</codeph> URLLoader 对象添加了两个事件侦听器。如果发生 IO 错误，则会调用 <codeph>errorHandler()</codeph> 方法，它在文本字段中显示一条错误消息。在接收所有数据并将其放在 <codeph>loader</codeph> URLLoader 对象的 data 属性中后，将调用 <codeph>loaderCompleteHandler()</codeph> 方法。此方法分析从文件加载的数据中的 CSS 样式，并使用样式定义填充 <codeph>sheet</codeph> StyleSheet 对象。</p>
 
 <p>当用户单击文本字段时，将调用 <codeph>clickHandler()</codeph> 方法。<codeph>clickHandler()</codeph> 方法中的 if 语句检查以确保在将样式表应用于文本字段之前完成文件加载。为了使样式表生效，在将样式表分配给文本字段后，必须为内容重新分配 <codeph>htmlText</codeph> 属性。还会将 heading 标签的 CSS <codeph>font-family</codeph> 和 <codeph>color</codeph> 属性值附加到文本字段内容中。（如果样式表值无效，则这些属性的值为“undefined”。）</p> 
 
 <p>下面是一个可用于此示例的 CSS 文件内容的示例。在运行此示例之前，请先创建一个文本文件，将下面的 CSS 内容复制到该文件中，然后使用文件名 <codeph>test.css</codeph> 保存该文件，并将其放在与 SWF 文件相同的目录中。</p>
 
 <pre>
   p {
      font-family: Times New Roman, Times, _serif;
      font-size: 14;
       font-Style: italic;
        margin-left: 10;  
   }
   h1 {
      font-family: Arial, Helvetica, _sans;
      font-size: 20;
      font-weight: bold;
   }
   .bluetext {
      color: #0000CC;
   }
 </pre>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.IOErrorEvent;
    import flash.events.Event;
    import flash.events.MouseEvent;

    public class StyleSheet_parseCSSExample extends Sprite {
        private var loader:URLLoader = new URLLoader();
        private var field:TextField = new TextField();
        private var exampleText:String = "&lt;h1>This is a headline&lt;/h1>"
                    + "&lt;p>This is a line of text. &lt;span class='bluetext'>" 
                    + "This line of text is colored blue.&lt;/span>&lt;/p>";
        private var sheet:StyleSheet = new StyleSheet();
        private var cssReady:Boolean = false;

        public function StyleSheet_parseCSSExample() {
            field.x = 10;
            field.y = 10;
            field.background = true;
            field.multiline = true;
            field.autoSize = TextFieldAutoSize.LEFT;
            field.htmlText = exampleText;

            field.addEventListener(MouseEvent.CLICK, clickHandler);
            
            addChild(field);
            
            var req:URLRequest = new URLRequest("test.css");
            loader.load(req);

            loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);
        }

        public function errorHandler(e:IOErrorEvent):void {
            field.htmlText = "Couldn't load the style sheet file.";
        }

        public function loaderCompleteHandler(event:Event):void {
            sheet.parseCSS(loader.data);
            cssReady = true;
        }

        public function clickHandler(e:MouseEvent):void {

            if (cssReady) {
                field.styleSheet = sheet;
                field.htmlText = exampleText;
                
                var style:Object = sheet.getStyle("h1");
                field.htmlText += "&lt;p>Headline font-family is: " + style.fontFamily + "&lt;/p>";
                field.htmlText += "&lt;p>Headline color is: " + style.color + "&lt;/p>";  

            } else {
                field.htmlText = "Couldn't apply the CSS styles.";
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:setStyle"><apiName>setStyle</apiName><shortdesc>
	 将具有指定名称的新样式添加到样式表对象中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example adds a style named <code>emphasized</code> to the 
	 StyleSheet <code>myStyleSheet</code>. The style includes two style properties: <code>color</code> 
	 and <code>fontWeight</code>. The style object is defined with the <code>{}</code> operator.
	 <pre><code>
	 myStyleSheet.setStyle("emphasized", {color:'#000000',fontWeight:'bold'});
	 </code></pre>
	 
	 <p>You could also create a style object using an instance of the Object class, and 
	 then pass that object (<code>styleObj</code>) as 
	 the <code>style</code> parameter, as the next example shows:</p>
	 <listing version="2.0">
	 import TextField.StyleSheet;
	 var my_styleSheet:StyleSheet = new StyleSheet();
	 
	 var styleObj:Object = new Object();
	 styleObj.color = "#000000";
	 styleObj.fontWeight = "bold";
	 my_styleSheet.setStyle("emphasized", styleObj);
	 delete styleObj;
	 
	 var styleNames_array:Array = my_styleSheet.getStyleNames();
	 for (var i=0;i&lt;styleNames_array.length;i++) {
	 	var styleName:String = styleNames_array[i];
	 	var thisStyle:Object = my_styleSheet.getStyle(styleName);
	 	trace(styleName);
	 	for (var prop in thisStyle) {
	 		trace("\t"+prop+": "+thisStyle[prop]);
	 	}
	 	trace("");
	 }
	 </listing>
	 <p><span class="flashonly">The following information appears in the Output 
	 panel:</span><span class="flexonly">The following information writes to the 
	 log file:</span></p>
	 <pre><code>
	 emphasized
	   fontWeight: bold
	   color: #000000
	 </code></pre>
	 
	 <p><strong>Note: </strong>Because Flash Player creates a copy of the style object
	 you pass to <code>setStyle()</code>, the <code> delete styleObj</code> command in the 
	 code example reduces memory usage by deleting the original style object passed to 
	 <code>setStyle()</code>.</p>
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>styleName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>一个字符串，用于指定要添加到样式表中的样式的名称。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>styleObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>一个说明样式的对象，或 <codeph>null</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将具有指定名称的新样式添加到样式表对象中。如果该样式表中没有指定名称的样式，将添加该样式。如果该样式表中已经有指定名称的样式，将替换该样式。如果 <codeph>styleObject</codeph> 参数为 <codeph>null</codeph>，则删除指定名称的样式。
	 
	 <p>Flash Player 将创建传递给此方法的样式对象的一个副本。</p>
	 
	 <p>要获取所支持样式的列表，请参阅 StyleSheet 类说明中的表。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:transform"><apiName>transform</apiName><shortdesc>
	 扩展 CSS 分析功能。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.transform, transform
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个包含 CSS 规则向文本格式属性映射的结果的 TextFormat 对象。
	 
	 </apiDesc><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier></apiReturn><apiParam><apiItemName>formatObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>一个说明样式的对象（包含作为对象属性的样式规则），或 <codeph>null</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 扩展 CSS 分析功能。高级开发人员可通过扩展 StyleSheet 类覆盖此方法。 
	 
	 </apiDesc><example conref="examples\StyleSheet_transformExample.as"> 本示例使用 <codeph>transform()</codeph> 方法将 CSS 文件中的某个样式应用于文本字段的 TextFormat 对象。
 
 <p>CSS 样式通常用于设置 HTML 内容的格式。但是，通过使用 StyleSheet 对象的 <codeph>transform()</codeph> 方法，可以将特定 CSS 样式分配给 TextFormat 对象，然后将其应用于任何文本字段。</p> 
 
 <p>我们使用 <codeph>URLRequest</codeph> 和 <codeph>URLLoader</codeph> 对象来加载 CSS 文件； 为 <codeph>Event.COMPLETE</codeph> 事件添加一个事件侦听器，在接收所有数据并将其放在 <codeph>loader</codeph> URLLoader 对象的 data 属性中后，将会发生该事件。然后，<codeph>loaderCompleteHandler()</codeph> 方法分析从文件加载的数据中的 CSS，并使用这些样式填充 <codeph>sheet</codeph> StyleSheet 对象。样式表的 <codeph>getStyle()</codeph> 方法将检索 HTML 段落样式，然后使用样式表的 <codeph>transform()</codeph> 方法将这些样式分配给 <codeph>cssFormat</codeph> TextFormat 对象。最后，将 <codeph>inputField</codeph> 文本字段的默认文本格式设置为新的 <codeph>cssFormat</codeph> 文本格式。</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldType;
    import flash.events.IOErrorEvent;
    import flash.events.Event;

    public class StyleSheet_transformExample extends Sprite {
        private var loader:URLLoader = new URLLoader();
        private var inputField:TextField = new TextField();
        private var sheet:StyleSheet = new StyleSheet();

        public function StyleSheet_transformExample() {
            inputField.x = 10;
            inputField.y = 10;
            inputField.background = true;
            inputField.width = 300;
            inputField.height = 200;
            inputField.wordWrap = true;
            inputField.multiline = true;    
            inputField.type = TextFieldType.INPUT;

            addChild(inputField);
            
            var req:URLRequest = new URLRequest("test.css");
            loader.load(req);

            loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);
        }

        public function errorHandler(e:IOErrorEvent):void {
            inputField.htmlText = "Couldn't load the style sheet file.";
        }

        public function loaderCompleteHandler(event:Event):void {
            var cssFormat:TextFormat = new TextFormat();
            sheet.parseCSS(loader.data);
            var style:Object = sheet.getStyle("p");
            cssFormat = sheet.transform(style);
            inputField.defaultTextFormat = cssFormat;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link></related-links></apiOperation><apiValue id="flash.text:StyleSheet:styleNames:get"><apiName>styleNames</apiName><shortdesc>
	 一个数组，其中包含此样式表中注册的所有样式的名称（字符串形式）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.getStyleNames, getStyleNames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiTipTexts><apiTipText>返回此 StyleSheet 中注册的所有样式的名称。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 一个数组，其中包含此样式表中注册的所有样式的名称（字符串形式）。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextSnapshot"><apiName>TextSnapshot</apiName><shortdesc> 
 TextSnapshot 对象可用于处理影片剪辑中的静态文本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 TextSnapshot 对象可用于处理影片剪辑中的静态文本。例如，您可以使用 TextSnapshot 对象用高于动态文本所允许的精度对文本进行布局，但仍以只读方式访问该文本。
 
 <p>您不必使用构造函数即可创建 TextSnapshot 对象；它由 <codeph>flash.display.DisplayObjectContainer.textSnapshot</codeph> 属性返回。</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/textSnapshot"><linktext>flash.display.DisplayObjectContainer.textSnapshot</linktext></link></related-links><apiOperation id="flash.text:TextSnapshot:findText"><apiName>findText</apiName><shortdesc>
	 搜索指定的 TextSnapshot 对象，并返回在 beginIndex 位置或其后找到的 textToFind 的第一个匹配项的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.findText, findText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>指定文本的第一个匹配项从零开始的索引位置或 -1。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>指定起始点以搜索指定文本。	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>textToFind</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>指定要搜索的文本。如果指定的是字符串文本，而不是 String 类型的变量，请用引号将字符串括起来。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>caseSensitive</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>指定文本是否必须与 <codeph>textToFind</codeph> 中的字符串大小写相匹配。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 搜索指定的 TextSnapshot 对象，并返回在 <codeph>beginIndex</codeph> 位置或其后找到的 <codeph>textToFind</codeph> 的第一个匹配项的位置。如果未找到 <codeph>textToFind</codeph>，则该方法返回 <codeph>-1</codeph>。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getSelected"><apiName>getSelected</apiName><shortdesc>
	 返回一个布尔值，该值指定 TextSnapshot 对象是否包含指定范围内的所选文本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getSelected, getSelected
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个布尔值，指示对应的 <codeph>setSelected()</codeph> 方法是否已选择了给定范围内的至少一个字符，如果选择了字符，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>指示要检查的第一个字符的位置。<codeph>beginIndex</codeph> 的有效值为 <codeph>0</codeph> 到 <codeph>TextSnapshot.charCount - 1</codeph>。如果 <codeph>beginIndex</codeph> 是一个负值，则使用 <codeph>0</codeph>。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>比要检查的最后一个字符的索引大 1 的一个值。<codeph>endIndex</codeph> 的有效值为 <codeph>0</codeph> 到 <codeph>charCount</codeph>。由 <codeph>endIndex</codeph> 参数索引的字符未包括在已提取的字符串中。如果省略此参数，则使用 <codeph>charCount</codeph>。如果此值小于等于 <codeph>beginIndex</codeph> 的值，则使用 <codeph>beginIndex + 1</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回一个布尔值，该值指定 TextSnapshot 对象是否包含指定范围内的所选文本。 
	 
	 <p>要搜索全部字符，请将值 <codeph>0</codeph> 传递给 <codeph>start</codeph>，并将 <codeph>charCount</codeph>（或任何非常大的数字）传递给 <codeph>end</codeph>。要搜索一个字符，请传递给 <codeph>end</codeph> 参数一个比 <codeph>start</codeph> 参数大 1 的值。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link><link href="flash.text.xml#TextSnapshot/getSelectedText()"><linktext>flash.text.TextSnapshot.getSelectedText()</linktext></link><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getSelectedText"><apiName>getSelectedText</apiName><shortdesc>
	 返回一个字符串，其中包含对应的 setSelected() 方法指定的所有字符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getSelectedText, getSelectedText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个字符串，其中包含对应的 <codeph>setSelected()</codeph> 命令指定的所有字符。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>includeLineEndings</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>一个可选的布尔值，用于指定是否将换行符插入到返回字符串中的合适位置。默认值为 <codeph>false</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回一个字符串，其中包含对应的 <codeph>setSelected()</codeph> 方法指定的所有字符。如果没有指定任何字符（由 <codeph>setSelected()</codeph> 方法指定），则返回一个空字符串。
	 
	 <p>如果将 <codeph>true</codeph> 传递给 <codeph>includeLineEndings</codeph>，则换行符将插入到返回字符串中，因此该返回字符串可能比输入范围长。如果 <codeph>includeLineEndings</codeph> 为 <codeph>false</codeph> 或被省略，则该方法返回没有添加任何字符的选定文本。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/getSelected()"><linktext>flash.text.TextSnapshot.getSelected()</linktext></link><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getText"><apiName>getText</apiName><shortdesc>
	 返回一个字符串，其中包含 beginIndex 和 endIndex 参数指定的所有字符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getText, getText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个包含指定范围内字符的字符串，如果在指定范围内未找到任何字符，则为一个空字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>指示要包括在返回字符串中的第一个字符的位置。<codeph>beginIndex</codeph> 的有效值为 <codeph>0</codeph> 到 <codeph>charCount - 1</codeph>。如果 <codeph>beginIndex</codeph> 是一个负值，则使用 <codeph>0</codeph>。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>比要检查的最后一个字符的索引大 1 的一个值。<codeph>endIndex</codeph> 的有效值为 <codeph>0</codeph> 到 <codeph>charCount</codeph>。由 <codeph>endIndex</codeph> 参数索引的字符未包括在已提取的字符串中。如果省略此参数，则使用 <codeph>charCount</codeph>。如果此值小于等于 <codeph>beginIndex</codeph> 的值，则使用 <codeph>beginIndex + 1</codeph>。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>includeLineEndings</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>一个可选的布尔值，指定是将换行符插入到返回的字符串中 (<codeph>true</codeph>)，还是不插入到返回的字符串中 (<codeph>false</codeph>)。默认值为 <codeph>false</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回一个字符串，其中包含 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 参数指定的所有字符。如果没有选择任何字符，则返回一个空字符串。 
	 
	 <p>要返回全部字符，请将值 <codeph>0</codeph> 传递给 <codeph>beginIndex</codeph>，并将 <codeph> charCount</codeph>（或任何非常大的数字）传递给 <codeph>endIndex</codeph>。要返回单个字符，请将值 <codeph>beginIndex + 1</codeph> 传递给 <codeph>endIndex</codeph>。 </p>
	 
	 <p>如果将值 <codeph>true</codeph> 传递给 <codeph>includeLineEndings</codeph>，则将换行符插入到返回字符串中认为合适的位置。在这种情况下，返回字符串可能比输入范围长。如果 <codeph>includeLineEndings</codeph> 为 <codeph>false</codeph> 或被省略，则返回所选文本，且不添加任何字符。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/getSelectedText()"><linktext>flash.text.TextSnapshot.getSelectedText()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getTextRunInfo"><apiName>getTextRunInfo</apiName><shortdesc>
	 返回包含关于文本运行信息的对象的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个对象数组，其中的每个对象都包含有关由 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 参数指定的字符范围中特定字符的信息。每个对象都包含以下 11 种属性：
	 <ul>
	 
	  	<li><codeph>indexInRun</codeph>：字符相对于整个字符串（而不是相对于所选运行文本）的从零开始的整数索引。</li>
	 
	  	<li><codeph>selected</codeph>：一个布尔值，指示是否选中字符。如果选中，则该值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。</li>
	 
	  	<li><codeph>font</codeph>：字符的字体名称。</li>
	 
	  	<li><codeph>color</codeph>：字符的 Alpha 和颜色的合并值。前两个十六进制数字表示 Alpha 值，其余数字表示颜色值。</li>
	 
	  	<li><codeph>height</codeph>：字符的高度，以像素为单位。</li>
	 
	  	<li><codeph>matrix_a</codeph>、<codeph>matrix_b</codeph>、<codeph>matrix_c</codeph>、<codeph>matrix_d</codeph>、<codeph>matrix_tx</codeph> 和 <codeph>matrix_ty</codeph>：矩阵的值，该矩阵对字符定义几何转换。通常，立式文本始终具有形式为 <codeph>[1 0 0 1 x y]</codeph> 的矩阵，其中 <codeph>x</codeph> 和 <codeph>y</codeph> 是字符在父级影片剪辑内的位置，与文本的高度无关。该矩阵位于父级影片剪辑坐标系统中，并且不包括对影片剪辑本身（或其父级）的任何转换。 </li>
	 
	 	<li><codeph>corner0x</codeph>、<codeph>corner0y</codeph>、<codeph>corner1x</codeph>、<codeph>corner1y</codeph>、<codeph>corner2x</codeph>、<codeph>corner2y</codeph>、<codeph>corner3x</codeph> 和 <codeph>corner3y</codeph>：字符边框的各个角，以父级影片剪辑的坐标系统为基础。这些值仅在字符使用的字体嵌入到 SWF 文件时可用。</li>
	 
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>TextSnapshot 对象中字符范围内第一个字符的索引值。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>TextSnapshot 对象中字符范围内最后一个字符的索引值。
	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回包含关于文本运行信息的对象的数组。每个对象都与两个方法参数指定的字符范围中的一个字符相对应。 
	 
	 <p><b>注意：</b>对于大范围的文本，使用 <codeph>getTextRunInfo()</codeph> 方法可以返回一个较大的对象。Adobe 建议限制由 <codeph>beginIndex</codeph> 和 <codeph>endIndex</codeph> 参数定义的文本范围。 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>Matrix 类</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:hitTestTextNearPos"><apiName>hitTestTextNearPos</apiName><shortdesc>
	 用于确定 TextSnapshot 对象中哪个字符位于包含 TextSnapshot 对象中文本的影片剪辑的指定的 x, y 坐标上或位于该坐标的附近。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.hitTestTextNearPos, hitTestTextNearPos
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个数字，表示最接近指定 <codeph>x</codeph>, <codeph>y</codeph> 坐标的字符的索引值。如果未找到任何字符，或者字体不包含字符度量信息，则返回 <codeph>-1</codeph>。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，表示包含文本的影片剪辑的 <codeph>x</codeph> 坐标。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，表示包含文本的影片剪辑的 <codeph>y</codeph> 坐标。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>maxDistance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>一个可选数字，表示距 <codeph>x</codeph>, <codeph>y</codeph>（搜索其可查找文本）的最远距离。此距离是从每个字符的中心点开始测量的。默认值为 <codeph>0</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 用于确定 TextSnapshot 对象中哪个字符位于包含 TextSnapshot 对象中文本的影片剪辑的指定的 <codeph>x</codeph>, <codeph>y</codeph> 坐标上或位于该坐标的附近。
	 
	 <p>如果省略 <codeph>maxDistance</codeph> 或为其传递值 <codeph>0</codeph>，则由 <codeph>x</codeph>, <codeph>y</codeph> 坐标指定的位置必须位于 TextSnapshot 对象的边框内。 
	 </p>
	 
	 <p>此方法仅适用于包括字符度量信息的字体；但是，默认情况下，Flash 创作工具不包含静态文本字段的这种信息。<ph outputclass="flashonly">因此，该方法可能会返回 <codeph>-1</codeph> 而不是索引值。为了确保返回索引值，您可以强制使 Flash 创作工具包括字体的字符度量信息。为此，请添加一个使用此字体的动态文本字段，为该动态文本字段选择“字符选项”，然后指定至少为一个字符嵌入该字体轮廓。（这与所指定的字符以及是否在静态文本字段中使用这些字符没有关系。）</ph></p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/x"><linktext>flash.display.DisplayObject.x</linktext></link><link href="flash.display.xml#DisplayObject/y"><linktext>flash.display.DisplayObject.y</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:setSelectColor"><apiName>setSelectColor</apiName><shortdesc>
	 指定当突出显示使用 setSelected() 方法选择的字符时要使用的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.setSelectColor, setSelectColor
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>hexColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFF00</apiData><apiDesc>用于字符（这些字符已被对应的 <codeph>setSelected()</codeph> 命令选中）旁边边框的颜色，以十六进制格式 (0x<i>RRGGBB</i>) 表示。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定当突出显示使用 <codeph> setSelected()</codeph> 方法选择的字符时要使用的颜色。该颜色始终是不透明的；您不能指定透明值。
	 
	 <p>此方法仅适用于包括字符度量信息的字体；但是，默认情况下，Flash 创作工具不包含静态文本字段的这种信息。因此，该方法可能会返回 <codeph>-1</codeph> 而不是索引值。<ph outputclass="flashonly">为了确保返回索引值，您可以强制使 Flash 创作工具包括字体的字符度量信息。为此，请添加一个使用此字体的动态文本字段，为该动态文本字段选择“字符选项”，然后指定至少为一个字符嵌入该字体轮廓。（这与所指定的字符以及是否在静态文本字段中使用这些字符没有关系。）</ph></p>	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:setSelected"><apiName>setSelected</apiName><shortdesc>
	 指定 TextSnapshot 对象中要选择或取消选择的字符范围。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.setSelected, setSelected
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>指示要选择的第一个字符的位置。<codeph>beginIndex</codeph> 的有效值为 <codeph>0</codeph> 到 <codeph>charCount - 1</codeph>。如果 <codeph>beginIndex</codeph> 是一个负值，则使用 <codeph>0</codeph>。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个整数，它等于要检查的最后一个字符的索引加 1。<codeph>end</codeph> 的有效值为 <codeph>0</codeph> 到 <codeph>charCount</codeph>。由 <codeph>end</codeph> 参数索引的字符未包括在已提取的字符串中。如果省略此参数，则使用 <codeph>TextSnapshot.charCount</codeph>。如果 <codeph>beginIndex</codeph> 的值小于等于 <codeph>endIndex</codeph> 的值，则使用 <codeph>beginIndex + 1</codeph>。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>select</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>一个布尔值，指定是应该选择文本 (<codeph>true</codeph>)，还是应该取消选择文本 (<codeph>false</codeph>)。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定 TextSnapshot 对象中要选择或取消选择的字符范围。被选中的字符的后面绘制有一个带颜色的矩形，与字符的边框匹配。边框的颜色由 <codeph>setSelectColor()</codeph> 定义。
	 
	 <p>要选择或取消选择所有字符，请将值 <codeph>0</codeph> 传递给 <codeph>beginIndex</codeph>，并将 <codeph>charCount</codeph>（或任何一个非常大的数字）传递给 <codeph>endIndex</codeph>。要指定单个字符，请将值 <codeph>start + 1</codeph> 传递给 <codeph>endIndex</codeph>。 </p>
	 
	 <p>因为在选择时，字符是单个地进行标记的，所以您可以多次调用此方法以选择多个字符；也就是说，使用此方法不会取消选择已由此方法设置的其它字符。</p>
	 
	 <p>只针对包含字符度量信息的字体显示表明选中的彩色矩形；默认情况下，Flash 不包含静态文本字段的这种信息。在某些情况下，此行为意味着选中的文本在屏幕上不会显示为已选中。<ph outputclass="flashonly">为了确保所有选中的文本都显示为已选中，您可以强制使 Flash 创作工具包括字体的字符度量信息。为此，请添加一个使用此字体的动态文本字段，为该动态文本字段选择“字符选项”，然后指定至少为一个字符嵌入该字体轮廓。这与所指定的字符以及是否在所述静态文本字段中使用这些字符没有关系。</ph></p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/setSelectColor()"><linktext>flash.text.TextSnapshot.setSelectColor()</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextSnapshot:charCount:get"><apiName>charCount</apiName><shortdesc>
	 TextSnapshot 对象中的字符数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.charCount, charCount, count
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 TextSnapshot 对象中的字符数。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFieldAutoSize"><apiName>TextFieldAutoSize</apiName><shortdesc>
TextFieldAutoSize 类是在设置 TextField 类的 autoSize 属性时使用的常数值的枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
TextFieldAutoSize 类是在设置 TextField 类的 <codeph>autoSize</codeph> 属性时使用的常数值的枚举。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/autoSize"><linktext>flash.text.TextField.autoSize</linktext></link></related-links><apiValue id="flash.text:TextFieldAutoSize:CENTER"><apiName>CENTER</apiName><shortdesc> 
	指定将文本视为居中对齐文本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>center</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	指定将文本视为居中对齐文本。调整单个文本字段行，使其在左右边距之间均衡分布。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:LEFT"><apiName>LEFT</apiName><shortdesc> 
	指定将文本视为左对齐文本，即文本字段的左侧固定不变，只在右侧调整单行的大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>left</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	指定将文本视为左对齐文本，即文本字段的左侧固定不变，只在右侧调整单行的大小。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:NONE"><apiName>NONE</apiName><shortdesc> 
	
	指定不调整大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	
	指定不调整大小。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:RIGHT"><apiName>RIGHT</apiName><shortdesc> 
	指定将文本视为右对齐文本，即文本字段的右侧固定不变，只在左侧调整单行的大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>right</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	指定将文本视为右对齐文本，即文本字段的右侧固定不变，只在左侧调整单行的大小。 
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:FontStyle"><apiName>FontStyle</apiName><shortdesc>
FontStyle 类提供 TextRenderer 类的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
FontStyle 类提供 TextRenderer 类的值。

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer"><linktext>flash.text.TextRenderer</linktext></link></related-links><apiValue id="flash.text:FontStyle:BOLD"><apiName>BOLD</apiName><shortdesc>
    为 setAdvancedAntiAliasingTable() 方法中的 fontStyle 参数定义粗体样式的字体。</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bold</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    为 <codeph>setAdvancedAntiAliasingTable()</codeph> 方法中的 <codeph>fontStyle</codeph> 参数定义粗体样式的字体。使用语法 <codeph>FontStyle.BOLD</codeph>。
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:BOLD_ITALIC"><apiName>BOLD_ITALIC</apiName><shortdesc>
    为 setAdvancedAntiAliasingTable() 方法中的 fontStyle 参数定义粗体和斜体样式的字体。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>boldItalic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    为 <codeph>setAdvancedAntiAliasingTable()</codeph> 方法中的 <codeph>fontStyle</codeph> 参数定义粗体和斜体样式的字体。使用语法 <codeph>FontStyle.BOLD_ITALIC</codeph>。
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:ITALIC"><apiName>ITALIC</apiName><shortdesc>
    为 setAdvancedAntiAliasingTable() 方法中的 fontStyle 参数定义斜体样式的字体。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>italic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    为 <codeph>setAdvancedAntiAliasingTable()</codeph> 方法中的 <codeph>fontStyle</codeph> 参数定义斜体样式的字体。使用语法 <codeph>FontStyle.ITALIC</codeph>。
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:REGULAR"><apiName>REGULAR</apiName><shortdesc>
    为 setAdvancedAntiAliasingTable() 方法中的 fontStyle 参数定义不带样式的字体。</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>regular</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    为 <codeph>setAdvancedAntiAliasingTable()</codeph> 方法中的 <codeph>fontStyle</codeph> 参数定义不带样式的字体。使用语法 <codeph>FontStyle.REGULAR</codeph>。 
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFieldType"><apiName>TextFieldType</apiName><shortdesc>
TextFieldType 类是在设置 TextField 类的 type 属性时使用的常数值的枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
TextFieldType 类是在设置 TextField 类的 <codeph>type</codeph> 属性时使用的常数值的枚举。 


</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/type"><linktext>flash.text.TextField.type</linktext></link></related-links><apiValue id="flash.text:TextFieldType:DYNAMIC"><apiName>DYNAMIC</apiName><shortdesc> 
	用于指定 dynamic TextField。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>dynamic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	用于指定 <codeph>dynamic</codeph> TextField。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldType:INPUT"><apiName>INPUT</apiName><shortdesc> 
	用于指定 input TextField。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>input</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	用于指定 <codeph>input</codeph> TextField。 
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>