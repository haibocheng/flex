<?xml version="1.0"?>
<apiPackage id="flash.utils"><apiName>flash.utils</apiName><apiDetail/><apiClassifier id="flash.utils:Proxy"><apiName>Proxy</apiName><shortdesc>
 Proxy 类用于覆盖对象的 ActionScript 操作（如检索和修改属性）的默认行为。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Proxy 类用于覆盖对象的 ActionScript 操作（如检索和修改属性）的默认行为。
 
 <p>Proxy 类没有构造函数，您不应尝试实例化 Proxy。而是应使用 Proxy 类的子类来覆盖诸如 <codeph>getProperty</codeph> 之类的方法并提供自定义行为。如果尝试使用 Proxy 类的某个方法而不覆盖该方法，则会引发异常。</p>
 <p>同时请记住，您自己的用于覆盖 Proxy 类的方法的代码也可能会意外引发异常。在使用这些方法时引发异常会导致问题，因为调用代码（使用诸如 <codeph>in</codeph>、<codeph>is</codeph> 和 <codeph>delete</codeph> 等运算符）不应该有异常。除非已经确信您的覆盖方法不会引发异常，否则 Adobe 建议在实现 Proxy 类的前后使用 <codeph>try..catch</codeph> 语句，以避免在运算符调用您的方法时出现致命错误。例如： </p> 
 <codeblock>
 dynamic class MyProxy extends Proxy {
     flash_proxy override function callProperty(name:~~, ...rest):~~ {
       try {
         // custom code here
       }
       catch (e:Error) {
         // respond to error here
       }
 }   
 </codeblock>
 
 <p>Proxy 类取代了 ActionScript 2.0 的 <codeph>Object.__resolve</codeph> 和 <codeph>Object.addProperty</codeph> 功能，ActionScript 3.0 中不再提供这些功能。利用 <codeph>Object.addProperty()</codeph> 功能可以在 ActionScript 2.0 中动态地创建 get 和 set 方法。尽管 ActionScript 3.0 在编译时提供了 get 和 set 方法，但是，除非使用 Proxy 类，否则将无法动态地将某个方法分配给对象。</p>
 
 <p>为了避免与 <codeph>public</codeph> 命名空间冲突，Proxy 类的方法位于 <codeph>flash_proxy</codeph> 命名空间中。</p>
 
 <p>在 Proxy 类的方法采用 <codeph>name</codeph> 参数的地方，<codeph>name</codeph> 可以为 String 或 QName 对象（如果使用了命名空间）。</p>
 
 </apiDesc><example conref="examples\ProxyExample.as"><codeblock>
package {
    import flash.display.Sprite;

    public class ProxyExample extends Sprite {
        public function ProxyExample() {
            var arr:ProxyArray = new ProxyArray();
            arr.push(1);
            arr.push(-2);
            arr.push(3);
            arr.push(4);
            arr.push("five");
            
            trace(arr.length); // 5
            trace(arr[0]);     // 1
            trace(arr[1]);     // -2
            trace(arr[2]);     // 3
            trace(arr[3]);     // 4

            trace(arr.sum());  // 6

            arr.clear();
            trace(arr); // (empty string)
            
            arr[0] = "zero";
            trace(arr); // zero
        }
    }
}

import flash.utils.Proxy;
import flash.utils.flash_proxy;

dynamic class ProxyArray extends Proxy {
    private var _item:Array;

    public function ProxyArray() {
        _item = new Array();
    }

    override flash_proxy function callProperty(methodName:*, ... args):* {
        var res:*;
        switch (methodName.toString()) {
            case 'clear':
                _item = new Array();
                break;
            case 'sum':
                var sum:Number = 0;
                for each (var i:* in _item) {
                    // ignore non-numeric values
                    if (!isNaN(i)) {
                        sum += i;
                    }
                }
                res = sum;
                break;
            default:
                res = _item[methodName].apply(_item, args);
                break;
        }
        return res;
    }

    override flash_proxy function getProperty(name:*):* {
        return _item[name];
    }

    override flash_proxy function setProperty(name:*, value:*):void {
        _item[name] = value;
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.utils:Proxy:flash_proxy:callProperty"><apiName>callProperty</apiName><shortdesc>
	 覆盖可作为函数调用的对象属性的行为。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>所调用方法的返回值。
     </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>正被调用的方法的名称。
	 </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>一个数组，指定所调用方法的参数。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 覆盖可作为函数调用的对象属性的行为。在调用对象的某个方法时，将调用此方法。某些对象可作为函数调用，同时某些对象属性也可作为函数调用。 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Function/call()"><linktext>Function.call()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>ECMA-262 Language Specification, 3rd Edition, section 15</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:deleteProperty"><apiName>deleteProperty</apiName><shortdesc>
	 覆盖删除属性的请求。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>如果删除了此属性，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>要删除的属性的名称。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 覆盖删除属性的请求。使用 <codeph>delete</codeph> 运算符删除属性时，将调用此方法来执行删除操作。 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../operators.html#delete"><linktext>delete 运算符</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>ECMA-262 Language Specification, 3rd Edition, 8.6.2.5</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:getDescendants"><apiName>getDescendants</apiName><shortdesc>
	 覆盖 descendant 运算符的使用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc><codeph>descendant</codeph> 运算符的结果。
     </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>要传递到对象中并要搜索的属性的名称。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 覆盖 <codeph>descendant</codeph> 运算符的使用。在使用 <codeph>descendant</codeph> 运算符时，将调用此方法。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../operators.html#descendant_accessor"><linktext>descendant 运算符</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>E4X Specification</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:getProperty"><apiName>getProperty</apiName><shortdesc>
     覆盖对属性值的任何请求。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>指定的属性或 <codeph>undefined</codeph>（如果未找到属性）。
     </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>要检索的属性的名称。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     覆盖对属性值的任何请求。如果无法找到属性，则该方法返回 <codeph>undefined</codeph>。有关此行为的详细信息，请参阅 ECMA-262 语言规范第三版的 8.6.2.1 小节。
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../statements.html#get"><linktext>get 语句</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>ECMA-262 Language Specification, 3rd Edition, section 8.6.2.1</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:hasProperty"><apiName>hasProperty</apiName><shortdesc>
	 覆盖请求以按名称来检查对象是否具有特定属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>如果此属性存在，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>要检查的属性的名称。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 覆盖请求以按名称来检查对象是否具有特定属性。 
     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Object/hasOwnProperty()"><linktext>Object.hasOwnProperty()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>ECMA-262 Language Specification, 3rd Edition, section 8.6.2.4</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:isAttribute"><apiName>isAttribute</apiName><shortdesc>
	 检查是否还将提供的 QName 标记为属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>如果 <codeph>name</codeph> 的参数为同样被标记为属性的 QName，则返回 <codeph>true</codeph>。
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>要检查的属性的名称。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 检查是否还将提供的 QName 标记为属性。 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#QName"><linktext>QName 类</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:nextName"><apiName>nextName</apiName><shortdesc>
	 允许按索引编号枚举代理对象的属性以检索属性名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>字符串。属性的名称。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>对象属性从 0 开始的索引值。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 允许按索引编号枚举代理对象的属性以检索属性名称。但是，无法枚举 Proxy 类自身的属性。此函数支持对对象实现 <codeph>for...in</codeph> 和 <codeph>for each..in</codeph> 循环以检索所需的名称。
	 <p>例如（使用 <codeph>Proxy.nextNameIndex()</codeph> 中的代码）：</p>
     <codeblock>
     protected var _item:Array; // array of object's properties
     override flash_proxy function nextNameIndex (index:int):int {
         // initial call
         if (index == 0) {
             _item = new Array();
             for (var x:~~ in _target) {
                _item.push(x);
             }
         }
     
         if (index &lt; _item.length) {
             return index + 1;
         } else {
             return 0;
         }
     }
     override flash_proxy function nextName(index:int):String {
         return _item[index - 1];
     }
     </codeblock>
 	 
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Proxy/nextNameIndex()"><linktext>Proxy.nextNameIndex()</linktext></link><link href="flash.utils.xml#Proxy/nextValue()"><linktext>Proxy.nextValue()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:nextNameIndex"><apiName>nextNameIndex</apiName><shortdesc>
	 允许按索引编号枚举代理对象的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>属性的索引值。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>从 0 开始的索引值，枚举将从该值开始。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 允许按索引编号枚举代理对象的属性。但是，无法枚举 Proxy 类自身的属性。此函数支持对对象实现 <codeph>for...in</codeph> 和 <codeph>for each..in</codeph> 循环以检索属性索引值。
	 <p>例如：</p>
	 <codeblock>
     protected var _item:Array; // array of object's properties
     override flash_proxy function nextNameIndex (index:int):int {
         // initial call
         if (index == 0) {
             _item = new Array();
             for (var x:~~ in _target) {
                _item.push(x);
             }
         }
     
         if (index &lt; _item.length) {
             return index + 1;
         } else {
             return 0;
         }
     }
     override flash_proxy function nextName(index:int):String {
         return _item[index - 1];
     }
	 </codeblock>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Proxy/nextName()"><linktext>Proxy.nextName()</linktext></link><link href="flash.utils.xml#Proxy/nextValue()"><linktext>Proxy.nextValue()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:nextValue"><apiName>nextValue</apiName><shortdesc>
 	 允许按索引编号枚举代理对象的属性以检索属性值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>属性的值。
	 </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>对象属性从 0 开始的索引值。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
 	 允许按索引编号枚举代理对象的属性以检索属性值。但是，无法枚举 Proxy 类自身的属性。此函数支持对对象实现 <codeph>for...in</codeph> 和 <codeph>for each..in</codeph> 循环以检索所需的值。
	 
	 <p>例如（使用 <codeph>Proxy.nextNameIndex()</codeph> 中的代码）：</p>
     <codeblock>
     protected var _item:Array; // array of object's properties
     override flash_proxy function nextNameIndex (index:int):int {
         // initial call
         if (index == 0) {
             _item = new Array();
             for (var x:~~ in _target) {
                _item.push(x);
             }
         }
     
         if (index &lt; _item.length) {
             return index + 1;
         } else {
             return 0;
         }
     }
     override flash_proxy function nextName(index:int):String {
         return _item[index - 1];
     }
     </codeblock>   
     </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Proxy/nextNameIndex()"><linktext>Proxy.nextNameIndex()</linktext></link><link href="flash.utils.xml#Proxy/nextName()"><linktext>Proxy.nextName()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:setProperty"><apiName>setProperty</apiName><shortdesc>
	 覆盖更改属性值的调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>要修改的属性的名称。
	 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>要为属性设置的值。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 覆盖更改属性值的调用。如果无法找到属性，此方法将创建一个具有指定名称和值的属性。 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../statements.html#set"><linktext>set 语句</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>ECMA-262 Language Specification, 3rd Edition, section 8.6.2.2</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.utils:ByteArray"><apiName>ByteArray</apiName><shortdesc>
 ByteArray 类提供用于优化读取、写入以及处理二进制数据的方法和属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 ByteArray 类提供用于优化读取、写入以及处理二进制数据的方法和属性。
 
 <p><i>注意：</i>ByteArray 类适用于需要在字节层访问数据的高级 开发人员。</p>
 
 <p>内存中的数据是一个压缩字节数组（数据类型的最紧凑表示形式），但可以使用标准 <codeph>[]</codeph>（数组访问）运算符来操作 ByteArray 类的实例。也可以使用与 URLStream 和 Socket 类中的方法相类似的方法将它作为内存中的文件进行读取和写入。</p>
 
 <p>此外，还支持 zlib 压缩和解压缩，以及 Action Message Format (AMF) 对象序列化。</p>
 
 <p>ByteArray 类可能的用途包括：
 
 <ul>
 
  <li>创建用以连接到服务器的自定义协议。</li>
 
  <li>编写自己的 URLEncoder/URLDecoder。</li>
 
  <li platform="actionscript">编写自己的 AMF/Remoting 包。</li>
 
  <li>通过使用数据类型优化数据的大小。</li>
 
 	 <li>在 Adobe<sup>®</sup> AIR<sup>®</sup> 中处理从文件加载的二进制数据。</li>
 
 </ul>
 </p>
 
 </apiDesc><example conref="examples\ByteArrayExample.as"> 以下示例使用 <codeph>ByteArrayExample</codeph> 类将布尔值和 pi 的双精度浮点表示形式写入字节数组。这是使用以下步骤完成的：
 <ol>
     <li>声明新的 ByteArray 对象实例 <codeph>byteArr</codeph>。</li>
     <li>写入布尔值 <codeph>false</codeph> 的字节等效值，然后检查长度并重新读取。</li>
     <li>写入数学值 pi 的双精度浮点等效值。</li>
     <li>重新读取写入字节数组的九个字节中的每一个字节。</li>
 </ol>
 
 <p><b>注意：</b>在字节上调用 <codeph>trace()</codeph> 时，它将输出存储于字节数组中的字节的十进制等效值。</p>
 
 <p>注意如何在末尾添加一段代码以检查文件结尾错误，确保读取的字节流没有超出文件结尾。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.errors.EOFError;

    public class ByteArrayExample extends Sprite {        
        public function ByteArrayExample() {
            var byteArr:ByteArray = new ByteArray();

            byteArr.writeBoolean(false);
            trace(byteArr.length);            // 1
            trace(byteArr[0]);            // 0

            byteArr.writeDouble(Math.PI);
            trace(byteArr.length);            // 9
            trace(byteArr[0]);            // 0
            trace(byteArr[1]);            // 64
            trace(byteArr[2]);            // 9
            trace(byteArr[3]);            // 33
            trace(byteArr[4]);            // 251
            trace(byteArr[5]);            // 84
            trace(byteArr[6]);            // 68
            trace(byteArr[7]);            // 45
            trace(byteArr[8]);            // 24
            
            byteArr.position = 0;

            try {
                trace(byteArr.readBoolean() == false); // true
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());        // 3.141592653589793
            }
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());
            } 
            catch(e:EOFError) {
                trace(e);            // EOFError: Error #2030: End of file was encountered.
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="../../operators.html#array_access"><linktext>[] (array access)</linktext></link><link href="flash.net.xml#Socket"><linktext>Socket 类</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream 类</linktext></link></related-links><apiConstructor id="flash.utils:ByteArray:ByteArray"><apiName>ByteArray</apiName><shortdesc>
 创建一个表示填充的字节数组的 ByteArray 实例，以便使用此类中的方法和属性来优化数据存储和数据流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 创建一个表示填充的字节数组的 ByteArray 实例，以便使用此类中的方法和属性来优化数据存储和数据流。
 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.utils:ByteArray:clear"><apiName>clear</apiName><shortdesc> 
	 清除字节数组的内容，并将 length 和 position 属性重置为 0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
	 清除字节数组的内容，并将 <codeph>length</codeph> 和 <codeph>position</codeph> 属性重置为 0。显式调用此方法将释放 ByteArray 实例占用的内存。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:compress"><apiName>compress</apiName><shortdesc>
	 压缩字节数组。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.compress, compress
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>algorithm</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>压缩时所用的压缩算法。有效值定义为 CompressionAlgorithm 类中的常量。默认情况下使用 zlib 格式。<ph platform="actionscript">仅为 Adobe AIR 中运行的内容识别此参数。Flash Player 只支持默认的 zlib 算法，如果尝试为此参数传递一个值，Flash Player 将引发异常。</ph>调用 <codeph>compress(<ph platform="javascript">air.</ph> CompressionAlgorithm.DEFLATE)</codeph> 与调用 <codeph>deflate()</codeph> 方法效果相同。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 压缩字节数组。将压缩整个字节数组。对于在 Adobe AIR 中运行的内容，可以通过传递一个值（在 CompressionAlgorithm 类中定义）作为 <codeph>algorithm</codeph> 参数来指定压缩算法。<ph platform="actionscript">Flash Player 只支持默认的 zlib 算法。</ph>
	 
	 <p>在调用后，ByteArray 的 <codeph>length</codeph> 属性将设置为新长度。<codeph>position</codeph> 属性将设置为字节数组末尾。</p>
	 
	 <p><xref href="http://www.ietf.org/rfc/rfc1950.txt" scope="external">http://www.ietf.org/rfc/rfc1950.txt</xref> 中介绍了 zlib 压缩的数据格式。</p>
	 
	 <p><xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref> 中介绍了 deflate 压缩算法。</p>
	 
	 <p>这种 deflate 压缩算法用于多种压缩格式，如 zlib、gzip、一些 zip 实现等。在使用这些压缩格式之一压缩数据时，除了存储原始数据的压缩版本之外，压缩格式数据（例如 .zip 文件）还包括元数据信息。举例来说，各种文件格式中包括的元数据的类型有文件名、文件修改日期/时间、原始文件大小、可选的注释、校验和数据等。</p>
	 
	 <p>例如，在使用 zlib 算法压缩 ByteArray 时，将以特定的格式构建生成的 ByteArray。一些字节包含有关所压缩数据的元数据，而另一些字节包含原始 ByteArray 数据的实际压缩版本。根据 zlib 压缩数据格式规范的定义，这些字节（即包含原始数据的压缩版本的部分）使用 deflate 算法进行压缩。因此，这些字节与对原始 ByteArray 调用 <codeph>compress( <ph outputclass="javascript">air.</ph> CompressionAlgorithm.DEFLATE)</codeph> 所得的结果相同。但是，<codeph>compress( <ph outputclass="javascript">air.</ph>CompressionAlgorithm.ZLIB)</codeph> 所得的结果包括额外的元数据，而 <codeph>compress( <ph platform="javascript">air.</ph> CompressionAlgorithm.DEFLATE)</codeph> 的结果只包括原始 ByteArray 数据的压缩版本，没有任何其它内容。</p>
	 
	 <p>为了使用 deflate 格式以 gzip 或 zip 等特定格式压缩 ByteArray 实例的数据，不能只调用 <codeph>compress( <ph platform="javascript">air.</ph> CompressionAlgorithm.DEFLATE)</codeph>。必须创建一个按照压缩格式规范构建的 ByteArray，包括相应的元数据以及使用 deflate 格式获取的压缩数据。同样，为了对以 gzip 或 zip 等格式压缩的数据进行解码，对这些数据不能只调用 <codeph>uncompress( <ph platform="javascript">air.</ph> CompressionAlgorithm.DEFLATE)</codeph>。首先，必须将元数据与压缩数据分离，然后才能使用 deflate 格式对压缩数据进行解压缩。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/uncompress()"><linktext>uncompress()</linktext></link><link href="flash.utils.xml#CompressionAlgorithm"><linktext>flash.utils.CompressionAlgorithm</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:deflate"><apiName>deflate</apiName><shortdesc>
	 使用 deflate 压缩算法压缩字节数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 使用 deflate 压缩算法压缩字节数组。将压缩整个字节数组。
	 
	 <p>在调用后，ByteArray 的 <codeph>length</codeph> 属性将设置为新长度。<codeph>position</codeph> 属性将设置为字节数组末尾。</p>
	 
	 <p><xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref> 中介绍了 deflate 压缩算法。</p>
	 
	 <p>为了使用 deflate 格式以 gzip 或 zip 等特定格式压缩 ByteArray 实例的数据，不能只调用 <codeph>deflate()</codeph>。必须创建一个按照压缩格式规范构建的 ByteArray，包括相应的元数据以及使用 deflate 格式获取的压缩数据。同样，为了对以 gzip 或 zip 等格式压缩的数据进行解码，对这些数据不能只调用 <codeph>inflate()</codeph>。首先，必须将元数据与压缩数据分离，然后才能使用 deflate 格式对压缩数据进行解压缩。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/inflate()"><linktext>inflate()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:inflate"><apiName>inflate</apiName><shortdesc>
	 使用 deflate 压缩算法将字节数组解压缩。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.uncompress, uncompress
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>数据不是有效的压缩数据；它不是使用用于压缩的相同压缩算法进行压缩的。
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 使用 deflate 压缩算法将字节数组解压缩。字节数组必须已经使用相同的算法进行压缩。 
	 
	 <p>在调用后，ByteArray 的 <codeph>length</codeph> 属性将设置为新长度。<codeph>position</codeph> 属性将设置为 0。</p>
	 
	 <p><xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref> 中介绍了 deflate 压缩算法。</p>
	 
	 <p>为了对使用 deflate 压缩算法的格式压缩的数据（如 gzip 或 zip 格式的数据）进行解码，对包含压缩格式数据的 ByteArray 不能只调用 <codeph>inflate()</codeph>。首先，必须将作为压缩数据格式的一部分而包括的元数据与实际压缩数据分开。有关详细信息，请参阅 <codeph>compress()</codeph> 方法的描述。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/deflate()"><linktext>deflate()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:readBoolean"><apiName>readBoolean</apiName><shortdesc>
	 从字节流中读取布尔值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readBoolean, readBoolean
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果字节不为零，则返回 <codeph>true</codeph>，否则返回 <codeph>false</codeph>。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取布尔值。读取单个字节，如果字节非零，则返回 <codeph>true</codeph>，否则返回 <codeph>false</codeph>。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readByte"><apiName>readByte</apiName><shortdesc>
	 从字节流中读取带符号的字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readByte, readByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>介于 -128 和 127 之间的整数。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取带符号的字节。
	 <p>返回值的范围是从 -128 到 127。</p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readBytes"><apiName>readBytes</apiName><shortdesc>
	 从字节流中读取 length 参数指定的数据字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readBytes, readBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>要将数据读入的 ByteArray 对象。
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc><codeph>bytes</codeph> 中的偏移（位置），应从该位置写入读取的数据。
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>要读取的字节数。默认值 0 导致读取所有可用的数据。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从字节流中读取 <codeph>length</codeph> 参数指定的数据字节数。从 <codeph>offset</codeph> 指定的位置开始，将字节读入 <codeph>bytes</codeph> 参数指定的 ByteArray 对象中，并将字节写入目标 ByteArray 中。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readDouble"><apiName>readDouble</apiName><shortdesc>
	 从字节流中读取一个 IEEE 754 双精度（64 位）浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readDouble, readDouble
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>双精度（64 位）浮点数。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取一个 IEEE 754 双精度（64 位）浮点数。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readFloat"><apiName>readFloat</apiName><shortdesc>
	 从字节流中读取一个 IEEE 754 单精度（32 位）浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readFloat, readFloat
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>单精度（32 位）浮点数。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取一个 IEEE 754 单精度（32 位）浮点数。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readInt"><apiName>readInt</apiName><shortdesc>
	 从字节流中读取一个带符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readInt, readInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>介于 -2147483648 和 2147483647 之间的 32 位带符号整数。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取一个带符号的 32 位整数。
	 
         <p>返回值的范围是从 -2147483648 到 2147483647。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
	 使用指定的字符集从字节流中读取指定长度的多字节字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readMultiByte, readMultiByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>UTF-8 编码的字符串。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要从字节流中读取的字节数。
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>表示用于解释字节的字符集的字符串。可能的字符集字符串包括 <codeph>"shift-jis"</codeph>、<codeph>"cn-gb"</codeph>、<codeph>"iso-8859-1"</codeph>”等。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character Sets</xref>。 
     <p><b>注意：</b>如果当前系统无法识别 <codeph>charSet</codeph> 参数的值，则应用程序将使用系统的默认代码页作为字符集。例如，<codeph>charSet</codeph> 参数的值（如在 <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> 中，使用 <codeph>01</codeph> 而不是 <codeph>1</codeph>）可能在您的开发计算机上起作用，但在其它计算机上可能不起作用。在其它计算机上，应用程序将使用系统的默认代码页。</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 使用指定的字符集从字节流中读取指定长度的多字节字符串。
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readObject"><apiName>readObject</apiName><shortdesc>
	 从字节数组中读取一个以 AMF 序列化格式进行编码的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readObject, readObject
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。	 
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>反序列化的对象。
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 从字节数组中读取一个以 AMF 序列化格式进行编码的对象。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:readShort"><apiName>readShort</apiName><shortdesc>
	 从字节流中读取一个带符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readShort, readShort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>介于 -32768 和 32767 之间的 16 位带符号整数。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取一个带符号的 16 位整数。
	 
	 <p>返回值的范围是从 -32768 到 32767。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUTF"><apiName>readUTF</apiName><shortdesc>
	 从字节流中读取一个 UTF-8 字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUTF, readUTF
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>UTF-8 编码的字符串。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是无符号的短整型（以字节表示长度）。
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#IDataInput/readUTF()"><linktext>flash.utils.IDataInput.readUTF()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
	 从字节流中读取一个由 length 参数指定的 UTF-8 字节序列，并返回一个字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUTFBytes, readUTFBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>由指定长度的 UTF-8 字节组成的字符串。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>指明 UTF-8 字节长度的无符号短整型数。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从字节流中读取一个由 <codeph>length</codeph> 参数指定的 UTF-8 字节序列，并返回一个字符串。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
	 从字节流中读取无符号的字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUnsignedByte, readUnsignedByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>介于 0 和 255 之间的 32 位无符号整数。
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取无符号的字节。
	 
	 <p>返回值的范围是从 0 到 255。 </p>	
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
	 从字节流中读取一个无符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUnsignedInt, readUnsignedInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>介于 0 和 4294967295 之间的 32 位无符号整数。
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取一个无符号的 32 位整数。
	 
	 <p>返回值的范围是从 0 到 4294967295。 </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
	 从字节流中读取一个无符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUnsignedShort, readUnsignedShort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>介于 0 和 65535 之间的 16 位无符号整数。
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从字节流中读取一个无符号的 16 位整数。
	 
	 <p>返回值的范围是从 0 到 65535。 </p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:toString"><apiName>toString</apiName><shortdesc>
	 将字节数组转换为字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>字节数组的字符串表示形式。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 将字节数组转换为字符串。如果数组中的数据以 Unicode 字节顺序标记开头，应用程序在将其转换为字符串时将保持该标记。如果 <codeph>System.useCodePage</codeph> 设置为 <codeph>true</codeph>，应用程序在转换时会将数组中的数据视为处于当前系统代码页中。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:uncompress"><apiName>uncompress</apiName><shortdesc>
	 解压缩字节数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.uncompress, uncompress
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>数据不是有效的压缩数据；它不是使用用于压缩的相同压缩算法进行压缩的。
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>algorithm</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>解压缩时要使用的压缩算法。它必须是用于压缩该数据的相同的压缩算法。有效值定义为 CompressionAlgorithm 类中的常量。默认情况下使用 zlib 格式。仅为 Adobe AIR 中运行的内容识别此参数。<ph platform="actionscript">Flash Player 只支持默认的 zlib 算法，如果尝试为此参数传递一个值，Flash Player 将引发异常。</ph>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 解压缩字节数组。对于在 Adobe AIR 中运行的内容，可以通过传递一个值（在 CompressionAlgorithm 类中定义）作为 <codeph>algorithm</codeph> 参数来指定压缩算法。字节数组必须已经使用相同的算法进行压缩。<ph platform="actionscript">Flash Player 只支持默认的 zlib 算法。</ph>
	 
	 <p>在调用后，ByteArray 的 <codeph>length</codeph> 属性将设置为新长度。<codeph>position</codeph> 属性将设置为 0。</p>
	 
	 <p><xref href="http://www.ietf.org/rfc/rfc1950.txt" scope="external">http://www.ietf.org/rfc/rfc1950.txt</xref> 中介绍了 zlib 压缩的数据格式。</p>
	 
	 <p><xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref> 中介绍了 deflate 压缩算法。</p>
	 
	 <p>在对使用 deflate 压缩算法的格式压缩的数据（如采用 gzip 或 zip 格式的数据）进行解码时，对包含压缩格式数据的 ByteArray 调用 <codeph>uncompress(CompressionAlgorithm.DEFLATE)</codeph> 将不起作用。首先，必须将作为压缩数据格式的一部分而包括的元数据与实际压缩数据分开。有关详细信息，请参阅 <codeph>compress()</codeph> 方法的描述。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/compress()"><linktext>compress()</linktext></link><link href="flash.utils.xml#CompressionAlgorithm"><linktext>flash.utils.CompressionAlgorithm</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
	 写入布尔值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeBoolean, writeBoolean
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>确定写入哪个字节的布尔值。如果该参数为 <codeph>true</codeph>，则该方法写入 1；如果该参数为 <codeph>false</codeph>，则该方法写入 0。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 写入布尔值。根据 <codeph>value</codeph> 参数写入单个字节。如果为 <codeph>true</codeph>，则写入 1，如果为 <codeph>false</codeph>，则写入 0。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeByte"><apiName>writeByte</apiName><shortdesc>
	 在字节流中写入一个字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeByte, writeByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个 32 位整数。低 8 位将被写入字节流。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在字节流中写入一个字节。 
	 <p>使用参数的低 8 位。忽略高 24 位。 </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeBytes"><apiName>writeBytes</apiName><shortdesc>
	 将指定字节数组 bytes（起始偏移量为 bytes，从 0 开始的索引）中包含 length 个字节的字节序列写入字节流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeBytes, writeBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>ByteArray 对象。
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>从 0 开始的索引，表示在数组中开始写入的位置。
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>一个无符号整数，表示在缓冲区中的写入范围。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将指定字节数组 <codeph>bytes</codeph>（起始偏移量为 <codeph>offset</codeph>，从零开始的索引）中包含 <codeph>length</codeph> 个字节的字节序列写入字节流。
	 
	 <p>如果省略 <codeph>length</codeph> 参数，则使用默认长度 0；该方法将从 <codeph>offset</codeph> 开始写入整个缓冲区。如果还省略了 <codeph>offset</codeph> 参数，则写入整个缓冲区。 </p> <p>如果 <codeph>offset</codeph> 或 <codeph>length</codeph> 超出范围，它们将被锁定到 <codeph>bytes</codeph> 数组的开头和结尾。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeDouble"><apiName>writeDouble</apiName><shortdesc>
	 在字节流中写入一个 IEEE 754 双精度（64 位）浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeDouble, writeDouble
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>双精度（64 位）浮点数。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在字节流中写入一个 IEEE 754 双精度（64 位）浮点数。 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeFloat"><apiName>writeFloat</apiName><shortdesc>
	 在字节流中写入一个 IEEE 754 单精度（32 位）浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeFloat, writeFloat
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>单精度（32 位）浮点数。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在字节流中写入一个 IEEE 754 单精度（32 位）浮点数。 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeInt"><apiName>writeInt</apiName><shortdesc>
	 在字节流中写入一个带符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeInt, writeInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要写入字节流的整数。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在字节流中写入一个带符号的 32 位整数。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
	 使用指定的字符集将多字节字符串写入字节流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeMultiByte, writeMultiByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>指示要使用的字符集的字符串。可能的字符集字符串包括 <codeph>"shift-jis"</codeph>、<codeph>"cn-gb"</codeph>、<codeph>"iso-8859-1"</codeph>”等。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character Sets</xref>。 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 使用指定的字符集将多字节字符串写入字节流。 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeObject"><apiName>writeObject</apiName><shortdesc>
	 将对象以 AMF 序列化格式写入字节数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeObject, writeObject
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>要序列化的对象。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将对象以 AMF 序列化格式写入字节数组。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:writeShort"><apiName>writeShort</apiName><shortdesc>
	 在字节流中写入一个 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeShort, writeShort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>32 位整数，该整数的低 16 位将被写入字节流。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在字节流中写入一个 16 位整数。使用参数的低 16 位。忽略高 16 位。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeUTF"><apiName>writeUTF</apiName><shortdesc>
	 将 UTF-8 字符串写入字节流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeUTF, writeUTF
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果长度大于 65535。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
	 将 UTF-8 字符串写入字节流。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeUTFBytes, writeUTFBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将 UTF-8 字符串写入字节流。类似于 <codeph>writeUTF()</codeph> 方法，但 <codeph>writeUTFBytes()</codeph> 不使用 16 位长度的词为字符串添加前缀。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
	 在字节流中写入一个无符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeUnsignedInt, writeUnsignedInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要写入字节流的无符号整数。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在字节流中写入一个无符号的 32 位整数。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.utils:ByteArray:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
	 可从字节数组的当前位置到数组末尾读取的数据的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>available, bytes, position 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 可从字节数组的当前位置到数组末尾读取的数据的字节数。
	 
	 <p>每次访问 ByteArray 对象时，将 <codeph>bytesAvailable</codeph> 属性与读取方法结合使用，以确保读取有效的数据。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:ByteArray:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
	 指示用于新 ByteArray 实例的 ByteArray 类的默认对象编码。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.defaultObjectEncoding, defaultObjectEncoding
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 指示用于新 ByteArray 实例的 ByteArray 类的默认对象编码。在创建新的 ByteArray 实例时，该实例上的编码以 <codeph>defaultObjectEncoding</codeph> 的值开头。<codeph>defaultObjectEncoding</codeph> 属性被初始化为 <codeph>ObjectEncoding.AMF3</codeph>。
	 
	 
	 <p>将对象写入二进制数据或从中读取对象时，将使用 <codeph>objectEncoding</codeph> 值来确定应使用 ActionScript 3.0、ActionScript2.0 还是 ActionScript 1.0 格式。该值为 ObjectEncoding 类中的常数。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding 类</linktext></link><link href="flash.utils.xml#ByteArray/objectEncoding"><linktext>flash.utils.ByteArray.objectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.utils:ByteArray:endian:get"><apiName>endian</apiName><shortdesc>
	 更改或读取数据的字节顺序；Endian.BIG_ENDIAN 或 Endian.LITTLE_ENDIAN。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 更改或读取数据的字节顺序；<codeph>Endian.BIG_ENDIAN</codeph> 或 <codeph>Endian.LITTLE_ENDIAN</codeph>。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>Endian 类</linktext></link></related-links></apiValue><apiValue id="flash.utils:ByteArray:length:get"><apiName>length</apiName><shortdesc>
	 ByteArray 对象的长度（以字节为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 ByteArray 对象的长度（以字节为单位）。
	 
	 <p>如果将长度设置为大于当前长度的值，该字节数组的右侧将用零填充。</p>
	 
	 <p>如果将长度设置为小于当前长度的值，将会截断该字节数组。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:ByteArray:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
	 用于确定在写入或读取 ByteArray 实例时应使用 ActionScript 3.0、ActionScript 2.0 还是 ActionScript 1.0 格式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.objectEncoding, objectEncoding
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 用于确定在写入或读取 ByteArray 实例时应使用 ActionScript 3.0、ActionScript 2.0 还是 ActionScript 1.0 格式。该值为 ObjectEncoding 类中的常数。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding 类</linktext></link><link href="flash.utils.xml#ByteArray/defaultObjectEncoding"><linktext>flash.utils.ByteArray.defaultObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.utils:ByteArray:position:get"><apiName>position</apiName><shortdesc>
	 将文件指针的当前位置（以字节为单位）移动或返回到 ByteArray 对象中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.getFilePointer, 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 将文件指针的当前位置（以字节为单位）移动或返回到 ByteArray 对象中。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:IDataOutput"><apiName>IDataOutput</apiName><shortdesc>
IDataOutput 接口提供一组用于写入二进制数据的方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
IDataOutput 接口提供一组用于写入二进制数据的方法。此接口是读取二进制数据的 IDataInput 接口的 I/O 对应接口。IDataOutput 接口是由 FileStream、Socket 和 ByteArray 类实现的。
<p>默认情况下，所有 IDataInput 和 IDataOutput 操作均为“bigEndian”（序列中的最高有效字节存储在最低或第一个存储地址），而且都不分块。 </p>
<p>符号扩展名仅在读取数据时有效，写入数据时无效。因此，无需单独的写入方法就可以使用 <codeph>IDataInput.readUnsignedByte()</codeph> 和 <codeph>IDataInput.readUnsignedShort()</codeph>。换言之：</p>
<ul>
  <li>将 <codeph>IDataOutput.writeByte()</codeph> 与 <codeph>IDataInput.readUnsignedByte()</codeph> 和 <codeph>IDataInput.readByte()</codeph> 一起使用。</li>
  <li>将 <codeph>IDataOutput.writeShort()</codeph> 与 <codeph>IDataInput.readUnsignedShort()</codeph> 和 <codeph>IDataInput.readShort()</codeph> 一起使用。</li>
</ul>

</apiDesc><example conref="examples\DataOutputExample.as"> 以下示例使用 <codeph>DataOutputExample</codeph> 类将布尔值和 pi 的双精度浮点表示形式写入字节数组。这是使用以下步骤完成的：
 <ol>
     <li>声明新的 ByteArray 对象实例 <codeph>byteArr</codeph>。</li>
     <li>写入布尔值 <codeph>false</codeph> 的字节等效值和数学值 pi 的双精度浮点等效值。</li>
     <li>重新读取布尔值和双精度浮点数。</li>
 </ol>
 
 <p>注意如何在末尾添加一段代码以检查文件结尾错误，确保读取的字节流没有超出文件结尾。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.errors.EOFError;

    public class DataOutputExample extends Sprite {        
        public function DataOutputExample() {
            var byteArr:ByteArray = new ByteArray();

            byteArr.writeBoolean(false);
            byteArr.writeDouble(Math.PI);
            
            byteArr.position = 0;

            try {
                trace(byteArr.readBoolean()); // false
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
                        
            try {
                trace(byteArr.readDouble());    // 3.141592653589793
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());
            } 
            catch(e:EOFError) {
                trace(e);        // EOFError: Error #2030: End of file was encountered.
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#IDataInput"><linktext>IDataInput interface</linktext></link><link href="flash.utils.xml#IDataOutput/endian"><linktext>endian</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>FileStream 类</linktext></link><link href="flash.net.xml#Socket"><linktext>Socket 类</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream 类</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>ByteArray 类</linktext></link></related-links><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
	 写入布尔值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>确定写入哪个字节的布尔值。如果该参数为 <codeph>true</codeph>，则写入 1；如果为 <codeph>false</codeph>，则写入 0。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 写入布尔值。根据 <codeph>value</codeph> 参数写入单个字节。如果为 <codeph>true</codeph>，则写入 1，如果为 <codeph>false</codeph>，则写入 0。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeByte"><apiName>writeByte</apiName><shortdesc>
	 写入一个字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个整型字节值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 写入一个字节。使用了该参数的低 8 位；忽略了高 24 位。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeBytes"><apiName>writeBytes</apiName><shortdesc>
	 在指定的字节数组 bytes 中，从 offset（使用从零开始的索引）指定的字节开始，向文件流、字节流或字节数组中写入一个长度由 length 指定的字节序列。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>要写入的字节数组。
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>从零开始的索引，指定在数组中开始写入的位置。
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>一个无符号整数，指定在缓冲区中的写入范围。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在指定的字节数组 <codeph>bytes</codeph> 中，从 <codeph>offset</codeph>（使用从零开始的索引）指定的字节开始，向文件流、字节流或字节数组中写入一个长度由 <codeph>length</codeph> 指定的字节序列。
	 
	 <p>如果省略 <codeph>length</codeph> 参数，则使用默认长度 0 并从 <codeph>offset</codeph> 开始写入整个缓冲区。如果还省略了 <codeph>offset</codeph> 参数，则写入整个缓冲区。 </p>
	 
	 <p>如果 <codeph>offset</codeph> 或 <codeph>length</codeph> 参数超出范围，它们将被锁定到 <codeph>bytes</codeph> 数组的开头和结尾。</p>
 	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeDouble"><apiName>writeDouble</apiName><shortdesc>
	 写入 IEEE 754 双精度（64 位）浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>双精度（64 位）浮点数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 写入 IEEE 754 双精度（64 位）浮点数。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeFloat"><apiName>writeFloat</apiName><shortdesc>
	 写入 IEEE 754 单精度（32 位）浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>单精度（32 位）浮点数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 写入 IEEE 754 单精度（32 位）浮点数。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeInt"><apiName>writeInt</apiName><shortdesc>
	 写入一个带符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个带符号的整型字节值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 写入一个带符号的 32 位整数。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
	 使用指定的字符集将多字节字符串写入文件流、字节流或字节数组中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>IDataOutput, IDataOutput.writeMultiByte, writeMultiByte
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>指示要使用的字符集的字符串。可能的字符集字符串包括 <codeph>"shift-jis"</codeph>、<codeph>"cn-gb"</codeph>、<codeph>"iso-8859-1"</codeph>”等。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character Sets</xref>。 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 使用指定的字符集将多字节字符串写入文件流、字节流或字节数组中。 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeObject"><apiName>writeObject</apiName><shortdesc>
	 以 AMF 序列化格式将对象写入文件流、字节流或字节数组中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>要进行序列化处理的对象。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 以 AMF 序列化格式将对象写入文件流、字节流或字节数组中。
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#IDataOutput/objectEncoding"><linktext>objectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeShort"><apiName>writeShort</apiName><shortdesc>
	 写入一个 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个整型字节值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 写入一个 16 位整数。使用了该参数的低 16 位；忽略了高 16 位。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeUTF"><apiName>writeUTF</apiName><shortdesc>
	 将 UTF-8 字符串写入文件流、字节流或字节数组中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果长度大于 65535。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将 UTF-8 字符串写入文件流、字节流或字节数组中。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
	 写入一个 UTF-8 字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 写入一个 UTF-8 字符串。类似于 <codeph>writeUTF()</codeph>，但不使用 16 位长度的词为字符串添加前缀。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
	 写入一个无符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个无符号的整型字节值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 写入一个无符号的 32 位整数。
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.utils:IDataOutput:flash.utils:IDataOutput:endian:get"><apiName>endian</apiName><shortdesc>
	 数据的字节顺序：为 Endian 类中的 BIG_ENDIAN 或 LITTLE_ENDIAN 常量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 数据的字节顺序：为 Endian 类中的 <codeph>BIG_ENDIAN</codeph> 或 <codeph>LITTLE_ENDIAN</codeph> 常量。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>Endian 类</linktext></link></related-links></apiValue><apiValue id="flash.utils:IDataOutput:flash.utils:IDataOutput:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     用于确定在使用 writeObject() 方法写入或读取二进制数据时是使用 AMF3 格式还是 AMF0 格式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     用于确定在使用 <codeph>writeObject()</codeph> 方法写入或读取二进制数据时是使用 AMF3 格式还是 AMF0 格式。该值为 ObjectEncoding 类中的常数。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#IDataInput/readObject()"><linktext>IDataInput.readObject()</linktext></link><link href="flash.utils.xml#IDataOutput/writeObject()"><linktext>writeObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding 类</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.utils:Endian"><apiName>Endian</apiName><shortdesc>
 Endian 类中包含一些值，它们指示用于表示多字节数字的字节顺序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Endian 类中包含一些值，它们指示用于表示多字节数字的字节顺序。字节顺序为 bigEndian（最高有效字节位于最前）或 littleEndian（最低有效字节位于最前）。
 
 <p><ph platform="actionscript">Flash Player 或</ph> Adobe<sup>®</sup> AIR™ 中的内容可以通过使用服务器的二进制协议直接与该服务器连接。某些服务器使用 bigEndian 字节顺序，某些服务器则使用 littleEndian 字节顺序。Internet 上的大多数服务器使用 bigEndian 字节顺序，因为“网络字节顺序”为 bigEndian。littleEndian 字节顺序很常用，因为 Intel x86 体系结构使用该字节顺序。使用与收发数据的服务器的协议相匹配的 Endian 字节顺序。</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.utils.xml#ByteArray/endian"><linktext>flash.utils.ByteArray.endian</linktext></link><link href="flash.filesystem.xml#FileStream/endian"><linktext>flash.filesystem.FileStream.endian</linktext></link><link href="flash.utils.xml#IDataInput/endian"><linktext>flash.utils.IDataInput.endian</linktext></link><link href="flash.utils.xml#IDataOutput/endian"><linktext>flash.utils.IDataOutput.endian</linktext></link><link href="flash.net.xml#Socket/endian"><linktext>flash.net.Socket.endian</linktext></link><link href="flash.net.xml#URLStream/endian"><linktext>flash.net.URLStream.endian</linktext></link></related-links><apiValue id="flash.utils:Endian:BIG_ENDIAN"><apiName>BIG_ENDIAN</apiName><shortdesc>
	 指示多字节数字的最高有效字节位于字节序列的最前面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bigEndian</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指示多字节数字的最高有效字节位于字节序列的最前面。
	 <p>十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。</p>
	 <p>使用 bigEndian 字节顺序（最高有效字节位于最前）的流将写入：</p>
	 <pre>
	 12 34 56 78
	 </pre>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Endian:LITTLE_ENDIAN"><apiName>LITTLE_ENDIAN</apiName><shortdesc>
	 指示多字节数字的最低有效字节位于字节序列的最前面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>littleEndian</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 指示多字节数字的最低有效字节位于字节序列的最前面。
	 <p>十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。</p>
	 <p>使用 littleEndian 字节顺序（最低有效字节位于最前）的流将写入：</p>
	 <pre>
	 78 56 34 12
	 </pre>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:IExternalizable"><apiName>IExternalizable</apiName><shortdesc>
 将类编码到数据流中时，IExternalizable 接口提供对其序列化的控制。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
 将类编码到数据流中时，IExternalizable 接口提供对其序列化的控制。IExternalizable 接口的 <codeph>writeExternal()</codeph> 和 <codeph>readExternal()</codeph> 方法是由一个类实现的，以便允许为对象及其超类型自定义数据流的内容和格式（但不是类名或类型）。每个单独的类都必须序列化并重新构建其实例的状态。这些方法必须与超类型相称才能保存其状态。这些方法取代了本机的 Action Message Format (AMF) 序列化行为。 
 <p>如果某个类既没有实现 IExternalizable 接口，也没有从实现该接口的类继承，则将仅使用公共成员的默认机制对该类的实例进行序列化。因此，类的私有成员、内部成员和受保护的成员将不可用。</p>
 <p>要序列化私有成员，类必须使用 IExternalizable 接口。例如，以下类将不会序列化其任何成员，因为这些成员都是私有成员：</p>
 <codeblock>
 class Example {
 
       private var one:int;
       private var two:int;
 }
 </codeblock>
 <p>但是，如果实现了 IExternalizable 接口，则可以将类的私有成员写入数据流或从数据流中读取类的私有成员，如下所示：</p>
 <codeblock>
 class Example implement IExternalizable {
 
       private var one:int;
       private var two:int;
 
       public function writeExternal(output:IDataOutput) {
 
            output.writeInt(one);
            output.writeInt(two);
       }
 
       public function readExternal(input:IDataInput) {
 
            one = input.readInt();
            two = input.readInt();
       }
 }
 </codeblock>
 <p><b>注意：</b>如果某个类实现了 IExternalizable，则默认序列化不再适用于该类的实例。如果该类从超类继承公共成员，还必须小心地管理这些成员。</p>
 <p>如果实现 IExternalizable 的某个类的子类有自己的私有成员，则该子类必须覆盖 IExternalizable 的方法，如下所示：</p>
 <codeblock>
 public class Base implements IExternalizable {
  
      private var one:Boolean;
  
      public function writeExternal(output:IDataOutput):void {
  
          output.writeBoolean(one);
      }
  
      public function readExternal(input:IDataInput):void {
  
          one = input.readBoolean();
      }
 }
  
 public class Example extends Base {
  
      private var one:String;
  
  
      public override function writeExternal(output:IDataOutput):void {
  
          super.writeExternal(output);
          output.writeUTF(one);
      }
  
      public override function readExternal(input:IDataInput):void {
      
          super.readExternal(input);
          one = input.readUTF();
      }
 }
 </codeblock>
 <p>在将数据写入数据流之前，也可以使用 IExternalizable 接口来压缩数据。例如：</p>
 <codeblock>
 class Example implements IExternalizable {
  
      public var one:Boolean;
      public var two:Boolean;
      public var three:Boolean;
      public var four:Boolean;
      public var five:Boolean;
      public var six:Boolean;
      public var seven:Boolean;
      public var eight:Boolean;
 
      public function writeExternal(output:IDataOutput) {
 
          var flag:int = 0;
 
          if (one) flag |= 1;
          if (two) flag |= 2;
          if (three) flag |= 4;
          if (four) flag |= 8;
          if (five) flag |= 16;
          if (six) flag |= 32;
          if (seven) flag |= 64;
          if (eight) flag |= 128;
 
          output.writeByte(flag);
      }
 
      public function readExternal(input:IDataInput) {
 
          var flag:int = input.readByte();
 
          one = (flag &amp; 1) != 0;
          two = (flag &amp; 2) != 0;
          three = (flag &amp; 4) != 0;
          four = (flag &amp; 8) != 0;
          five = (flag &amp; 16) != 0;
          six = (flag &amp; 32) != 0;
          seven = (flag &amp; 64) != 0;
          eight = (flag &amp; 128) != 0;
      }
 }
 </codeblock>
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links><apiOperation id="flash.utils:IExternalizable:flash.utils:IExternalizable:readExternal"><apiName>readExternal</apiName><shortdesc>
	 类实现此方法，以便通过调用 IDataInput 接口的方法，将其自身从数据流中解码。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>input</apiItemName><apiOperationClassifier>flash.utils:IDataInput</apiOperationClassifier><apiDesc>实现 IDataInput 接口的类的名称。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 类实现此方法，以便通过调用 IDataInput 接口的方法，将其自身从数据流中解码。此方法必须读取与 <codeph>writeExternal()</codeph> 方法所写入值处于同一序列中并且类型相同的值。
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IExternalizable:flash.utils:IExternalizable:writeExternal"><apiName>writeExternal</apiName><shortdesc>
	 类实现此方法，以便通过调用 IDataOutput 接口的方法，将其自身编码到数据流中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>output</apiItemName><apiOperationClassifier>flash.utils:IDataOutput</apiOperationClassifier><apiDesc>实现 IDataOutput 接口的类的名称。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 类实现此方法，以便通过调用 IDataOutput 接口的方法，将其自身编码到数据流中。
     </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiOperation id="globalOperation:flash.utils:describeType"><apiName>describeType</apiName><shortdesc>
	 生成描述 ActionScript 对象（命名为方法的参数）的 XML 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 XML 对象，包含有关作为参数传入的对象的详细信息。它提供有关对象的以下信息：
	 
	 <ul>
	  <li>对象的类</li> 
	 	 <li>类的属性</li> 
	 	 <li>从类到其基类的继承树</li> 
	 	 <li>类实现的接口</li> 
	 	 <li>类的已声明实例属性</li> 
	 	 <li>类的已声明静态属性</li> 
	 	 <li>类的实例方法</li>
	 	 <li>类的静态方法 </li>
	 	 <li>（对于类的每个方法）名称、参数的数量、返回类型和参数类型 </li>
	 </ul>
     <p><b>注意：</b> <codeph>describeType()</codeph> 只显示公共属性和方法，而不会显示私有、在包内部或在自定义命名空间中的属性和方法。 </p>
	 
 	 </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>需要类型说明的对象。可以将任何 ActionScript 值传递给此方法，包括所有可用的 ActionScript 类型、对象实例、原始类型（如 uint）和类对象。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 生成描述 ActionScript 对象（命名为方法的参数）的 XML 对象。此方法实现 ActionScript 语言的<i>反射</i>编程概念。
	 <p>如果 <codeph>value</codeph> 参数是类型的实例，则返回的 XML 对象包括该类型的所有实例属性，但不包括任何静态属性。可以在解析 XML 对象时检查此条件，方法是检查 <codeph>&lt;type></codeph> 标签的 <codeph>isStatic</codeph> 属性的值，该值在 <codeph>value</codeph> 参数是类型的实例时为 <codeph>false</codeph>。</p>
	 <p>要获取某个类型的静态属性，请为 <codeph>value</codeph> 参数传递该类型本身。返回的 XML 对象不仅仅包括类型的静态属性，而且还包括它的所有实例属性。实例属性嵌套在名为 <codeph>&lt;factory></codeph> 的标签内，从而与静态属性区分开来。在这种情况下，<codeph>&lt;type></codeph> 标签的 <codeph>isStatic</codeph> 属性为 <codeph>true</codeph>。</p>
	 <p><b>注意：</b>如果只需要遍历某个对象的继承层次结构，而不需要 <codeph>describeType()</codeph> 提供的其它信息，请改用 <codeph>getQualifiedClassName()</codeph> 和 <codeph>getQualifiedSuperclassName()</codeph> 函数。</p>
	 <p>下表描述了由 <codeph>describeType()</codeph> 生成的 XML 对象的某些标签和属性（返回的所有类和接口名称均采用完全限定的格式）：</p>
	 <adobetable class="innertable">
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	 <tgroup cols="3"><thead><row><entry>标签</entry><entry>属性</entry><entry>说明</entry></row></thead><tbody><row><entry><codeph>&lt;type></codeph></entry><entry> </entry><entry>XML 对象的根标签。</entry></row><row><entry> </entry><entry>name</entry><entry>ActionScript 对象的数据类型的名称。</entry></row><row><entry> </entry><entry>base</entry><entry>ActionScript 对象的定义类的直接超类。如果 ActionScript 对象是类对象，则值为 <codeph>Class</codeph>。</entry></row><row><entry> </entry><entry>isDynamic</entry><entry>如果 ActionScript 对象的定义类是动态的，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。如果 ActionScript 对象是类对象，则值为 <codeph>true</codeph>，因为 Class 类是动态的。</entry></row><row><entry> </entry><entry>isFinal</entry><entry>如果 ActionScript 对象的定义类是最终类，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。</entry></row><row><entry> </entry><entry>isStatic</entry><entry>如果 ActionScript 对象是类对象或构造函数，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。此属性之所以名为 <codeph>isStatic</codeph>，原因是：如果此属性为 <codeph>true</codeph>，则未嵌套在 <codeph>factory</codeph> 标记内的任何标签都是静态的。</entry></row><row><entry><codeph>&lt;extendsClass></codeph></entry><entry> </entry><entry>ActionScript 对象的定义类的每个超类都有一个单独的 <codeph>extendsClass</codeph> 标签。</entry></row><row><entry> </entry><entry>type</entry><entry>ActionScript 对象的定义类扩展的超类的名称。</entry></row><row><entry><codeph>&lt;implementsInterface></codeph></entry><entry> </entry><entry>ActionScript 对象的定义类或其任何超类实现的每个接口都有一个单独的 <codeph>implementsInterface</codeph> 标签。</entry></row><row><entry> </entry><entry>type</entry><entry>ActionScript 对象的定义类实现的接口的名称。</entry></row><row><entry><codeph>&lt;accessor></codeph></entry><entry> </entry><entry>存取器是 getter 和 setter 函数定义的一个属性。</entry></row><row><entry> </entry><entry>name</entry><entry>存取器的名称。</entry></row><row><entry> </entry><entry>access</entry><entry>属性的访问权限。可能的值包括 <codeph>readonly</codeph>、<codeph>writeonly</codeph> 和 <codeph>readwrite</codeph>。</entry></row><row><entry> </entry><entry>type</entry><entry>属性的数据类型。</entry></row><row><entry> </entry><entry>declaredBy</entry><entry>包含关联的 getter 或 setter 函数的类。</entry></row><row><entry><codeph>&lt;constant></codeph></entry><entry> </entry><entry>常量是用 <codeph>const</codeph> 语句定义的一个属性。</entry></row><row><entry> </entry><entry>name</entry><entry>常量的名称。</entry></row><row><entry> </entry><entry>type</entry><entry>常量的数据类型。</entry></row><row><entry><codeph>&lt;method></codeph></entry><entry> </entry><entry>方法是作为类定义的一部分声明的函数。</entry></row><row><entry> </entry><entry>name</entry><entry>方法的名称。</entry></row><row><entry> </entry><entry>declaredBy</entry><entry>包含方法定义的类。</entry></row><row><entry> </entry><entry>returnType</entry><entry>方法的返回值的数据类型。</entry></row><row><entry><codeph>&lt;parameter></codeph></entry><entry> </entry><entry>方法定义的每个参数都有一个单独的 <codeph>parameter</codeph> 标签。此标签始终嵌套在 <codeph>&lt;method></codeph> 标签内。</entry></row><row><entry> </entry><entry>index</entry><entry>一个数字，对应于参数在方法的参数列表中出现的顺序。第一个参数的值为 1。</entry></row><row><entry> </entry><entry>type</entry><entry>参数的数据类型。</entry></row><row><entry> </entry><entry>optional</entry><entry>如果参数是可选参数，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。</entry></row><row><entry><codeph>&lt;variable></codeph></entry><entry> </entry><entry>变量是用 <codeph>var</codeph> 语句定义的一个属性。</entry></row><row><entry> </entry><entry>name</entry><entry>变量的名称。</entry></row><row><entry> </entry><entry>type</entry><entry>变量的数据类型。</entry></row><row><entry><codeph>&lt;factory></codeph></entry><entry> </entry><entry>如果 ActionScript 对象是类对象或构造函数，则所有实例属性和方法均嵌套在此标签内。如果 <codeph>&lt;type></codeph> 标签的 <codeph>isStatic</codeph> 属性为 <codeph>true</codeph>，则未嵌套在 <codeph>&lt;factory></codeph> 标签内的所有属性和方法都是静态的。只有在 ActionScript 对象是类对象或构造函数时，此标签才会出现。</entry></row></tbody></tgroup></adobetable>
	 
	 
	 </apiDesc><example conref="examples\DescribeTypeExample.as"><codeblock>package {
    import flash.display.Sprite;
    import flash.utils.describeType;
    
    public class DescribeTypeExample extends Sprite {
        public function DescribeTypeExample() {
            var child:Sprite = new Sprite();
            var description:XML = describeType(child);
            trace(description..accessor.@name.toXMLString());
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/getQualifiedClassName()"><linktext>getQualifiedClassName()</linktext></link><link href="flash.utils.xml#/getQualifiedSuperclassName()"><linktext>getQualifiedSuperclassName()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:escapeMultiByte"><apiName>escapeMultiByte</apiName><shortdesc>
	  返回编码为 UTF-8 或系统代码页的输入字符串的转义副本，具体取决于 System.useCodePage 的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>输入字符串的转义副本。如果 System.useCodePage 为 <codeph>true</codeph>，则转义字符串采用系统代码页编码。如果 System.useCodePage 为 <codeph>false</codeph>，则转义字符串采用 UTF-8 编码。例如，如果 System.useCodePage 为 <codeph>false</codeph>，输入字符串“CrÃ¼e”在所有系统上都将被转义为“Cr%C3%BCe”。如果 system.useCodePage 为 <codeph>true</codeph>，并且系统使用拉丁语代码页，则“CrÃ¼e”将被转义为“Cr%FCe”。如果系统使用不包含字母“Ã¼”的非拉丁语代码页，结果将可能为“Cr?e”。
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要转义的字符串。
	  
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  返回编码为 UTF-8 或系统代码页的输入字符串的转义副本，具体取决于 System.useCodePage 的值。通过使用 System.useCodePage，将使播放器能够访问用本地代码页编码的旧内容，但只能在使用旧代码页的系统上访问。例如，在使用日语默认代码页的操作系统中，只能正确转义和反向转义以 <codeph>Shift-JIS</codeph> 编码的日语数据。
	  
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:flash.utils:getDefinitionByName"><apiName>getDefinitionByName</apiName><shortdesc>
	 返回 name 参数指定的类的类对象引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>不存在具有指定名称的公共定义。
	 
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回 <codeph>name</codeph> 参数指定的类的类对象引用。
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>类的名称。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回 <codeph>name</codeph> 参数指定的类的类对象引用。
	 </apiDesc><example conref="examples\GetDefinitionByNameExample.as"> 以下示例使用 <codeph>GetDefinitionByNameExample</codeph> 类在舞台上创建一个橙色的正方形。这是使用以下步骤完成的：
 <ol>
     <li>声明代表橙色背景颜色和 80 像素大小的变量，这些变量稍后将用于绘制正方形。</li>
     <li>在构造函数内，将 Class 类型的变量 <codeph>ClassReference</codeph> 赋予 Sprite。</li>
     <li>对名为 <codeph>instance</codeph> 的 ClassReference 的实例进行实例化。</li>
     <li>由于 <codeph>instance</codeph> 按引用是 Sprite 对象，因此可以使用可用于 Sprite 的方法绘制正方形并将其添加到显示列表。</li>
 </ol>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.utils.getDefinitionByName;

    public class GetDefinitionByNameExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint = 80;

        public function GetDefinitionByNameExample() {
            var ClassReference:Class = getDefinitionByName("flash.display.Sprite") as Class;
            var instance:Object = new ClassReference();
            instance.graphics.beginFill(bgColor);
            instance.graphics.drawRect(0, 0, size, size);
            instance.graphics.endFill();
            addChild(DisplayObject(instance));
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="globalOperation:flash.utils:getQualifiedClassName"><apiName>getQualifiedClassName</apiName><shortdesc>
	  返回对象的完全限定类名。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>包含完全限定类名称的字符串。
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>需要完全限定类名称的对象。可以将任何 ActionScript 值传递给此方法，包括所有可用的 ActionScript 类型、对象实例、原始类型（如 uint）和类对象。
	  
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  返回对象的完全限定类名。
	  
	  </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#/describeType()"><linktext>describeType()</linktext></link><link href="flash.utils.xml#/getQualifiedSuperclassName()"><linktext>getQualifiedSuperclassName()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:getQualifiedSuperclassName"><apiName>getQualifiedSuperclassName</apiName><shortdesc>
	返回 value 参数指定的对象的基类的完全限定类名。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>完全限定的基类名称，或 <codeph>null</codeph>（如果不存在基类名称）。
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>任何值。
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	返回 <codeph>value</codeph> 参数指定的对象的基类的完全限定类名。此函数检索基类名称的速度比 <codeph>describeType()</codeph> 快，但提供的信息不如 <codeph>describeType()</codeph> 全面。
	<p>使用此函数检索了类的名称后，可以用 <codeph>getDefinitionByName()</codeph> 函数将类名称转换为类引用。</p>
	<p><b>注意：</b>此函数将本身局限于实例层次结构，而 <codeph>describeType()</codeph> 函数则使用类对象层次结构（如果 <codeph>value</codeph> 参数是数据类型）。如果在数据类型上调用 <codeph>describeType()</codeph>，将会基于类对象层次结构（其中所有类对象均继承自 Class）返回超类。但是，<codeph>getQualifiedSuperclassName()</codeph> 函数会忽略类对象层次结构，并基于较普通的实例层次结构返回超类。例如，调用 <codeph>getQualifiedSuperclassName(String)</codeph> 将会返回 <codeph>Object</codeph>，尽管从技术角度来说 String 类对象继承自 Class。换言之，不管使用的是类型的实例还是类型本身，结果都是相同的。</p>
	</apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#/describeType()"><linktext>describeType()</linktext></link><link href="flash.utils.xml#/getDefinitionByName()"><linktext>getDefinitionByName()</linktext></link><link href="flash.utils.xml#/getQualifiedClassName()"><linktext>getQualifiedClassName()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:getTimer"><apiName>getTimer</apiName><shortdesc>
	 用于计算相对时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>自初始化运行时（处理 ActionScript 2.0 时）或启动虚拟计算机（处理 ActionScript 3.0 时）以来经过的毫秒数。如果运行时开始播放一个 SWF 文件，稍后再加载另一个 SWF 文件，则返回值相对于加载第一个 SWF 文件的时间。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 用于计算相对时间。对于处理 ActionScript 3.0 的 Flash 运行时，此方法返回自为 ActionScript 3.0 (AVM2) 启动 Flash 运行时虚拟计算机以来经过的毫秒数。对于处理 ActionScript 2.0 的 Flash 运行时，此方法返回自 Flash 运行时开始初始化以来经过的毫秒数。Flash 运行时使用两台虚拟机处理 ActionScript。AVM1 是用于运行 ActionScript 1.0 和 2.0 的 ActionScript 虚拟机。AVM2 是用于运行 ActionScript 3.0 的 ActionScript 虚拟机。AVM1 的 <codeph>getTimer()</codeph> 方法行为与 AVM2 的行为不同。
	 <p>关于日历日期（时间戳），请参阅 Date 对象。</p> 	 
	 
	 </apiDesc><example conref="examples\getTimerExample.as"> 以下示例使用 <codeph>GetTimerExample</codeph> 类获取并输出自 Flash Player 开始播放后经过的毫秒数。
<codeblock>
package {
    import flash.utils.getTimer;
    import flash.display.Sprite;

    public class GetTimerExample extends Sprite {
        public function GetTimerExample() {
            var duration:uint = getTimer();
            trace("duration: " + duration);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#AVM1Movie"><linktext>flash.display.AVM1Movie</linktext></link><link href="#Date"><linktext>Date 类</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:unescapeMultiByte"><apiName>unescapeMultiByte</apiName><shortdesc>
	  返回依据系统代码页或 UTF-8 解码的输入字符串的反向转义副本，具体取决于 System.useCodePage 的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>输入字符串的转义副本。如果 System.useCodePage 为 <codeph>true</codeph>，则转义字符串采用系统代码页编码。如果 System.useCodePage 为 <codeph>false</codeph>，则转义字符串采用 UTF-8 编码。例如，如果 System.useCodePage 为 <codeph>false</codeph>，输入字符串“Crüe”在所有系统上都将被转义为“Cr%C3%BCe”。如果 system.useCodePage 为 <codeph>true</codeph>，并且系统使用拉丁语代码页，则“Crüe”将被转义为“Cr%FCe”。如果系统使用不包含字母“ü”的非拉丁语代码页，结果将可能为“Cr?e”。如果在 System.useCodePage 设置为 <codeph>true</codeph> 的情况下对“Cr%C3%BCe”进行反向转义，则在不同的系统上会生成不同的错误结果，比如在拉丁语系统上会生成“CrÃ¼e”。同样，在 System.useCodePage 设置为 <codeph>false</codeph> 的情况下对“Cr%FCe”进行反向转义可能会生成“Cre”、“Cr?e”或其它变体，具体取决于系统的代码页。	
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要反向转义的转义字符串。
	  
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  返回依据系统代码页或 UTF-8 解码的输入字符串的反向转义副本，具体取决于 System.useCodePage 的值。通过使用 System.useCodePage，将使播放器能够访问用本地代码页编码的旧内容，但只能在使用旧代码页的系统上访问。例如，在使用日语默认代码页的操作系统中，只能正确转义和反向转义以 <codeph>Shift-JIS</codeph> 编码的日语数据。
	  
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:flash.utils:clearInterval"><apiName>clearInterval</apiName><shortdesc>
 取消指定的 setInterval() 调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>设置为变量的 <codeph>setInterval()</codeph> 调用的 ID，如以下代码中所示：
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 取消指定的 <codeph>setInterval()</codeph> 调用。
 
 </apiDesc><example conref="examples\ClearIntervalExample.as"> 以下示例使用 <codeph>setInterval()</codeph> 方法创建一个计时间隔，以 1 秒的固定间隔调用 <codeph>myRepeatingFunction()</codeph> 方法。
 <p>每次调用 <codeph>myRepeatingFunction</codeph> 方法都会递增 <codeph>counter</codeph> 属性，当该属性等于 <codeph>stopCount</codeph> 属性时，调用 <codeph>clearInterval() </codeph> 方法（使用属性 <codeph>intervalId</codeph> 进行调用，该属性是对前面创建的间隔的引用 ID）。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class ClearIntervalExample extends Sprite {
        private var intervalDuration:Number = 1000; // duration between intervals, in milliseconds
        private var intervalId:uint;
        private var counter:uint     = 0;
        private var stopCount:uint     = 3;
        
        public function ClearIntervalExample() {
            intervalId = setInterval(myRepeatingFunction, intervalDuration, "Hello", "World");
        }

        public function myRepeatingFunction():void {
            trace(arguments[0] + " " + arguments[1]);

            counter++;
            if(counter == stopCount) {
                trace("Clearing Interval");
                clearInterval(intervalId);    
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/setInterval()"><linktext>setInterval()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:clearTimeout"><apiName>clearTimeout</apiName><shortdesc>
 取消指定的 setTimeout() 调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>设置为变量的 <codeph>setTimeout()</codeph> 调用的 ID，如以下代码中所示：
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 取消指定的 <codeph>setTimeout()</codeph> 调用。
 
 </apiDesc><example conref="examples\ClearTimeoutExample.as"> 以下示例使用 <codeph>setTimeout()</codeph> 方法在指定的延迟期之后调用另一个方法。
 <p>创建一个计数到一百万的循环。如果计算机处理此请求的速度比第二个请求到期的速度更快，<codeph>clearTimeout()</codeph> 将删除 <codeph>setTimeout()</codeph> 请求，将不调用 <codeph>myDelayedFunction()</codeph>。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class ClearTimeoutExample extends Sprite {
        private var delay:Number = 1000; // delay before calling myDelayedFunction
        private var intervalId:uint;
        private var count:uint = 1000000;
        
        public function ClearTimeoutExample() {
            intervalId = setTimeout(myDelayedFunction, delay);
            startCounting();
        }

        public function startCounting():void {
            var i:uint = 0;
            do {
                if(i == count-1) {
                    clearTimeout(intervalId);
                    trace("Your computer can count to " + count + " in less than " + delay/1000 + " seconds.");    
                }
                i++;
            } while(i &lt; count)            
        }
        
        public function myDelayedFunction():void {
            trace("Time expired.");
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/setTimeout()"><linktext>setTimeout()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:setInterval"><apiName>setInterval</apiName><shortdesc>
 以指定的间隔（以毫秒为单位）运行函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>超时进程的唯一数字标识符。使用此标识符可通过调用 <codeph>clearInterval()</codeph> 方法取消进程。
 
 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>closure</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要执行的函数的名称。不要包括引号或圆括号，并且不要指定要调用的函数的参数。例如，使用 <codeph>functionName</codeph>，而不要使用 <codeph>functionName()</codeph> 或 <codeph>functionName(param)</codeph>。
 
 </apiDesc></apiParam><apiParam><apiItemName>delay</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>间隔（以毫秒为单位）。 
 
 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>传递给 closure 函数的可选参数列表。
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 以指定的间隔（以毫秒为单位）运行函数。
 
 <p>作为使用 <codeph>setInterval()</codeph> 方法的替代方法，请考虑创建一个 Timer 对象，带有指定的间隔，并使用 0 作为 <codeph>repeatCount</codeph> 参数（这样可将计时器设置为无限制重复）。</p>
 
 <p>如果打算使用 <codeph>clearInterval()</codeph> 方法取消 <codeph>setInterval()</codeph> 调用，请确保将 <codeph>setInterval()</codeph> 调用分配给一个变量（<codeph>clearInterval()</codeph> 函数稍后将引用该变量）。如果不通过调用 <codeph>clearInterval()</codeph> 函数取消 <codeph>setInterval()</codeph> 调用，则不会将包含 setTimeout 闭包函数的对象作为垃圾回收。 </p>
 
 </apiDesc><example conref="examples\SetIntervalExample.as"> 以下示例使用 <codeph>setInterval()</codeph> 方法创建一个计时间隔，以 1 秒的固定间隔调用 <codeph>myRepeatingFunction()</codeph> 方法。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class SetIntervalExample extends Sprite {
        private var intervalDuration:Number = 1000; // duration between intervals, in milliseconds
        
        public function SetIntervalExample() {
            var intervalId:uint = setInterval(myRepeatingFunction, intervalDuration, "Hello", "World");
        }

        public function myRepeatingFunction():void {
            trace(arguments[0] + " " + arguments[1]);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/clearInterval()"><linktext>clearInterval()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:setTimeout"><apiName>setTimeout</apiName><shortdesc>
 在指定的延迟（以毫秒为单位）后运行指定的函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>超时进程的唯一数字标识符。使用此标识符可通过调用 <codeph>clearTimeout()</codeph> 方法取消进程。
 
 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>closure</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要执行的函数的名称。不要包括引号或圆括号，并且不要指定要调用的函数的参数。例如，使用 <codeph>functionName</codeph>，而不要使用 <codeph>functionName()</codeph> 或 <codeph>functionName(param)</codeph>。
 
 </apiDesc></apiParam><apiParam><apiItemName>delay</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>执行函数之前的延迟时间（以毫秒为单位）。 
 
 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>传递给 closure 函数的可选参数列表。
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 在指定的延迟（以毫秒为单位）后运行指定的函数。
 
 <p>作为使用此方法的替代方法，请考虑创建一个 Timer 对象，带有指定的间隔，并使用 1 作为 <codeph>repeatCount</codeph> 参数（这样可将计时器设置为只运行一次）。</p>
 
 <p>如果打算使用 <codeph>clearTimeout()</codeph> 方法取消 <codeph>setTimeout()</codeph> 调用，请确保将 <codeph>setTimeout()</codeph> 调用分配给一个变量（<codeph>clearTimeout()</codeph> 函数稍后将引用该变量）。如果不通过调用 <codeph>clearTimeout()</codeph> 函数取消 <codeph>setTimeout()</codeph> 调用，则不会将包含设置的超时 closure 函数的对象作为垃圾回收。 </p>
 
 </apiDesc><example conref="examples\SetTimeoutExample.as"> 以下示例使用 <codeph>setTimeout()</codeph> 方法在指定的延迟期之后调用另一个方法。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class SetTimeoutExample extends Sprite {
        private var delay:Number = 1000; // delay before calling myDelayedFunction
        
        public function SetTimeoutExample() {
            var intervalId:uint = setTimeout(myDelayedFunction, delay, "Hello", "World");
        }

        public function myDelayedFunction():void {
            trace(arguments[0] + " " + arguments[1]);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/clearTimeout()"><linktext>clearTimeout()</linktext></link></related-links></apiOperation><apiClassifier id="flash.utils:Timer"><apiName>Timer</apiName><shortdesc>
 Timer 类是计时器的接口，它使您能按指定的时间序列运行代码。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Timer 类是计时器的接口，它使您能按指定的时间序列运行代码。使用 <codeph>start()</codeph> 方法来启动计时器。为 <codeph>timer</codeph> 事件添加事件侦听器，以便将代码设置为按计时器间隔运行。
 
 <p>可以创建 Timer 对象以运行一次或按指定间隔重复运行，从而按计划执行代码。<ph platform="actionscript">根据 SWF 文件的帧速率或 Flash Player 的环境（可用内存及其它因素），Flash Player 或 Adobe AIR 分派事件的间隔可能稍有不同。例如，如果某个 SWF 文件设置为以每秒 10 帧 (fps)（也就是 100 毫秒的间隔）的速度播放，但计时器设置为在 80 毫秒时触发事件，则将按接近于 100 毫秒的间隔触发事件。</ph> <ph platform="javascript">根据应用程序的内部帧速率，应用程序分派事件的间隔可能稍有不同。</ph>大量耗费内存的脚本也可能使事件发生偏差。</p>
 
 </apiDesc><example conref="examples\TimerExample.as"> 以下示例使用 <codeph>TimerExample</codeph> 类来说明如何将侦听器方法 <codeph>timerHandler()</codeph> 设置为侦听要分派的新 TimerEvent。计时器将在调用 <codeph>start()</codeph> 时启动，并且之后将分派计时器事件。  
<codeblock>
package {
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.display.Sprite;

    public class TimerExample extends Sprite {

        public function TimerExample() {
            var myTimer:Timer = new Timer(1000, 2);
            myTimer.addEventListener("timer", timerHandler);
            myTimer.start();
        }

        public function timerHandler(event:TimerEvent):void {
            trace("timerHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.utils:Timer_flash.events.TimerEvent.TIMER_COMPLETE_timerComplete"><apiName>timerComplete</apiName><shortdesc>
 每当它完成 Timer.repeatCount 设置的请求数后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TimerEvent.TIMER_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.TimerEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 每当它完成 <codeph>Timer.repeatCount</codeph> 设置的请求数后分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.utils:Timer_flash.events.TimerEvent.TIMER_timer"><apiName>timer</apiName><shortdesc>
 每当 Timer 对象达到根据 Timer.delay 属性指定的间隔时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TimerEvent.TIMER</apiEventType><adobeApiEventClassifier>flash.events.TimerEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 每当 Timer 对象达到根据 <codeph>Timer.delay</codeph> 属性指定的间隔时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.utils:Timer:Timer"><apiName>Timer</apiName><shortdesc>
	 使用指定的 delay 和 repeatCount 状态构造新的 Timer 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>如果指定的延迟为负数或不是有限数
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiParam><apiItemName>delay</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>计时器事件间的延迟（以毫秒为单位）。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>repeatCount</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>指定重复次数。如果为 0，则计时器重复无限次数。如果不为 0，则将运行计时器，运行次数为指定的次数，然后停止。
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 使用指定的 <codeph>delay</codeph> 和 <codeph>repeatCount</codeph> 状态构造新的 Timer 对象。
	 
	 <p>计时器不会自动启动；必须调用 <codeph>start()</codeph> 方法来启动它。</p>
	 
	 </apiDesc><example conref="examples\Timer_constructorExample.as"> 在下面的示例中，为用户提供了 90 秒的时间将响应写入到输入文本字段中。此外，每隔 30 秒显示一个状态消息，可让用户了解还剩下多少秒。
 
 <p>创建了一个 Timer 对象，它在 30 秒内启动（将延迟设置为 30000 毫秒），并在总共 90 秒的时间内重复启动 3 次。（计时器将在第 3 次后停止。）</p>
 
 <p>为 <codeph>myTimer</codeph> 计时器添加了两个事件侦听器。第一个事件侦听器是由 <codeph>TimerEvent.TIMER</codeph> 事件触发的，每次启动计时器时都会发生此事件。<codeph>timerHandler()</codeph> 方法将更改 <codeph>statusTextField</codeph> 文本字段的文本以反映所剩的秒数。 </p>
 <p><b>注意：</b>Timer 类通过增大 <codeph>currentCount</codeph> 属性中的数字来跟踪计时器需要启动的次数 (<codeph>repeats</codeph>)。</p> 
 
 <p>在最后一次调用计时器后，将分派 <codeph>TimerEvent.TIMER_COMPLETE</codeph> 事件并调用 <codeph>completeHandler()</codeph> 方法。<codeph>completeHandler()</codeph> 方法将 <codeph>inputTextField</codeph> 文本字段的类型从 <codeph>INPUT</codeph> 更改为 <codeph>DYNAMIC</codeph>，这意味着用户不再可以输入或更改文本。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.Event;

    public class Timer_constructorExample extends Sprite {
            private var statusTextField:TextField = new TextField();        
            private var inputTextField:TextField = new TextField();
            private var delay:uint = 30000;
            private var repeat:uint = 3;
            private var myTimer:Timer = new Timer(delay, repeat);
            
        public function Timer_constructorExample() {
            inputTextField.x = 10;
            inputTextField.y = 10;
            inputTextField.border = true;
            inputTextField.background = true;
            inputTextField.height = 200;
            inputTextField.width = 200;
            inputTextField.multiline = true;
            inputTextField.wordWrap = true;
            inputTextField.type = TextFieldType.INPUT;

            statusTextField.x = 10;
            statusTextField.y = 220;
            statusTextField.background = true;
            statusTextField.autoSize = TextFieldAutoSize.LEFT;   

            myTimer.start(); 
            statusTextField.text = "You have " + ((delay * repeat) / 1000) 
                                 + " seconds to write your response.";

            myTimer.addEventListener(TimerEvent.TIMER, timerHandler);
            myTimer.addEventListener(TimerEvent.TIMER_COMPLETE, completeHandler);

            addChild(inputTextField);
            addChild(statusTextField);
        }

        private function timerHandler(e:TimerEvent):void{
            repeat--;
            statusTextField.text = ((delay * repeat) / 1000) + " seconds left.";
        }

        private function completeHandler(e:TimerEvent):void {
            statusTextField.text = "Times Up.";
            inputTextField.type = TextFieldType.DYNAMIC;    
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiOperation id="flash.utils:Timer:reset"><apiName>reset</apiName><shortdesc>
   	 如果计时器正在运行，则停止计时器，并将 currentCount 属性设回为 0，这类似于秒表的重置按钮。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
   	 如果计时器正在运行，则停止计时器，并将 <codeph>currentCount</codeph> 属性设回为 0，这类似于秒表的重置按钮。然后，在调用 <codeph>start()</codeph> 后，将运行计时器实例，运行次数为指定的重复次数（由 <codeph>repeatCount</codeph> 值设置）。
   	 
   	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Timer/stop()"><linktext>Timer.stop()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Timer:start"><apiName>start</apiName><shortdesc>
	 如果计时器尚未运行，则启动计时器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 如果计时器尚未运行，则启动计时器。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:Timer:stop"><apiName>stop</apiName><shortdesc>
	 停止计时器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 停止计时器。如果在调用 <codeph>stop()</codeph> 后调用 <codeph>start()</codeph>，则将继续运行计时器实例，运行次数为<i>剩余的 </i>重复次数（由 <codeph>repeatCount</codeph> 属性设置）。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Timer/reset()"><linktext>Timer.reset()</linktext></link></related-links></apiOperation><apiValue id="flash.utils:Timer:currentCount:get"><apiName>currentCount</apiName><shortdesc>
	 计时器从 0 开始后触发的总次数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 计时器从 0 开始后触发的总次数。如果已重置了计时器，则只会计入重置后的触发次数。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Timer:delay:get"><apiName>delay</apiName><shortdesc>
	 计时器事件间的延迟（以毫秒为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>如果指定的延迟为负数或不是有限数，则将引发异常。
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 计时器事件间的延迟（以毫秒为单位）。如果在计时器正在运行时设置延迟间隔，则计时器将按相同的 <codeph>repeatCount</codeph> 迭代重新启动。
     
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Timer:repeatCount:get"><apiName>repeatCount</apiName><shortdesc>
	 设置的计时器运行总次数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 设置的计时器运行总次数。如果重复计数设置为 0，则计时器将持续不断运行，直至调用了 <codeph>stop()</codeph> 方法或程序停止。如果重复计数不为 0，则将运行计时器，运行次数为指定的次数。如果设置的 <codeph>repeatCount</codeph> 总数等于或小于 <codeph>currentCount</codeph>，则计时器将停止并且不会再次触发。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Timer:running:get"><apiName>running</apiName><shortdesc>
     计时器的当前状态；如果计时器正在运行，则为 true，否则为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     计时器的当前状态；如果计时器正在运行，则为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:CompressionAlgorithm"><apiName>CompressionAlgorithm</apiName><shortdesc>
 CompressionAlgorithm 类为压缩和解压缩选项的名称定义字符串常量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 CompressionAlgorithm 类为压缩和解压缩选项的名称定义字符串常量。这些常量是 <codeph>ByteArray.compress()</codeph> 和 <codeph>ByteArray.uncompress()</codeph> 方法的 <codeph>algorithm</codeph> 参数所使用的值。
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.utils.xml#ByteArray/compress()"><linktext>flash.utils.ByteArray.compress()</linktext></link><link href="flash.utils.xml#ByteArray/uncompress()"><linktext>flash.utils.ByteArray.uncompress()</linktext></link></related-links><apiValue id="flash.utils:CompressionAlgorithm:DEFLATE"><apiName>DEFLATE</apiName><shortdesc>
	 定义用于 deflate 压缩算法的字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>deflate</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 定义用于 deflate 压缩算法的字符串。
	 
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:CompressionAlgorithm:ZLIB"><apiName>ZLIB</apiName><shortdesc>
	定义用于 zlib 压缩算法的字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>zlib</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	定义用于 zlib 压缩算法的字符串。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:IDataInput"><apiName>IDataInput</apiName><shortdesc>
IDataInput 接口提供一组用于读取二进制数据的方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
IDataInput 接口提供一组用于读取二进制数据的方法。此接口是写入二进制数据的 IDataOutput 接口的 I/O 对应接口。
<p>默认情况下，所有 IDataInput 和 IDataOutput 操作均为“bigEndian”（序列中的最高有效字节存储在最低或第一个存储地址），而且都不分块。如果可用数据不足，则会引发 <codeph>EOFError</codeph> 异常。使用 <codeph>IDataInput.bytesAvailable</codeph> 属性来确定可供读取的数据有多少。</p>

<p>符号扩展名仅在读取数据时有效，写入数据时无效。因此，无需单独的写入方法就可以使用 <codeph>IDataInput.readUnsignedByte()</codeph> 和 <codeph>IDataInput.readUnsignedShort()</codeph>。换言之：</p>
<ul><li>将 <codeph>IDataOutput.writeByte()</codeph> 与 <codeph>IDataInput.readUnsignedByte()</codeph> 和 <codeph>IDataInput.readByte()</codeph> 一起使用。</li>
<li>将 <codeph>IDataOutput.writeShort()</codeph> 与 <codeph>IDataInput.readUnsignedShort()</codeph> 和 <codeph>IDataInput.readShort()</codeph> 一起使用。</li></ul>

</apiDesc><example conref="examples\DataInputExample.as"> 以下示例使用 <codeph>DataInputExample</codeph> 类将布尔值和 pi 的双精度浮点表示形式写入字节数组。这是使用以下步骤完成的：
 <ol>
     <li>声明新的 ByteArray 对象实例 <codeph>byteArr</codeph>。</li>
     <li>写入布尔值 <codeph>false</codeph> 的字节等效值和数学值 pi 的双精度浮点等效值。</li>
     <li>重新读取布尔值和双精度浮点数。</li>
 </ol>
 
 <p>注意如何在末尾添加一段代码以检查文件结尾错误，确保读取的字节流没有超出文件结尾。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.errors.EOFError;

    public class DataInputExample extends Sprite {        
        public function DataInputExample() {
            var byteArr:ByteArray = new ByteArray();

            byteArr.writeBoolean(false);
            byteArr.writeDouble(Math.PI);
            
            byteArr.position = 0;

            try {
                trace(byteArr.readBoolean()); // false
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());    // 3.141592653589793
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());
            } 
            catch(e:EOFError) {
                trace(e);        // EOFError: Error #2030: End of file was encountered.
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#IDataOutput"><linktext>IDataOutput interface</linktext></link><link href="flash.utils.xml#IDataInput/endian"><linktext>endian</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>FileStream 类</linktext></link><link href="flash.net.xml#Socket"><linktext>Socket 类</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream 类</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>ByteArray 类</linktext></link><link href="flash.errors.xml#EOFError"><linktext>EOFError 类</linktext></link></related-links><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readBoolean"><apiName>readBoolean</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取布尔值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个布尔值，如果字节不为零，则为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取布尔值。读取单个字节，如果字节非零，则返回 <codeph>true</codeph>，否则返回 <codeph>false</codeph>。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readByte"><apiName>readByte</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取带符号的字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 -128 到 127。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取带符号的字节。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readBytes"><apiName>readBytes</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取 length 参数指定的数据字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>要将数据读入的 <codeph>ByteArray</codeph> 对象。
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc><codeph>bytes</codeph> 参数中的偏移，应从该位置开始读取数据。
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>要读取的字节数。默认值 0 导致读取所有可用的数据。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取 <codeph>length</codeph> 参数指定的数据字节数。将从 <codeph>offset</codeph> 指定的位置开始，将字节读入 <codeph>bytes</codeph> 参数指定的 ByteArray 对象。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readDouble"><apiName>readDouble</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取 IEEE 754 双精度浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个 IEEE 754 双精度浮点数。
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取 IEEE 754 双精度浮点数。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readFloat"><apiName>readFloat</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取 IEEE 754 单精度浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个 IEEE 754 单精度浮点数。
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取 IEEE 754 单精度浮点数。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readInt"><apiName>readInt</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取带符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 -2147483648 到 2147483647。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取带符号的 32 位整数。
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
	 使用指定的字符集从文件流、字节流或字节数组中读取指定长度的多字节字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>IDataInput, IDataInput.readMultiByte, readMultiByte
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>UTF-8 编码的字符串。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要从字节流中读取的字节数。
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>表示用于解释字节的字符集的字符串。可能的字符集字符串包括 <codeph>"shift-jis"</codeph>、<codeph>"cn-gb"</codeph>、<codeph>"iso-8859-1"</codeph>”等。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character Sets</xref>。 
	 
     <p><b>注意：</b>如果当前系统无法识别 <codeph>charSet</codeph> 参数的值，则 <ph platform="actionscript">Adobe<sup>®</sup> Flash<sup>®</sup> Player 或 </ph>Adobe<sup>®</sup> AIR<sup>®</sup> 将采用系统的默认代码页作为字符集。例如，<codeph>charSet</codeph> 参数的值（如在使用 <codeph>01</codeph> 而不是 <codeph>1</codeph> 的 <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> 中）可能适用于您的开发计算机，而不适用于其它计算机。在其它计算机上，<ph platform="actionscript">Flash Player 或</ph> AIR 运行时将使用系统的默认代码页。</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 使用指定的字符集从文件流、字节流或字节数组中读取指定长度的多字节字符串。
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readObject"><apiName>readObject</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取以 AMF 序列化格式编码的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>反序列化的对象
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取以 AMF 序列化格式编码的对象。
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#IDataInput/objectEncoding"><linktext>objectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readShort"><apiName>readShort</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取带符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 -32768 到 32767。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取带符号的 16 位整数。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUTF"><apiName>readUTF</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取 UTF-8 字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>由字符的字节表示形式生成的 UTF-8 字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取 UTF-8 字符串。假定字符串的前缀是无符号的短整型（以字节表示长度）。
	 
	 <p>此方法类似于 Java IDataInput 接口中的 <codeph>readUTF()</codeph> 方法。<sup/></p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
	 从字节流或字节数组中读取 UTF-8 字节序列，并返回一个字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>由指定长度字符的字节表示形式生成的 UTF-8 字符串。	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要读取的字节数。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从字节流或字节数组中读取 UTF-8 字节序列，并返回一个字符串。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取无符号的字节。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 0 到 255。 	   
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取无符号的字节。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取无符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 0 到 4294967295。
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取无符号的 32 位整数。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
	 从文件流、字节流或字节数组中读取无符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>没有足够的数据可供读取。
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 0 到 65535。 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 从文件流、字节流或字节数组中读取无符号的 16 位整数。
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.utils:IDataInput:flash.utils:IDataInput:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
	 返回可在输入缓冲区中读取的数据的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 返回可在输入缓冲区中读取的数据的字节数。在尝试使用某一种读取方法读取数据之前，用户代码必须调用 <codeph>bytesAvailable</codeph> 以确保有足够的数据可用。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:IDataInput:flash.utils:IDataInput:endian:get"><apiName>endian</apiName><shortdesc>
	 数据的字节顺序：为 Endian 类中的 BIG_ENDIAN 或 LITTLE_ENDIAN 常量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 数据的字节顺序：为 Endian 类中的 <codeph>BIG_ENDIAN</codeph> 或 <codeph>LITTLE_ENDIAN</codeph> 常量。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>Endian 类</linktext></link></related-links></apiValue><apiValue id="flash.utils:IDataInput:flash.utils:IDataInput:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     用于确定在使用 readObject() 方法写入或读取二进制数据时是使用 AMF3 格式还是 AMF0 格式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     用于确定在使用 <codeph>readObject()</codeph> 方法写入或读取二进制数据时是使用 AMF3 格式还是 AMF0 格式。该值为 ObjectEncoding 类中的常数。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#IDataInput/readObject()"><linktext>readObject()</linktext></link><link href="flash.utils.xml#IDataOutput/writeObject()"><linktext>IDataOutput.writeObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding 类</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.utils:Dictionary"><apiName>Dictionary</apiName><shortdesc>
 Dictionary 类用于创建属性的动态集合，该集合使用全等运算符 (===) 进行键比较。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Dictionary 类用于创建属性的动态集合，该集合使用全等运算符 (<codeph>===</codeph>) 进行键比较。将对象用作键时，会使用对象的标识来查找对象，而不是使用在对象上调用 <codeph>toString()</codeph> 所返回的值。Dictionary 集合中的原始（内置）对象（例如 Number）的行为方式与它们作为常规对象的属性时的行为方式相同。
 
 <p platform="actionscript">以下语句显示了一个 Dictionary 对象和一个 key 对象之间的关系：</p>
 
 <codeblock platform="actionscript">
 var dict:Dictionary = new Dictionary();
 var obj:Object = new Object();
 var key:Object = new Object();
 key.toString = function() { return "key" }
  
 dict[key] = "Letters";
 obj["key"] = "Letters";
  
 dict[key] == "Letters"; // true
 obj["key"] == "Letters"; // true 
 obj[key] == "Letters"; // true because key == "key" is true because key.toString == "key"
 dict["key"] == "Letters"; // false because "key" === key is false
 delete dict[key]; //removes the key
 </codeblock>
 
 <p><b>重要说明：</b>Dictionary 类只可用于 ActionScript 3.0 代码（运行于 SWF 内容中）。它不可用于 JavaScript 代码（运行于 Adobe<sup>®</sup> AIR™ 中）。</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="../../operators.html#strict_equality"><linktext>=== (strict equality)</linktext></link></related-links><apiConstructor id="flash.utils:Dictionary:Dictionary"><apiName>Dictionary</apiName><shortdesc>
	 创建新的 Dictionary 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>weakKeys</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指示 Dictionary 对象在对象键上使用“弱”引用。如果对某个对象的唯一引用位于指定的 Dictionary 对象中，则键符合垃圾回收的条件，并且在回收对象时会被从表中删除。
  	 
  	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建新的 Dictionary 对象。要从 Dictionary 对象中删除键，请使用 <codeph>delete</codeph> 运算符。
  	 
  	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier></apiPackage>