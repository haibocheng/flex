////////////////////////////////////////////////////////////////////////////////
//
//  ADOBE SYSTEMS INCORPORATED
//  Copyright 2006-2008 Adobe Systems Incorporated
//  All Rights Reserved.
//
//  NOTICE: Adobe permits you to use, modify, and distribute this file
//  in accordance with the terms of the license agreement accompanying it.
//
////////////////////////////////////////////////////////////////////////////////
package flex.webtier.server.j2ee.jsp;

import flex.webtier.services.ServiceFactory;
import flex.webtier.services.extensions.ExtensionManager;
import flex.webtier.util.Trace;
import flex.webtier.server.j2ee.cache.CacheKeyUtils;
import flex.webtier.server.j2ee.BaseCompileFilter;
import flex.webtier.server.j2ee.BrowserCacheFilter;
import flex.webtier.server.j2ee.CompileAgent;
import flex.webtier.server.j2ee.MxmlContext;
import flex.webtier.server.j2ee.MxmlFilter;
import flex.webtier.server.j2ee.SwfRequestHandler;
import flex.webtier.server.j2ee.RecompileFilter;
import flex.webtier.server.j2ee.SwfRenderFilter;
import flex.webtier.server.j2ee.SwfServlet;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * This class is used by the SwfServlet to handle requests for swfs that originated
 * with mxml code generated by the jsp tags.
 * The logic is not included in the SwfServlet directly but is loaded using
 * reflection. This allows separation between the webtier code and the jsp code.
 */
public class JspSwfRequestHandler implements SwfRequestHandler
{
    private CompileAgent compileAgent;
    private MxmlFilter jspCompileChain;
    private boolean logCompilerErrors;
    private String mxmlExt;
    private String swdExt;
    private String swfExt;

    public JspSwfRequestHandler()
    {
        initializeExtensions();
        jspCompileChain = createJspCompileChain();
        logCompilerErrors = ServiceFactory.getConfigurator().getServerConfiguration().getDebuggingConfiguration().logCompilerErrors();
        compileAgent = new CompileAgent();
    }


    private void initializeExtensions()
    {
        ExtensionManager extensionManager = ServiceFactory.getExtensionManager();
        mxmlExt = extensionManager.getMxmlExt();
        swdExt = extensionManager.getSwdExt();
        swfExt = extensionManager.getSwfExt();
    }

    private MxmlFilter createJspCompileChain()
    {

        // process recompile=true query param
        RecompileFilter recompileFilter = new RecompileFilter();

        // return 304 if the browser content is up-to-date
        BrowserCacheFilter browserCacheFilter = new BrowserCacheFilter();

        BaseCompileFilter compileFilter;
        compileFilter = new JspCompileFilter(swfExt);

        // writes swf/swd to response and render warnings/errors to console/log
        SwfRenderFilter swfRenderFilter = new SwfRenderFilter(swfExt, swdExt);

        recompileFilter.setNext(browserCacheFilter);
        browserCacheFilter.setNext(compileFilter);
        compileFilter.setNext(swfRenderFilter);

        return recompileFilter;
    }

    public void processRequest(HttpServletRequest request, HttpServletResponse response, ServletContext servletContext) throws IOException
    {

        MxmlContext context = new MxmlContext();
        context.setRequest(request);
        context.setResponse(response);
        context.setServletContext(servletContext);
        context.setPageTitle(request.getServletPath());

        String uri = request.getServletPath();
        String dependencyKey = CacheKeyUtils.generateJspCacheKey(request, SourceCache.uriToKey(uri));
        SourceCache sourceCache = SourceCache.getInstance(servletContext);
        SourceCacheEntry sourceEntry = sourceCache.getEntry(dependencyKey);
        if (sourceEntry != null)
        {
            String jspFilename = sourceEntry.realPath;
            String parentDir = new File(jspFilename).getParent();
            context.setAppPath(parentDir + File.separator + "jsp" + sourceEntry.sourceHash + mxmlExt);
            context.setParentDir(parentDir);
            compileAgent.setupMxmlContextKeys(servletContext, context, request);
            context.setSourceCodeLoader(new JspSourceCodeLoader(sourceEntry.sourceCode));

            try
            {
                if (!ServiceFactory.getLicenseService().isMxmlCompileEnabled())
                {
                    response.sendError(481, "The current license does not support this feature.");
                    ServiceFactory.getLogger().logError("The current license does not support this feature. request=" + request.getServletPath());
                    return;
                }

                compileAgent.setupCompileEventLogger(context, request);

                jspCompileChain.invoke(context);
            }
            catch (FileNotFoundException fnfe)
            {
                response.sendError(HttpServletResponse.SC_NOT_FOUND);
                if (logCompilerErrors)
                {
                    ServiceFactory.getLogger().logError(fnfe.getMessage(), fnfe);
                }
            }
            catch (Throwable t)
            {
                if (Trace.error)
                {
                    t.printStackTrace();
                }

                SwfServlet.sendNotAvailableResponse(response, "Unknown error", "Unknown error " + request.getServletPath() + ": " + t.getMessage(), t);
            }
        }
    }

}